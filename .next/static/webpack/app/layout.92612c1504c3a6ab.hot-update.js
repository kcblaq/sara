/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fkc%2FDocuments%2FProjects%2FSEO%2Fsara%2Fsrc%2Fapp%2Fglobals.css&modules=%2FUsers%2Fkc%2FDocuments%2FProjects%2FSEO%2Fsara%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22src%2Fapp%2Flayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=%2FUsers%2Fkc%2FDocuments%2FProjects%2FSEO%2Fsara%2Fsrc%2Fredux%2Ffeatures%2Fprovider.tsx&server=false!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fkc%2FDocuments%2FProjects%2FSEO%2Fsara%2Fsrc%2Fapp%2Fglobals.css&modules=%2FUsers%2Fkc%2FDocuments%2FProjects%2FSEO%2Fsara%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22src%2Fapp%2Flayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=%2FUsers%2Fkc%2FDocuments%2FProjects%2FSEO%2Fsara%2Fsrc%2Fredux%2Ffeatures%2Fprovider.tsx&server=false! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/globals.css */ \"(app-pages-browser)/./src/app/globals.css\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"src/app/layout.tsx\\\",\\\"import\\\":\\\"Inter\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"inter\\\"}\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/redux/features/provider.tsx */ \"(app-pages-browser)/./src/redux/features/provider.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRmtjJTJGRG9jdW1lbnRzJTJGUHJvamVjdHMlMkZTRU8lMkZzYXJhJTJGc3JjJTJGYXBwJTJGZ2xvYmFscy5jc3MmbW9kdWxlcz0lMkZVc2VycyUyRmtjJTJGRG9jdW1lbnRzJTJGUHJvamVjdHMlMkZTRU8lMkZzYXJhJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmZvbnQlMkZnb29nbGUlMkZ0YXJnZXQuY3NzJTNGJTdCJTIycGF0aCUyMiUzQSUyMnNyYyUyRmFwcCUyRmxheW91dC50c3glMjIlMkMlMjJpbXBvcnQlMjIlM0ElMjJJbnRlciUyMiUyQyUyMmFyZ3VtZW50cyUyMiUzQSU1QiU3QiUyMnN1YnNldHMlMjIlM0ElNUIlMjJsYXRpbiUyMiU1RCU3RCU1RCUyQyUyMnZhcmlhYmxlTmFtZSUyMiUzQSUyMmludGVyJTIyJTdEJm1vZHVsZXM9JTJGVXNlcnMlMkZrYyUyRkRvY3VtZW50cyUyRlByb2plY3RzJTJGU0VPJTJGc2FyYSUyRnNyYyUyRnJlZHV4JTJGZmVhdHVyZXMlMkZwcm92aWRlci50c3gmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxvS0FBOEY7QUFDOUYsMGJBQStPO0FBQy9PIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/NGU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9rYy9Eb2N1bWVudHMvUHJvamVjdHMvU0VPL3NhcmEvc3JjL2FwcC9nbG9iYWxzLmNzc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2tjL0RvY3VtZW50cy9Qcm9qZWN0cy9TRU8vc2FyYS9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP3tcXFwicGF0aFxcXCI6XFxcInNyYy9hcHAvbGF5b3V0LnRzeFxcXCIsXFxcImltcG9ydFxcXCI6XFxcIkludGVyXFxcIixcXFwiYXJndW1lbnRzXFxcIjpbe1xcXCJzdWJzZXRzXFxcIjpbXFxcImxhdGluXFxcIl19XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwiaW50ZXJcXFwifVwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2tjL0RvY3VtZW50cy9Qcm9qZWN0cy9TRU8vc2FyYS9zcmMvcmVkdXgvZmVhdHVyZXMvcHJvdmlkZXIudHN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fkc%2FDocuments%2FProjects%2FSEO%2Fsara%2Fsrc%2Fapp%2Fglobals.css&modules=%2FUsers%2Fkc%2FDocuments%2FProjects%2FSEO%2Fsara%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%22path%22%3A%22src%2Fapp%2Flayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=%2FUsers%2Fkc%2FDocuments%2FProjects%2FSEO%2Fsara%2Fsrc%2Fredux%2Ffeatures%2Fprovider.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\"); //# sourceMappingURL=process.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxpQkFBaUJDO0FBQ3JCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQyxDQUFDSCxrQkFBa0JJLHFCQUFNQSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlMLGdCQUFnQk0sR0FBRyxLQUFLLE9BQVEsRUFBQ0wsbUJBQW1CRyxxQkFBTUEsQ0FBQ0MsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJSixpQkFBaUJLLEdBQUcsTUFBTSxXQUFXRixxQkFBTUEsQ0FBQ0MsT0FBTyxHQUFHRSxtQkFBT0EsQ0FBQyw0R0FBNEIsR0FFelAsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Y2E2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOlsiX2dsb2JhbF9wcm9jZXNzIiwiX2dsb2JhbF9wcm9jZXNzMSIsIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWwiLCJwcm9jZXNzIiwiZW52IiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(()=>{\n    \"use strict\";\n    var e = {\n        686: (e, r, t)=>{\n            var n = t(808);\n            var i = Object.create(null);\n            var a = typeof document === \"undefined\";\n            var o = Array.prototype.forEach;\n            function debounce(e, r) {\n                var t = 0;\n                return function() {\n                    var n = this;\n                    var i = arguments;\n                    var a = function functionCall() {\n                        return e.apply(n, i);\n                    };\n                    clearTimeout(t);\n                    t = setTimeout(a, r);\n                };\n            }\n            function noop() {}\n            function getCurrentScriptUrl(e) {\n                var r = i[e];\n                if (!r) {\n                    if (document.currentScript) {\n                        r = document.currentScript.src;\n                    } else {\n                        var t = document.getElementsByTagName(\"script\");\n                        var a = t[t.length - 1];\n                        if (a) {\n                            r = a.src;\n                        }\n                    }\n                    i[e] = r;\n                }\n                return function(e) {\n                    if (!r) {\n                        return null;\n                    }\n                    var t = r.split(/([^\\\\/]+)\\.js$/);\n                    var i = t && t[1];\n                    if (!i) {\n                        return [\n                            r.replace(\".js\", \".css\")\n                        ];\n                    }\n                    if (!e) {\n                        return [\n                            r.replace(\".js\", \".css\")\n                        ];\n                    }\n                    return e.split(\",\").map(function(e) {\n                        var t = new RegExp(\"\".concat(i, \"\\\\.js$\"), \"g\");\n                        return n(r.replace(t, \"\".concat(e.replace(/{fileName}/g, i), \".css\")));\n                    });\n                };\n            }\n            function updateCss(e, r) {\n                if (!r) {\n                    if (!e.href) {\n                        return;\n                    }\n                    r = e.href.split(\"?\")[0];\n                }\n                if (!isUrlRequest(r)) {\n                    return;\n                }\n                if (e.isLoaded === false) {\n                    return;\n                }\n                if (!r || !(r.indexOf(\".css\") > -1)) {\n                    return;\n                }\n                e.visited = true;\n                var t = e.cloneNode();\n                t.isLoaded = false;\n                t.addEventListener(\"load\", function() {\n                    if (t.isLoaded) {\n                        return;\n                    }\n                    t.isLoaded = true;\n                    e.parentNode.removeChild(e);\n                });\n                t.addEventListener(\"error\", function() {\n                    if (t.isLoaded) {\n                        return;\n                    }\n                    t.isLoaded = true;\n                    e.parentNode.removeChild(e);\n                });\n                t.href = \"\".concat(r, \"?\").concat(Date.now());\n                if (e.nextSibling) {\n                    e.parentNode.insertBefore(t, e.nextSibling);\n                } else {\n                    e.parentNode.appendChild(t);\n                }\n            }\n            function getReloadUrl(e, r) {\n                var t;\n                e = n(e, {\n                    stripWWW: false\n                });\n                r.some(function(n) {\n                    if (e.indexOf(r) > -1) {\n                        t = n;\n                    }\n                });\n                return t;\n            }\n            function reloadStyle(e) {\n                if (!e) {\n                    return false;\n                }\n                var r = document.querySelectorAll(\"link\");\n                var t = false;\n                o.call(r, function(r) {\n                    if (!r.href) {\n                        return;\n                    }\n                    var n = getReloadUrl(r.href, e);\n                    if (!isUrlRequest(n)) {\n                        return;\n                    }\n                    if (r.visited === true) {\n                        return;\n                    }\n                    if (n) {\n                        updateCss(r, n);\n                        t = true;\n                    }\n                });\n                return t;\n            }\n            function reloadAll() {\n                var e = document.querySelectorAll(\"link\");\n                o.call(e, function(e) {\n                    if (e.visited === true) {\n                        return;\n                    }\n                    updateCss(e);\n                });\n            }\n            function isUrlRequest(e) {\n                if (!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)) {\n                    return false;\n                }\n                return true;\n            }\n            e.exports = function(e, r) {\n                if (a) {\n                    console.log(\"no window.document found, will not HMR CSS\");\n                    return noop;\n                }\n                var t = getCurrentScriptUrl(e);\n                function update() {\n                    var e = t(r.filename);\n                    var n = reloadStyle(e);\n                    if (r.locals) {\n                        console.log(\"[HMR] Detected local css modules. Reload all css\");\n                        reloadAll();\n                        return;\n                    }\n                    if (n) {\n                        console.log(\"[HMR] css reload %s\", e.join(\" \"));\n                    } else {\n                        console.log(\"[HMR] Reload all css\");\n                        reloadAll();\n                    }\n                }\n                return debounce(update, 50);\n            };\n        },\n        808: (e)=>{\n            function normalizeUrl(e) {\n                return e.reduce(function(e, r) {\n                    switch(r){\n                        case \"..\":\n                            e.pop();\n                            break;\n                        case \".\":\n                            break;\n                        default:\n                            e.push(r);\n                    }\n                    return e;\n                }, []).join(\"/\");\n            }\n            e.exports = function(e) {\n                e = e.trim();\n                if (/^data:/i.test(e)) {\n                    return e;\n                }\n                var r = e.indexOf(\"//\") !== -1 ? e.split(\"//\")[0] + \"//\" : \"\";\n                var t = e.replace(new RegExp(r, \"i\"), \"\").split(\"/\");\n                var n = t[0].toLowerCase().replace(/\\.$/, \"\");\n                t[0] = \"\";\n                var i = normalizeUrl(t);\n                return r + n + i;\n            };\n        }\n    };\n    var r = {};\n    function __nccwpck_require__(t) {\n        var n = r[t];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = r[t] = {\n            exports: {}\n        };\n        var a = true;\n        try {\n            e[t](i, i.exports, __nccwpck_require__);\n            a = false;\n        } finally{\n            if (a) delete r[t];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(686);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBSztJQUFhLElBQUlBLElBQUU7UUFBQyxLQUFJLENBQUNBLEdBQUVDLEdBQUVDO1lBQUssSUFBSUMsSUFBRUQsRUFBRTtZQUFLLElBQUlFLElBQUVDLE9BQU9DLE1BQU0sQ0FBQztZQUFNLElBQUlDLElBQUUsT0FBT0MsYUFBVztZQUFZLElBQUlDLElBQUVDLE1BQU1DLFNBQVMsQ0FBQ0MsT0FBTztZQUFDLFNBQVNDLFNBQVNiLENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxJQUFJQyxJQUFFO2dCQUFFLE9BQU87b0JBQVcsSUFBSUMsSUFBRSxJQUFJO29CQUFDLElBQUlDLElBQUVVO29CQUFVLElBQUlQLElBQUUsU0FBU1E7d0JBQWUsT0FBT2YsRUFBRWdCLEtBQUssQ0FBQ2IsR0FBRUM7b0JBQUU7b0JBQUVhLGFBQWFmO29CQUFHQSxJQUFFZ0IsV0FBV1gsR0FBRU47Z0JBQUU7WUFBQztZQUFDLFNBQVNrQixRQUFPO1lBQUMsU0FBU0Msb0JBQW9CcEIsQ0FBQztnQkFBRSxJQUFJQyxJQUFFRyxDQUFDLENBQUNKLEVBQUU7Z0JBQUMsSUFBRyxDQUFDQyxHQUFFO29CQUFDLElBQUdPLFNBQVNhLGFBQWEsRUFBQzt3QkFBQ3BCLElBQUVPLFNBQVNhLGFBQWEsQ0FBQ0MsR0FBRztvQkFBQSxPQUFLO3dCQUFDLElBQUlwQixJQUFFTSxTQUFTZSxvQkFBb0IsQ0FBQzt3QkFBVSxJQUFJaEIsSUFBRUwsQ0FBQyxDQUFDQSxFQUFFc0IsTUFBTSxHQUFDLEVBQUU7d0JBQUMsSUFBR2pCLEdBQUU7NEJBQUNOLElBQUVNLEVBQUVlLEdBQUc7d0JBQUE7b0JBQUM7b0JBQUNsQixDQUFDLENBQUNKLEVBQUUsR0FBQ0M7Z0JBQUM7Z0JBQUMsT0FBTyxTQUFT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Q0FBQ0MsRUFBRSxHQUFDO1lBQUNtRCxTQUFRLENBQUM7UUFBQztRQUFFLElBQUk5QyxJQUFFO1FBQUssSUFBRztZQUFDUCxDQUFDLENBQUNFLEVBQUUsQ0FBQ0UsR0FBRUEsRUFBRWlELE9BQU8sRUFBQ2E7WUFBcUIzRCxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT04sQ0FBQyxDQUFDQyxFQUFFO1FBQUE7UUFBQyxPQUFPRSxFQUFFaUQsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPYSx3QkFBc0IsYUFBWUEsb0JBQW9CRSxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJbkUsSUFBRWdFLG9CQUFvQjtJQUFLSSxPQUFPakIsT0FBTyxHQUFDbkQ7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz81ZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs2ODY6KGUscix0KT0+e3ZhciBuPXQoODA4KTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDgwODplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNjg2KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOlsiZSIsInIiLCJ0IiwibiIsImkiLCJPYmplY3QiLCJjcmVhdGUiLCJhIiwiZG9jdW1lbnQiLCJvIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwiZGVib3VuY2UiLCJhcmd1bWVudHMiLCJmdW5jdGlvbkNhbGwiLCJhcHBseSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJub29wIiwiZ2V0Q3VycmVudFNjcmlwdFVybCIsImN1cnJlbnRTY3JpcHQiLCJzcmMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImxlbmd0aCIsInNwbGl0IiwicmVwbGFjZSIsIm1hcCIsIlJlZ0V4cCIsImNvbmNhdCIsInVwZGF0ZUNzcyIsImhyZWYiLCJpc1VybFJlcXVlc3QiLCJpc0xvYWRlZCIsImluZGV4T2YiLCJ2aXNpdGVkIiwiY2xvbmVOb2RlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIkRhdGUiLCJub3ciLCJuZXh0U2libGluZyIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwiZ2V0UmVsb2FkVXJsIiwic3RyaXBXV1ciLCJzb21lIiwicmVsb2FkU3R5bGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2FsbCIsInJlbG9hZEFsbCIsInRlc3QiLCJleHBvcnRzIiwiY29uc29sZSIsImxvZyIsInVwZGF0ZSIsImZpbGVuYW1lIiwibG9jYWxzIiwiam9pbiIsIm5vcm1hbGl6ZVVybCIsInJlZHVjZSIsInBvcCIsInB1c2giLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwidW5kZWZpbmVkIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        229: function(e) {\n            var t = e.exports = {};\n            var r;\n            var n;\n            function defaultSetTimout() {\n                throw new Error(\"setTimeout has not been defined\");\n            }\n            function defaultClearTimeout() {\n                throw new Error(\"clearTimeout has not been defined\");\n            }\n            (function() {\n                try {\n                    if (typeof setTimeout === \"function\") {\n                        r = setTimeout;\n                    } else {\n                        r = defaultSetTimout;\n                    }\n                } catch (e) {\n                    r = defaultSetTimout;\n                }\n                try {\n                    if (typeof clearTimeout === \"function\") {\n                        n = clearTimeout;\n                    } else {\n                        n = defaultClearTimeout;\n                    }\n                } catch (e) {\n                    n = defaultClearTimeout;\n                }\n            })();\n            function runTimeout(e) {\n                if (r === setTimeout) {\n                    return setTimeout(e, 0);\n                }\n                if ((r === defaultSetTimout || !r) && setTimeout) {\n                    r = setTimeout;\n                    return setTimeout(e, 0);\n                }\n                try {\n                    return r(e, 0);\n                } catch (t) {\n                    try {\n                        return r.call(null, e, 0);\n                    } catch (t) {\n                        return r.call(this, e, 0);\n                    }\n                }\n            }\n            function runClearTimeout(e) {\n                if (n === clearTimeout) {\n                    return clearTimeout(e);\n                }\n                if ((n === defaultClearTimeout || !n) && clearTimeout) {\n                    n = clearTimeout;\n                    return clearTimeout(e);\n                }\n                try {\n                    return n(e);\n                } catch (t) {\n                    try {\n                        return n.call(null, e);\n                    } catch (t) {\n                        return n.call(this, e);\n                    }\n                }\n            }\n            var i = [];\n            var o = false;\n            var u;\n            var a = -1;\n            function cleanUpNextTick() {\n                if (!o || !u) {\n                    return;\n                }\n                o = false;\n                if (u.length) {\n                    i = u.concat(i);\n                } else {\n                    a = -1;\n                }\n                if (i.length) {\n                    drainQueue();\n                }\n            }\n            function drainQueue() {\n                if (o) {\n                    return;\n                }\n                var e = runTimeout(cleanUpNextTick);\n                o = true;\n                var t = i.length;\n                while(t){\n                    u = i;\n                    i = [];\n                    while(++a < t){\n                        if (u) {\n                            u[a].run();\n                        }\n                    }\n                    a = -1;\n                    t = i.length;\n                }\n                u = null;\n                o = false;\n                runClearTimeout(e);\n            }\n            t.nextTick = function(e) {\n                var t = new Array(arguments.length - 1);\n                if (arguments.length > 1) {\n                    for(var r = 1; r < arguments.length; r++){\n                        t[r - 1] = arguments[r];\n                    }\n                }\n                i.push(new Item(e, t));\n                if (i.length === 1 && !o) {\n                    runTimeout(drainQueue);\n                }\n            };\n            function Item(e, t) {\n                this.fun = e;\n                this.array = t;\n            }\n            Item.prototype.run = function() {\n                this.fun.apply(null, this.array);\n            };\n            t.title = \"browser\";\n            t.browser = true;\n            t.env = {};\n            t.argv = [];\n            t.version = \"\";\n            t.versions = {};\n            function noop() {}\n            t.on = noop;\n            t.addListener = noop;\n            t.once = noop;\n            t.off = noop;\n            t.removeListener = noop;\n            t.removeAllListeners = noop;\n            t.emit = noop;\n            t.prependListener = noop;\n            t.prependOnceListener = noop;\n            t.listeners = function(e) {\n                return [];\n            };\n            t.binding = function(e) {\n                throw new Error(\"process.binding is not supported\");\n            };\n            t.cwd = function() {\n                return \"/\";\n            };\n            t.chdir = function(e) {\n                throw new Error(\"process.chdir is not supported\");\n            };\n            t.umask = function() {\n                return 0;\n            };\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = t[r] = {\n            exports: {}\n        };\n        var o = true;\n        try {\n            e[r](i, i.exports, __nccwpck_require__);\n            o = false;\n        } finally{\n            if (o) delete t[r];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(229);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDO1lBQUUsSUFBSUMsSUFBRUQsRUFBRUUsT0FBTyxHQUFDLENBQUM7WUFBRSxJQUFJQztZQUFFLElBQUlDO1lBQUUsU0FBU0M7Z0JBQW1CLE1BQU0sSUFBSUMsTUFBTTtZQUFrQztZQUFDLFNBQVNDO2dCQUFzQixNQUFNLElBQUlELE1BQU07WUFBb0M7WUFBRTtnQkFBVyxJQUFHO29CQUFDLElBQUcsT0FBT0UsZUFBYSxZQUFXO3dCQUFDTCxJQUFFSztvQkFBVSxPQUFLO3dCQUFDTCxJQUFFRTtvQkFBZ0I7Z0JBQUMsRUFBQyxPQUFNTCxHQUFFO29CQUFDRyxJQUFFRTtnQkFBZ0I7Z0JBQUMsSUFBRztvQkFBQyxJQUFHLE9BQU9JLGlCQUFlLFlBQVc7d0JBQUNMLElBQUVLO29CQUFZLE9BQUs7d0JBQUNMLElBQUVHO29CQUFtQjtnQkFBQyxFQUFDLE9BQU1QLEdBQUU7b0JBQUNJLElBQUVHO2dCQUFtQjtZQUFDO1lBQUssU0FBU0csV0FBV1YsQ0FBQztnQkFBRSxJQUFHRyxNQUFJSyxZQUFXO29CQUFDLE9BQU9BLFdBQVdSLEdBQUU7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDRyxNQUFJRSxvQkFBa0IsQ0FBQ0YsQ0FBQUEsS0FBSUssWUFBVztvQkFBQ0wsSUFBRUs7b0JBQVcsT0FBT0EsV0FBV1IsR0FBRTtnQkFBRTtnQkFBQyxJQUFHO29CQUFDLE9BQU9HLEVBQUVILEdBQUU7Z0JBQUUsRUFBQyxPQUFNQyxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBT0UsRUFBRVEsSUFBSSxDQUFDLE1BQUtYLEdBQUU7b0JBQUUsRUFBQyxPQUFNQyxHQUFFO3dCQUFDLE9BQU9FLEVBQUVRLElBQUksQ0FBQyxJQUFJLEVBQUNYLEdBQUU7b0JBQUU7Z0JB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c3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzFiMWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6WyJlIiwidCIsImV4cG9ydHMiLCJyIiwibiIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJpIiwibyIsInUiLCJhIiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInJ1biIsIm5leHRUaWNrIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJwdXNoIiwiSXRlbSIsImZ1biIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsInVuZGVmaW5lZCIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        var _s = $RefreshSig$();\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var useSyncExternalStore = React.useSyncExternalStore;\n        // for CommonJS interop.\n        var useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n        function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n            _s();\n            // Use this to track the rendered snapshot.\n            var instRef = useRef(null);\n            var inst;\n            if (instRef.current === null) {\n                inst = {\n                    hasValue: false,\n                    value: null\n                };\n                instRef.current = inst;\n            } else {\n                inst = instRef.current;\n            }\n            var _useMemo = useMemo(function() {\n                // Track the memoized state using closure variables that are local to this\n                // memoized instance of a getSnapshot function. Intentionally not using a\n                // useRef hook, because that state would be shared across all concurrent\n                // copies of the hook/component.\n                var hasMemo = false;\n                var memoizedSnapshot;\n                var memoizedSelection;\n                var memoizedSelector = function(nextSnapshot) {\n                    if (!hasMemo) {\n                        // The first time the hook is called, there is no memoized result.\n                        hasMemo = true;\n                        memoizedSnapshot = nextSnapshot;\n                        var _nextSelection = selector(nextSnapshot);\n                        if (isEqual !== undefined) {\n                            // Even if the selector has changed, the currently rendered selection\n                            // may be equal to the new selection. We should attempt to reuse the\n                            // current value if possible, to preserve downstream memoizations.\n                            if (inst.hasValue) {\n                                var currentSelection = inst.value;\n                                if (isEqual(currentSelection, _nextSelection)) {\n                                    memoizedSelection = currentSelection;\n                                    return currentSelection;\n                                }\n                            }\n                        }\n                        memoizedSelection = _nextSelection;\n                        return _nextSelection;\n                    } // We may be able to reuse the previous invocation's result.\n                    // We may be able to reuse the previous invocation's result.\n                    var prevSnapshot = memoizedSnapshot;\n                    var prevSelection = memoizedSelection;\n                    if (objectIs(prevSnapshot, nextSnapshot)) {\n                        // The snapshot is the same as last time. Reuse the previous selection.\n                        return prevSelection;\n                    } // The snapshot has changed, so we need to compute a new selection.\n                    // The snapshot has changed, so we need to compute a new selection.\n                    var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n                    // has changed. If it hasn't, return the previous selection. That signals\n                    // to React that the selections are conceptually equal, and we can bail\n                    // out of rendering.\n                    // If a custom isEqual function is provided, use that to check if the data\n                    // has changed. If it hasn't, return the previous selection. That signals\n                    // to React that the selections are conceptually equal, and we can bail\n                    // out of rendering.\n                    if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n                        return prevSelection;\n                    }\n                    memoizedSnapshot = nextSnapshot;\n                    memoizedSelection = nextSelection;\n                    return nextSelection;\n                }; // Assigning this to a constant so that Flow knows it can't change.\n                // Assigning this to a constant so that Flow knows it can't change.\n                var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n                var getSnapshotWithSelector = function() {\n                    return memoizedSelector(getSnapshot());\n                };\n                var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function() {\n                    return memoizedSelector(maybeGetServerSnapshot());\n                };\n                return [\n                    getSnapshotWithSelector,\n                    getServerSnapshotWithSelector\n                ];\n            }, [\n                getSnapshot,\n                getServerSnapshot,\n                selector,\n                isEqual\n            ]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];\n            var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n            useEffect(function() {\n                inst.hasValue = true;\n                inst.value = value;\n            }, [\n                value\n            ]);\n            useDebugValue(value);\n            return value;\n        }\n        _s(useSyncExternalStoreWithSelector, \"mZhzs7ShZXU5RBraOlzBOQ4BK68=\", false, function() {\n            return [\n                useSyncExternalStore\n            ];\n        });\n        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4Qzs7UUFFTztRQUVWLHlDQUF5QyxHQUN6QyxJQUNFLE9BQU9DLG1DQUFtQyxlQUMxQyxPQUFPQSwrQkFBK0JDLDJCQUEyQixLQUMvRCxZQUNGO1lBQ0FELCtCQUErQkMsMkJBQTJCLENBQUMsSUFBSUM7UUFDakU7UUFDVSxJQUFJQyxRQUFRQyxtQkFBT0EsQ0FBQztRQUU5Qjs7O0NBR0MsR0FDRCxTQUFTQyxHQUFHQyxDQUFDLEVBQUVDLENBQUM7WUFDZCxPQUFPRCxNQUFNQyxLQUFNRCxDQUFBQSxNQUFNLEtBQUssSUFBSUEsTUFBTSxJQUFJQyxDQUFBQSxLQUFNRCxNQUFNQSxLQUFLQyxNQUFNQSxFQUFFLHNDQUFzQzs7UUFFN0c7UUFFQSxJQUFJQyxXQUFXLE9BQU9DLE9BQU9KLEVBQUUsS0FBSyxhQUFhSSxPQUFPSixFQUFFLEdBQUdBO1FBRTdELElBQUlLLHVCQUF1QlAsTUFBTU8sb0JBQW9CO1FBRXJELHdCQUF3QjtRQUV4QixJQUFJQyxTQUFTUixNQUFNUSxNQUFNLEVBQ3JCQyxZQUFZVCxNQUFNUyxTQUFTLEVBQzNCQyxVQUFVVixNQUFNVSxPQUFPLEVBQ3ZCQyxnQkFBZ0JYLE1BQU1XLGFBQWEsRUFBRSw2RUFBNkU7UUFFdEgsU0FBU0MsaUNBQWlDQyxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsaUJBQWlCLEVBQUVDLFFBQVEsRUFBRUMsT0FBTzs7WUFDcEcsMkNBQTJDO1lBQzNDLElBQUlDLFVBQVVWLE9BQU87WUFDckIsSUFBSVc7WUFFSixJQUFJRCxRQUFRRSxPQUFPLEtBQUssTUFBTTtnQkFDNUJELE9BQU87b0JBQ0xFLFVBQVU7b0JBQ1ZDLE9BQU87Z0JBQ1Q7Z0JBQ0FKLFFBQVFFLE9BQU8sR0FBR0Q7WUFDcEIsT0FBTztnQkFDTEEsT0FBT0QsUUFBUUUsT0FBTztZQUN4QjtZQUVBLElBQUlHLFdBQVdiLFFBQVE7Z0JBQ3JCLDBFQUEwRTtnQkFDMUUseUVBQXlFO2dCQUN6RSx3RUFBd0U7Z0JBQ3hFLGdDQUFnQztnQkFDaEMsSUFBSWMsVUFBVTtnQkFDZCxJQUFJQztnQkFDSixJQUFJQztnQkFFSixJQUFJQyxtQkFBbUIsU0FBVUMsWUFBWTtvQkFDM0MsSUFBSSxDQUFDSixTQUFTO3dCQUNaLGtFQUFrRTt3QkFDbEVBLFVBQVU7d0JBQ1ZDLG1CQUFtQkc7d0JBRW5CLElBQUlDLGlCQUFpQmIsU0FBU1k7d0JBRTlCLElBQUlYLFlBQVlhLFdBQVc7NEJBQ3pCLHFFQUFxRTs0QkFDckUsb0VBQW9FOzRCQUNwRSxrRUFBa0U7NEJBQ2xFLElBQUlYLEtBQUtFLFFBQVEsRUFBRTtnQ0FDakIsSUFBSVUsbUJBQW1CWixLQUFLRyxLQUFLO2dDQUVqQyxJQUFJTCxRQUFRYyxrQkFBa0JGLGlCQUFpQjtvQ0FDN0NILG9CQUFvQks7b0NBQ3BCLE9BQU9BO2dDQUNUOzRCQUNGO3dCQUNGO3dCQUVBTCxvQkFBb0JHO3dCQUNwQixPQUFPQTtvQkFDVCxFQUFFLDREQUE0RDtvQkFHOUQsNERBQTREO29CQUM1RCxJQUFJRyxlQUFlUDtvQkFDbkIsSUFBSVEsZ0JBQWdCUDtvQkFFcEIsSUFBSXJCLFNBQVMyQixjQUFjSixlQUFlO3dCQUN4Qyx1RUFBdUU7d0JBQ3ZFLE9BQU9LO29CQUNULEVBQUUsbUVBQW1FO29CQUdyRSxtRUFBbUU7b0JBQ25FLElBQUlDLGdCQUFnQmxCLFNBQVNZLGVBQWUsMEVBQTBFO29CQUN0SCx5RUFBeUU7b0JBQ3pFLHVFQUF1RTtvQkFDdkUsb0JBQW9CO29CQUVwQiwwRUFBMEU7b0JBQzFFLHlFQUF5RTtvQkFDekUsdUVBQXVFO29CQUN2RSxvQkFBb0I7b0JBQ3BCLElBQUlYLFlBQVlhLGFBQWFiLFFBQVFnQixlQUFlQyxnQkFBZ0I7d0JBQ2xFLE9BQU9EO29CQUNUO29CQUVBUixtQkFBbUJHO29CQUNuQkYsb0JBQW9CUTtvQkFDcEIsT0FBT0E7Z0JBQ1QsR0FBRyxtRUFBbUU7Z0JBR3RFLG1FQUFtRTtnQkFDbkUsSUFBSUMseUJBQXlCcEIsc0JBQXNCZSxZQUFZLE9BQU9mO2dCQUV0RSxJQUFJcUIsMEJBQTBCO29CQUM1QixPQUFPVCxpQkFBaUJiO2dCQUMxQjtnQkFFQSxJQUFJdUIsZ0NBQWdDRiwyQkFBMkIsT0FBT0wsWUFBWTtvQkFDaEYsT0FBT0gsaUJBQWlCUTtnQkFDMUI7Z0JBQ0EsT0FBTztvQkFBQ0M7b0JBQXlCQztpQkFBOEI7WUFDakUsR0FBRztnQkFBQ3ZCO2dCQUFhQztnQkFBbUJDO2dCQUFVQzthQUFRLEdBQ2xEcUIsZUFBZWYsUUFBUSxDQUFDLEVBQUUsRUFDMUJnQixxQkFBcUJoQixRQUFRLENBQUMsRUFBRTtZQUVwQyxJQUFJRCxRQUFRZixxQkFBcUJNLFdBQVd5QixjQUFjQztZQUMxRDlCLFVBQVU7Z0JBQ1JVLEtBQUtFLFFBQVEsR0FBRztnQkFDaEJGLEtBQUtHLEtBQUssR0FBR0E7WUFDZixHQUFHO2dCQUFDQTthQUFNO1lBQ1ZYLGNBQWNXO1lBQ2QsT0FBT0E7UUFDVDtXQXZHU1Y7O2dCQWdHS0w7OztRQVNkaUMsd0NBQXdDLEdBQUc1QjtRQUNqQyx5Q0FBeUMsR0FDbkQsSUFDRSxPQUFPZixtQ0FBbUMsZUFDMUMsT0FBT0EsK0JBQStCNEMsMEJBQTBCLEtBQzlELFlBQ0Y7WUFDQTVDLCtCQUErQjRDLDBCQUEwQixDQUFDLElBQUkxQztRQUNoRTtJQUVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzPzM4MmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlO1xuXG4vLyBmb3IgQ29tbW9uSlMgaW50ZXJvcC5cblxudmFyIHVzZVJlZiA9IFJlYWN0LnVzZVJlZixcbiAgICB1c2VFZmZlY3QgPSBSZWFjdC51c2VFZmZlY3QsXG4gICAgdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8sXG4gICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7IC8vIFNhbWUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmUsIGJ1dCBzdXBwb3J0cyBzZWxlY3RvciBhbmQgaXNFcXVhbCBhcmd1bWVudHMuXG5cbmZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICAvLyBVc2UgdGhpcyB0byB0cmFjayB0aGUgcmVuZGVyZWQgc25hcHNob3QuXG4gIHZhciBpbnN0UmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgaW5zdDtcblxuICBpZiAoaW5zdFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgaW5zdCA9IHtcbiAgICAgIGhhc1ZhbHVlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfTtcbiAgICBpbnN0UmVmLmN1cnJlbnQgPSBpbnN0O1xuICB9IGVsc2Uge1xuICAgIGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG4gIH1cblxuICB2YXIgX3VzZU1lbW8gPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUcmFjayB0aGUgbWVtb2l6ZWQgc3RhdGUgdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMgdGhhdCBhcmUgbG9jYWwgdG8gdGhpc1xuICAgIC8vIG1lbW9pemVkIGluc3RhbmNlIG9mIGEgZ2V0U25hcHNob3QgZnVuY3Rpb24uIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGFcbiAgICAvLyB1c2VSZWYgaG9vaywgYmVjYXVzZSB0aGF0IHN0YXRlIHdvdWxkIGJlIHNoYXJlZCBhY3Jvc3MgYWxsIGNvbmN1cnJlbnRcbiAgICAvLyBjb3BpZXMgb2YgdGhlIGhvb2svY29tcG9uZW50LlxuICAgIHZhciBoYXNNZW1vID0gZmFsc2U7XG4gICAgdmFyIG1lbW9pemVkU25hcHNob3Q7XG4gICAgdmFyIG1lbW9pemVkU2VsZWN0aW9uO1xuXG4gICAgdmFyIG1lbW9pemVkU2VsZWN0b3IgPSBmdW5jdGlvbiAobmV4dFNuYXBzaG90KSB7XG4gICAgICBpZiAoIWhhc01lbW8pIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgdGhlIGhvb2sgaXMgY2FsbGVkLCB0aGVyZSBpcyBubyBtZW1vaXplZCByZXN1bHQuXG4gICAgICAgIGhhc01lbW8gPSB0cnVlO1xuICAgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuXG4gICAgICAgIHZhciBfbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG5cbiAgICAgICAgaWYgKGlzRXF1YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHNlbGVjdG9yIGhhcyBjaGFuZ2VkLCB0aGUgY3VycmVudGx5IHJlbmRlcmVkIHNlbGVjdGlvblxuICAgICAgICAgIC8vIG1heSBiZSBlcXVhbCB0byB0aGUgbmV3IHNlbGVjdGlvbi4gV2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmV1c2UgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCB2YWx1ZSBpZiBwb3NzaWJsZSwgdG8gcHJlc2VydmUgZG93bnN0cmVhbSBtZW1vaXphdGlvbnMuXG4gICAgICAgICAgaWYgKGluc3QuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gaW5zdC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGlzRXF1YWwoY3VycmVudFNlbGVjdGlvbiwgX25leHRTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBfbmV4dFNlbGVjdGlvbjtcbiAgICAgICAgcmV0dXJuIF9uZXh0U2VsZWN0aW9uO1xuICAgICAgfSAvLyBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSB0aGUgcHJldmlvdXMgaW52b2NhdGlvbidzIHJlc3VsdC5cblxuXG4gICAgICAvLyBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSB0aGUgcHJldmlvdXMgaW52b2NhdGlvbidzIHJlc3VsdC5cbiAgICAgIHZhciBwcmV2U25hcHNob3QgPSBtZW1vaXplZFNuYXBzaG90O1xuICAgICAgdmFyIHByZXZTZWxlY3Rpb24gPSBtZW1vaXplZFNlbGVjdGlvbjtcblxuICAgICAgaWYgKG9iamVjdElzKHByZXZTbmFwc2hvdCwgbmV4dFNuYXBzaG90KSkge1xuICAgICAgICAvLyBUaGUgc25hcHNob3QgaXMgdGhlIHNhbWUgYXMgbGFzdCB0aW1lLiBSZXVzZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLlxuICAgICAgICByZXR1cm4gcHJldlNlbGVjdGlvbjtcbiAgICAgIH0gLy8gVGhlIHNuYXBzaG90IGhhcyBjaGFuZ2VkLCBzbyB3ZSBuZWVkIHRvIGNvbXB1dGUgYSBuZXcgc2VsZWN0aW9uLlxuXG5cbiAgICAgIC8vIFRoZSBzbmFwc2hvdCBoYXMgY2hhbmdlZCwgc28gd2UgbmVlZCB0byBjb21wdXRlIGEgbmV3IHNlbGVjdGlvbi5cbiAgICAgIHZhciBuZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTsgLy8gSWYgYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gY2hlY2sgaWYgdGhlIGRhdGFcbiAgICAgIC8vIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXNuJ3QsIHJldHVybiB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBUaGF0IHNpZ25hbHNcbiAgICAgIC8vIHRvIFJlYWN0IHRoYXQgdGhlIHNlbGVjdGlvbnMgYXJlIGNvbmNlcHR1YWxseSBlcXVhbCwgYW5kIHdlIGNhbiBiYWlsXG4gICAgICAvLyBvdXQgb2YgcmVuZGVyaW5nLlxuXG4gICAgICAvLyBJZiBhIGN1c3RvbSBpc0VxdWFsIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB1c2UgdGhhdCB0byBjaGVjayBpZiB0aGUgZGF0YVxuICAgICAgLy8gaGFzIGNoYW5nZWQuIElmIGl0IGhhc24ndCwgcmV0dXJuIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uIFRoYXQgc2lnbmFsc1xuICAgICAgLy8gdG8gUmVhY3QgdGhhdCB0aGUgc2VsZWN0aW9ucyBhcmUgY29uY2VwdHVhbGx5IGVxdWFsLCBhbmQgd2UgY2FuIGJhaWxcbiAgICAgIC8vIG91dCBvZiByZW5kZXJpbmcuXG4gICAgICBpZiAoaXNFcXVhbCAhPT0gdW5kZWZpbmVkICYmIGlzRXF1YWwocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG4gICAgICB9XG5cbiAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG4gICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTZWxlY3Rpb247XG4gICAgICByZXR1cm4gbmV4dFNlbGVjdGlvbjtcbiAgICB9OyAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0YW50IHNvIHRoYXQgRmxvdyBrbm93cyBpdCBjYW4ndCBjaGFuZ2UuXG5cblxuICAgIC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3RhbnQgc28gdGhhdCBGbG93IGtub3dzIGl0IGNhbid0IGNoYW5nZS5cbiAgICB2YXIgbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90ID09PSB1bmRlZmluZWQgPyBudWxsIDogZ2V0U2VydmVyU25hcHNob3Q7XG5cbiAgICB2YXIgZ2V0U25hcHNob3RXaXRoU2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihnZXRTbmFwc2hvdCgpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFNlcnZlclNuYXBzaG90V2l0aFNlbGVjdG9yID0gbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKG1heWJlR2V0U2VydmVyU25hcHNob3QoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gW2dldFNuYXBzaG90V2l0aFNlbGVjdG9yLCBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3Rvcl07XG4gIH0sIFtnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsXSksXG4gICAgICBnZXRTZWxlY3Rpb24gPSBfdXNlTWVtb1swXSxcbiAgICAgIGdldFNlcnZlclNlbGVjdGlvbiA9IF91c2VNZW1vWzFdO1xuXG4gIHZhciB2YWx1ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U2VsZWN0aW9uLCBnZXRTZXJ2ZXJTZWxlY3Rpb24pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGluc3QuaGFzVmFsdWUgPSB0cnVlO1xuICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjtcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQiLCJFcnJvciIsIlJlYWN0IiwicmVxdWlyZSIsImlzIiwieCIsInkiLCJvYmplY3RJcyIsIk9iamVjdCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZURlYnVnVmFsdWUiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJzZWxlY3RvciIsImlzRXF1YWwiLCJpbnN0UmVmIiwiaW5zdCIsImN1cnJlbnQiLCJoYXNWYWx1ZSIsInZhbHVlIiwiX3VzZU1lbW8iLCJoYXNNZW1vIiwibWVtb2l6ZWRTbmFwc2hvdCIsIm1lbW9pemVkU2VsZWN0aW9uIiwibWVtb2l6ZWRTZWxlY3RvciIsIm5leHRTbmFwc2hvdCIsIl9uZXh0U2VsZWN0aW9uIiwidW5kZWZpbmVkIiwiY3VycmVudFNlbGVjdGlvbiIsInByZXZTbmFwc2hvdCIsInByZXZTZWxlY3Rpb24iLCJuZXh0U2VsZWN0aW9uIiwibWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCIsImdldFNuYXBzaG90V2l0aFNlbGVjdG9yIiwiZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3IiLCJnZXRTZWxlY3Rpb24iLCJnZXRTZXJ2ZXJTZWxlY3Rpb24iLCJleHBvcnRzIiwicmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js":
/*!***************************************************************!*\
  !*** ./node_modules/use-sync-external-store/with-selector.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/use-sync-external-store-with-selector.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDZOQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvd2l0aC1zZWxlY3Rvci5qcz83ZWNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"5b94e9a28b6c\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvZ2xvYmFscy5jc3M/ZjEyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjViOTRlOWEyOGI2Y1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/store.ts":
/*!**************************!*\
  !*** ./src/app/store.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   store: function() { return /* binding */ store; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _redux_features_navSlice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../redux/features/navSlice */ \"(app-pages-browser)/./src/redux/features/navSlice.ts\");\n\n\nconst store = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.configureStore)({\n    reducer: {\n        nav: _redux_features_navSlice__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n    }\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtEO0FBRUE7QUFFM0MsTUFBTUUsUUFBUUYsZ0VBQWNBLENBQUM7SUFDaENHLFNBQVM7UUFDTEMsS0FBS0gsZ0VBQVFBO0lBQ2pCO0FBQ0osR0FBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3N0b3JlLnRzPzE0N2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29uZmlndXJlU3RvcmUgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuXG5pbXBvcnQgbmF2U2xpY2UgZnJvbSBcIi4uL3JlZHV4L2ZlYXR1cmVzL25hdlNsaWNlXCI7XG5cbmV4cG9ydCBjb25zdCBzdG9yZSA9IGNvbmZpZ3VyZVN0b3JlKHtcbiAgICByZWR1Y2VyOiB7XG4gICAgICAgIG5hdjogbmF2U2xpY2VcbiAgICB9XG59KVxuXG5leHBvcnQgdHlwZSBSb290U3RhdGUgPSBSZXR1cm5UeXBlPHR5cGVvZiBzdG9yZS5nZXRTdGF0ZT5cbmV4cG9ydCB0eXBlIEFwcERpc3BhdGNoID0gdHlwZW9mIHN0b3JlLmRpc3BhdGNoIl0sIm5hbWVzIjpbImNvbmZpZ3VyZVN0b3JlIiwibmF2U2xpY2UiLCJzdG9yZSIsInJlZHVjZXIiLCJuYXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/store.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/redux/features/navSlice.ts":
/*!****************************************!*\
  !*** ./src/redux/features/navSlice.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   currentNav: function() { return /* binding */ currentNav; },\n/* harmony export */   navState: function() { return /* binding */ navState; },\n/* harmony export */   setCurrentState: function() { return /* binding */ setCurrentState; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n\nconst initialState = {\n    current: \"\"\n};\nconst navState = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: \"navstate\",\n    initialState,\n    reducers: {\n        setCurrentState: (state, action)=>{\n            state.current = action.payload;\n        }\n    }\n});\nconst { setCurrentState } = navState.actions;\nconst currentNav = (state)=>state.nav;\n/* harmony default export */ __webpack_exports__[\"default\"] = (navState.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9yZWR1eC9mZWF0dXJlcy9uYXZTbGljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRThEO0FBSTlELE1BQU1DLGVBQTBCO0lBQzVCQyxTQUFTO0FBQ2I7QUFFTyxNQUFNQyxXQUFXSCw2REFBV0EsQ0FBQztJQUNoQ0ksTUFBTTtJQUNOSDtJQUNBSSxVQUFVO1FBQ05DLGlCQUFpQixDQUFDQyxPQUFPQztZQUNyQkQsTUFBTUwsT0FBTyxHQUFHTSxPQUFPQyxPQUFPO1FBQ2xDO0lBQ0o7QUFDSixHQUFFO0FBRUssTUFBTSxFQUFFSCxlQUFlLEVBQUMsR0FBR0gsU0FBU08sT0FBTyxDQUFDO0FBQzVDLE1BQU1DLGFBQWEsQ0FBQ0osUUFBcUJBLE1BQU1LLEdBQUc7QUFDekQsK0RBQWVULFNBQVNVLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3JlZHV4L2ZlYXR1cmVzL25hdlNsaWNlLnRzPzg2ODMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUm9vdFN0YXRlIH0gZnJvbSBcIkAvYXBwL3N0b3JlXCI7XG5pbXBvcnQgeyBOYXZTdGF0ZXMgfSBmcm9tIFwiQC90eXBlcy9uYXZUeXBlc1wiO1xuaW1wb3J0IHsgY3JlYXRlU2xpY2UsIFBheWxvYWRBY3Rpb24gfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuXG5cblxuY29uc3QgaW5pdGlhbFN0YXRlOiBOYXZTdGF0ZXMgPSB7XG4gICAgY3VycmVudDogJydcbn1cblxuZXhwb3J0IGNvbnN0IG5hdlN0YXRlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6ICduYXZzdGF0ZScsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICAgIHNldEN1cnJlbnRTdGF0ZTogKHN0YXRlLCBhY3Rpb246IFBheWxvYWRBY3Rpb248c3RyaW5nPikgPT4ge1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudCA9IGFjdGlvbi5wYXlsb2FkXG4gICAgICAgIH1cbiAgICB9XG59KVxuXG5leHBvcnQgY29uc3QgeyBzZXRDdXJyZW50U3RhdGV9ID0gbmF2U3RhdGUuYWN0aW9ucztcbmV4cG9ydCBjb25zdCBjdXJyZW50TmF2ID0gKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLm5hdlxuZXhwb3J0IGRlZmF1bHQgbmF2U3RhdGUucmVkdWNlclxuIl0sIm5hbWVzIjpbImNyZWF0ZVNsaWNlIiwiaW5pdGlhbFN0YXRlIiwiY3VycmVudCIsIm5hdlN0YXRlIiwibmFtZSIsInJlZHVjZXJzIiwic2V0Q3VycmVudFN0YXRlIiwic3RhdGUiLCJhY3Rpb24iLCJwYXlsb2FkIiwiYWN0aW9ucyIsImN1cnJlbnROYXYiLCJuYXYiLCJyZWR1Y2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/redux/features/navSlice.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/redux/features/provider.tsx":
/*!*****************************************!*\
  !*** ./src/redux/features/provider.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ \"(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var _app_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../app/store */ \"(app-pages-browser)/./src/app/store.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\nfunction APpProvider(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_redux__WEBPACK_IMPORTED_MODULE_3__.Provider, {\n        store: _app_store__WEBPACK_IMPORTED_MODULE_1__.store,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/kc/Documents/Projects/SEO/sara/src/redux/features/provider.tsx\",\n        lineNumber: 8,\n        columnNumber: 5\n    }, this);\n}\n_c = APpProvider;\n/* harmony default export */ __webpack_exports__[\"default\"] = (APpProvider);\nvar _c;\n$RefreshReg$(_c, \"APpProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9yZWR1eC9mZWF0dXJlcy9wcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUN1QztBQUNDO0FBQ2Q7QUFFMUIsU0FBU0csWUFBWSxLQUFzQztRQUF0QyxFQUFDQyxRQUFRLEVBQTZCLEdBQXRDO0lBQ3JCLHFCQUNJLDhEQUFDSixpREFBUUE7UUFBQ0MsT0FBT0EsNkNBQUtBO2tCQUNqQkc7Ozs7OztBQUdUO0tBTlNEO0FBUVQsK0RBQWVBLFdBQVdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3JlZHV4L2ZlYXR1cmVzL3Byb3ZpZGVyLnRzeD80ZWJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuaW1wb3J0IHsgc3RvcmUgfSBmcm9tIFwiLi4vLi4vYXBwL3N0b3JlXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmZ1bmN0aW9uIEFQcFByb3ZpZGVyKHtjaGlsZHJlbn06e2NoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGV9KXtcbnJldHVybiAoXG4gICAgPFByb3ZpZGVyIHN0b3JlPXtzdG9yZX0+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1Byb3ZpZGVyPlxuKVxufVxuXG5leHBvcnQgZGVmYXVsdCBBUHBQcm92aWRlcjsiXSwibmFtZXMiOlsiUHJvdmlkZXIiLCJzdG9yZSIsIlJlYWN0IiwiQVBwUHJvdmlkZXIiLCJjaGlsZHJlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/redux/features/provider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}":
/*!************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"src/app/layout.tsx","import":"Inter","arguments":[{"subsets":["latin"]}],"variableName":"inter"} ***!
  \************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Inter_aaf875', '__Inter_Fallback_aaf875'\",\"fontStyle\":\"normal\"},\"className\":\"__className_aaf875\"};\n    if(true) {\n      // 1710152088044\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwic3JjL2FwcC9sYXlvdXQudHN4XCIsXCJpbXBvcnRcIjpcIkludGVyXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcImludGVyXCJ9IiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLFNBQVMsZ0ZBQWdGO0FBQzNHLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdNQUEySCxjQUFjLHNEQUFzRDtBQUM3TixNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/MTZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1wic3R5bGVcIjp7XCJmb250RmFtaWx5XCI6XCInX19JbnRlcl9hYWY4NzUnLCAnX19JbnRlcl9GYWxsYmFja19hYWY4NzUnXCIsXCJmb250U3R5bGVcIjpcIm5vcm1hbFwifSxcImNsYXNzTmFtZVwiOlwiX19jbGFzc05hbWVfYWFmODc1XCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTAxNTIwODgwNDRcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiL1VzZXJzL2tjL0RvY3VtZW50cy9Qcm9qZWN0cy9TRU8vc2FyYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: function() { return /* binding */ ReducerType; },\n/* harmony export */   SHOULD_AUTOBATCH: function() { return /* binding */ SHOULD_AUTOBATCH; },\n/* harmony export */   TaskAbortError: function() { return /* binding */ TaskAbortError; },\n/* harmony export */   Tuple: function() { return /* binding */ Tuple; },\n/* harmony export */   __DO_NOT_USE__ActionTypes: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes; },\n/* harmony export */   addListener: function() { return /* binding */ addListener; },\n/* harmony export */   applyMiddleware: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware; },\n/* harmony export */   asyncThunkCreator: function() { return /* binding */ asyncThunkCreator; },\n/* harmony export */   autoBatchEnhancer: function() { return /* binding */ autoBatchEnhancer; },\n/* harmony export */   bindActionCreators: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators; },\n/* harmony export */   buildCreateSlice: function() { return /* binding */ buildCreateSlice; },\n/* harmony export */   clearAllListeners: function() { return /* binding */ clearAllListeners; },\n/* harmony export */   combineReducers: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers; },\n/* harmony export */   combineSlices: function() { return /* binding */ combineSlices; },\n/* harmony export */   compose: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose; },\n/* harmony export */   configureStore: function() { return /* binding */ configureStore; },\n/* harmony export */   createAction: function() { return /* binding */ createAction; },\n/* harmony export */   createActionCreatorInvariantMiddleware: function() { return /* binding */ createActionCreatorInvariantMiddleware; },\n/* harmony export */   createAsyncThunk: function() { return /* binding */ createAsyncThunk; },\n/* harmony export */   createDraftSafeSelector: function() { return /* binding */ createDraftSafeSelector; },\n/* harmony export */   createDraftSafeSelectorCreator: function() { return /* binding */ createDraftSafeSelectorCreator; },\n/* harmony export */   createDynamicMiddleware: function() { return /* binding */ createDynamicMiddleware; },\n/* harmony export */   createEntityAdapter: function() { return /* binding */ createEntityAdapter; },\n/* harmony export */   createImmutableStateInvariantMiddleware: function() { return /* binding */ createImmutableStateInvariantMiddleware; },\n/* harmony export */   createListenerMiddleware: function() { return /* binding */ createListenerMiddleware; },\n/* harmony export */   createNextState: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce; },\n/* harmony export */   createReducer: function() { return /* binding */ createReducer; },\n/* harmony export */   createSelector: function() { return /* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector; },\n/* harmony export */   createSelectorCreator: function() { return /* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator; },\n/* harmony export */   createSerializableStateInvariantMiddleware: function() { return /* binding */ createSerializableStateInvariantMiddleware; },\n/* harmony export */   createSlice: function() { return /* binding */ createSlice; },\n/* harmony export */   createStore: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore; },\n/* harmony export */   current: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current; },\n/* harmony export */   findNonSerializableValue: function() { return /* binding */ findNonSerializableValue; },\n/* harmony export */   formatProdErrorMessage: function() { return /* binding */ formatProdErrorMessage; },\n/* harmony export */   freeze: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze; },\n/* harmony export */   isAction: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction; },\n/* harmony export */   isActionCreator: function() { return /* binding */ isActionCreator; },\n/* harmony export */   isAllOf: function() { return /* binding */ isAllOf; },\n/* harmony export */   isAnyOf: function() { return /* binding */ isAnyOf; },\n/* harmony export */   isAsyncThunkAction: function() { return /* binding */ isAsyncThunkAction; },\n/* harmony export */   isDraft: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft; },\n/* harmony export */   isFluxStandardAction: function() { return /* binding */ isFSA; },\n/* harmony export */   isFulfilled: function() { return /* binding */ isFulfilled; },\n/* harmony export */   isImmutableDefault: function() { return /* binding */ isImmutableDefault; },\n/* harmony export */   isPending: function() { return /* binding */ isPending; },\n/* harmony export */   isPlain: function() { return /* binding */ isPlain; },\n/* harmony export */   isPlainObject: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject; },\n/* harmony export */   isRejected: function() { return /* binding */ isRejected; },\n/* harmony export */   isRejectedWithValue: function() { return /* binding */ isRejectedWithValue; },\n/* harmony export */   legacy_createStore: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore; },\n/* harmony export */   lruMemoize: function() { return /* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize; },\n/* harmony export */   miniSerializeError: function() { return /* binding */ miniSerializeError; },\n/* harmony export */   nanoid: function() { return /* binding */ nanoid; },\n/* harmony export */   original: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original; },\n/* harmony export */   prepareAutoBatched: function() { return /* binding */ prepareAutoBatched; },\n/* harmony export */   removeListener: function() { return /* binding */ removeListener; },\n/* harmony export */   unwrapResult: function() { return /* binding */ unwrapResult; },\n/* harmony export */   weakMapMemoize: function() { return /* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize; }\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(app-pages-browser)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(app-pages-browser)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(app-pages-browser)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(app-pages-browser)/./node_modules/redux-thunk/dist/redux-thunk.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// src/index.ts\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelectorCreator = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n    const createDraftSafeSelector2 = Object.assign(function() {\n        for(var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++){\n            args2[_key] = arguments[_key];\n        }\n        const selector = createSelector2(...args2);\n        const wrappedSelector = function(value) {\n            for(var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                rest[_key - 1] = arguments[_key];\n            }\n            return selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n        };\n        Object.assign(wrappedSelector, selector);\n        return wrappedSelector;\n    }, {\n        withTypes: ()=>createDraftSafeSelector2\n    });\n    return createDraftSafeSelector2;\n};\nvar createDraftSafeSelector = createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  true && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  true && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {\n    return function(noop3) {\n        return noop3;\n    };\n};\n// src/getDefaultMiddleware.ts\n\n// src/createAction.ts\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v)=>{\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (prepareAction) {\n            let prepared = prepareAction(...args);\n            if (!prepared) {\n                throw new Error( false ? 0 : \"prepareAction did not return an object\");\n            }\n            return {\n                type,\n                payload: prepared.payload,\n                ...\"meta\" in prepared && {\n                    meta: prepared.meta\n                },\n                ...\"error\" in prepared && {\n                    error: prepared.error\n                }\n            };\n        }\n        return {\n            type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = ()=>\"\".concat(type);\n    actionCreator.type = type;\n    actionCreator.match = (action)=>(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n    return actionCreator;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n    hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    const splitType = type ? \"\".concat(type).split(\"/\") : [];\n    const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return 'Detected an action creator with type \"'.concat(type || \"unknown\", \"\\\" being dispatched. \\nMake sure you're calling the action creator before dispatching, i.e. `dispatch(\").concat(actionName, \"())` instead of `dispatch(\").concat(actionName, \")`. This is necessary even if the action has no payload.\");\n}\nfunction createActionCreatorInvariantMiddleware() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    if (false) {}\n    const { isActionCreator: isActionCreator2 = isActionCreator } = options;\n    return ()=>(next)=>(action)=>{\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n}\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    let elapsed = 0;\n    return {\n        measureTime (fn) {\n            const started = Date.now();\n            try {\n                return fn();\n            } finally{\n                const finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded () {\n            if (elapsed > maxDelay) {\n                console.warn(\"\".concat(fnName, \" took \").concat(elapsed, \"ms, which is more than the warning threshold of \").concat(maxDelay, \"ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.\"));\n            }\n        }\n    };\n}\nfunction find(iterable, comparator) {\n    for (const entry of iterable){\n        if (comparator(entry)) {\n            return entry;\n        }\n    }\n    return void 0;\n}\nvar Tuple = class _Tuple extends Array {\n    static get [Symbol.species]() {\n        return _Tuple;\n    }\n    concat() {\n        for(var _len = arguments.length, arr = new Array(_len), _key = 0; _key < _len; _key++){\n            arr[_key] = arguments[_key];\n        }\n        return super.concat.apply(this, arr);\n    }\n    prepend() {\n        for(var _len = arguments.length, arr = new Array(_len), _key = 0; _key < _len; _key++){\n            arr[_key] = arguments[_key];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new _Tuple(...arr[0].concat(this));\n        }\n        return new _Tuple(...arr.concat(this));\n    }\n    constructor(...items){\n        super(...items);\n        Object.setPrototypeOf(this, _Tuple.prototype);\n    }\n};\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, ()=>{}) : val;\n}\nfunction emplace(map, key, handler) {\n    if (map.has(key)) {\n        let value = map.get(key);\n        if (handler.update) {\n            value = handler.update(value, key, map);\n            map.set(key, value);\n        }\n        return value;\n    }\n    if (!handler.insert) throw new Error( false ? 0 : \"No insert provided for key not already in map\");\n    const inserted = handler.insert(key, map);\n    map.set(key, inserted);\n    return inserted;\n}\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations () {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable) {\n    let ignorePaths = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], obj = arguments.length > 2 ? arguments[2] : void 0, path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"\", checkedObjects = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : /* @__PURE__ */ new Set();\n    const tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(const key in obj){\n            const childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable) {\n    let ignoredPaths = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], trackedProperty = arguments.length > 2 ? arguments[2] : void 0, obj = arguments.length > 3 ? arguments[3] : void 0, sameParentRef = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, path = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"\";\n    const prevObj = trackedProperty ? trackedProperty.value : void 0;\n    const sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    const keysToDetect = {};\n    for(let key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(let key in obj){\n        keysToDetect[key] = true;\n    }\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for(let key in keysToDetect){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return result;\n        }\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    if (false) {} else {\n        let stringify2 = function(obj, serializer, indent, decycler) {\n            return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n        }, getSerialize2 = function(serializer, decycler) {\n            let stack = [], keys = [];\n            if (!decycler) decycler = function(_, value) {\n                if (stack[0] === value) return \"[Circular ~]\";\n                return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n            };\n            return function(key, value) {\n                if (stack.length > 0) {\n                    var thisPos = stack.indexOf(this);\n                    ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n                    ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n                    if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n                } else stack.push(value);\n                return serializer == null ? value : serializer.call(this, key, value);\n            };\n        };\n        var stringify = stringify2, getSerialize = getSerialize2;\n        let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options;\n        const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n        return (param)=>{\n            let { getState } = param;\n            let state = getState();\n            let tracker = track(state);\n            let result;\n            return (next)=>(action)=>{\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : \"A state mutation was detected between dispatches, in the path '\".concat(result.path || \"\", \"'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\"));\n                        }\n                    });\n                    const dispatchedAction = next(action);\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : \"A state mutation was detected inside a dispatch, in the path: \".concat(result.path || \"\", \". Take a look at the reducer(s) handling the action \").concat(stringify2(action), \". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\"));\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                    return dispatchedAction;\n                };\n        };\n    }\n}\n// src/serializableStateInvariantMiddleware.ts\n\nfunction isPlain(val) {\n    const type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value) {\n    let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", isSerializable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : isPlain, getEntries = arguments.length > 3 ? arguments[3] : void 0, ignoredPaths = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], cache = arguments.length > 5 ? arguments[5] : void 0;\n    let foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache === null || cache === void 0 ? void 0 : cache.has(value)) return false;\n    const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for (const [key, nestedValue] of entries){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                keyPath: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return foundNestedSerializable;\n            }\n        }\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for (const nestedValue of Object.values(value)){\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    if (false) {} else {\n        const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = [\n            \"meta.arg\",\n            \"meta.baseQueryMeta\"\n        ], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options;\n        const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n        return (storeAPI)=>(next)=>(action)=>{\n                    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                        return next(action);\n                    }\n                    const result = next(action);\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                        measureUtils.measureTime(()=>{\n                            const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                            if (foundActionNonSerializableValue) {\n                                const { keyPath, value } = foundActionNonSerializableValue;\n                                console.error(\"A non-serializable value was detected in an action, in the path: `\".concat(keyPath, \"`. Value:\"), value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                            }\n                        });\n                    }\n                    if (!ignoreState) {\n                        measureUtils.measureTime(()=>{\n                            const state = storeAPI.getState();\n                            const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                            if (foundStateNonSerializableValue) {\n                                const { keyPath, value } = foundStateNonSerializableValue;\n                                console.error(\"A non-serializable value was detected in the state, in the path: `\".concat(keyPath, \"`. Value:\"), value, \"\\nTake a look at the reducer(s) handling this action type: \".concat(action.type, \".\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)\"));\n                            }\n                        });\n                        measureUtils.warnIfExceeded();\n                    }\n                    return result;\n                };\n    }\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = ()=>function getDefaultMiddleware(options) {\n        const { thunk = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options !== null && options !== void 0 ? options : {};\n        let middlewareArray = new Tuple();\n        if (thunk) {\n            if (isBoolean(thunk)) {\n                middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n            } else {\n                middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n            }\n        }\n        if (true) {\n            if (immutableCheck) {\n                let immutableOptions = {};\n                if (!isBoolean(immutableCheck)) {\n                    immutableOptions = immutableCheck;\n                }\n                middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n            }\n            if (serializableCheck) {\n                let serializableOptions = {};\n                if (!isBoolean(serializableCheck)) {\n                    serializableOptions = serializableCheck;\n                }\n                middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n            }\n            if (actionCreatorCheck) {\n                let actionCreatorOptions = {};\n                if (!isBoolean(actionCreatorCheck)) {\n                    actionCreatorOptions = actionCreatorCheck;\n                }\n                middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n            }\n        }\n        return middlewareArray;\n    };\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = ()=>(payload)=>({\n            payload,\n            meta: {\n                [SHOULD_AUTOBATCH]: true\n            }\n        });\nvar createQueueWithTimer = (timeout)=>{\n    return (notify)=>{\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  true && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);\nvar autoBatchEnhancer = function() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n        type: \"raf\"\n    };\n    return (next)=>function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            const store = next(...args);\n            let notifying = true;\n            let shouldNotifyAtEndOfTick = false;\n            let notificationQueued = false;\n            const listeners = /* @__PURE__ */ new Set();\n            const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            const notifyListeners = ()=>{\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach((l)=>l());\n                }\n            };\n            return Object.assign({}, store, {\n                // Override the base `store.subscribe` method to keep original listeners\n                // from running if we're delaying notifications\n                subscribe (listener2) {\n                    const wrappedListener = ()=>notifying && listener2();\n                    const unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return ()=>{\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                // Override the base `store.dispatch` method so that we can check actions\n                // for the `shouldAutoBatch` flag and determine if batching is active\n                dispatch (action) {\n                    try {\n                        var _action_meta;\n                        notifying = !(action === null || action === void 0 ? void 0 : (_action_meta = action.meta) === null || _action_meta === void 0 ? void 0 : _action_meta[SHOULD_AUTOBATCH]);\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n};\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer)=>function getDefaultEnhancers(options) {\n        const { autoBatch = true } = options !== null && options !== void 0 ? options : {};\n        let enhancerArray = new Tuple(middlewareEnhancer);\n        if (autoBatch) {\n            enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n        }\n        return enhancerArray;\n    };\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n    const getDefaultMiddleware = buildGetDefaultMiddleware();\n    const { reducer = void 0, middleware, devTools = true, preloadedState = void 0, enhancers = void 0 } = options || {};\n    let rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n    }\n    if (!IS_PRODUCTION && middleware && typeof middleware !== \"function\") {\n        throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n    }\n    let finalMiddleware;\n    if (typeof middleware === \"function\") {\n        finalMiddleware = middleware(getDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    } else {\n        finalMiddleware = getDefaultMiddleware();\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n    }\n    let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools({\n            // Enable capture of stack traces for dispatched Redux actions\n            trace: !IS_PRODUCTION,\n            ...typeof devTools === \"object\" && devTools\n        });\n    }\n    const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n    if (!IS_PRODUCTION && enhancers && typeof enhancers !== \"function\") {\n        throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n    }\n    let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n    if (!IS_PRODUCTION && !Array.isArray(storeEnhancers)) {\n        throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n    }\n    if (!IS_PRODUCTION && storeEnhancers.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n    }\n    if (!IS_PRODUCTION && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n        console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n    }\n    const composedEnhancer = finalCompose(...storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    const actionsMap = {};\n    const actionMatchers = [];\n    let defaultCaseReducer;\n    const builder = {\n        addCase (typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error( false ? 0 : \"`builder.addCase` cannot be called with two reducers for the same action type '\".concat(type, \"'\"));\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher (matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher,\n                reducer\n            });\n            return builder;\n        },\n        addDefaultCase (reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n        }\n    }\n    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n    let getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = ()=>freezeDraftable(initialState());\n    } else {\n        const frozenInitialState = freezeDraftable(initialState);\n        getInitialState = ()=>frozenInitialState;\n    }\n    function reducer() {\n        let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getInitialState(), action = arguments.length > 1 ? arguments[1] : void 0;\n        let caseReducers = [\n            actionsMap[action.type],\n            ...finalActionMatchers.filter((param)=>{\n                let { matcher } = param;\n                return matcher(action);\n            }).map((param)=>{\n                let { reducer: reducer2 } = param;\n                return reducer2;\n            })\n        ];\n        if (caseReducers.filter((cr)=>!!cr).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce((previousState, caseReducer)=>{\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    const draft = previousState;\n                    const result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    const result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw new Error( false ? 0 : \"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft)=>{\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = function() {\n    let size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 21;\n    let id = \"\";\n    let i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/matchers.ts\nvar matches = (matcher, action)=>{\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf() {\n    for(var _len = arguments.length, matchers = new Array(_len), _key = 0; _key < _len; _key++){\n        matchers[_key] = arguments[_key];\n    }\n    return (action)=>{\n        return matchers.some((matcher)=>matches(matcher, action));\n    };\n}\nfunction isAllOf() {\n    for(var _len = arguments.length, matchers = new Array(_len), _key = 0; _key < _len; _key++){\n        matchers[_key] = arguments[_key];\n    }\n    return (action)=>{\n        return matchers.every((matcher)=>matches(matcher, action));\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    const hasValidRequestId = typeof action.meta.requestId === \"string\";\n    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending() {\n    for(var _len = arguments.length, asyncThunks = new Array(_len), _key = 0; _key < _len; _key++){\n        asyncThunks[_key] = arguments[_key];\n    }\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.pending);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected() {\n    for(var _len = arguments.length, asyncThunks = new Array(_len), _key = 0; _key < _len; _key++){\n        asyncThunks[_key] = arguments[_key];\n    }\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.rejected);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue() {\n    for(var _len = arguments.length, asyncThunks = new Array(_len), _key = 0; _key < _len; _key++){\n        asyncThunks[_key] = arguments[_key];\n    }\n    const hasFlag = (action)=>{\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return (action)=>{\n            const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled() {\n    for(var _len = arguments.length, asyncThunks = new Array(_len), _key = 0; _key < _len; _key++){\n        asyncThunks[_key] = arguments[_key];\n    }\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.fulfilled);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction() {\n    for(var _len = arguments.length, asyncThunks = new Array(_len), _key = 0; _key < _len; _key++){\n        asyncThunks[_key] = arguments[_key];\n    }\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = [];\n        for (const asyncThunk of asyncThunks){\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar FulfillWithMeta = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar miniSerializeError = (value)=>{\n    if (typeof value === \"object\" && value !== null) {\n        const simpleError = {};\n        for (const property of commonProperties){\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = /* @__PURE__ */ (()=>{\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta)=>({\n                payload,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"fulfilled\"\n                }\n            }));\n        const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta)=>({\n                payload: void 0,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"pending\"\n                }\n            }));\n        const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta)=>({\n                payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: (error === null || error === void 0 ? void 0 : error.name) === \"AbortError\",\n                    condition: (error === null || error === void 0 ? void 0 : error.name) === \"ConditionError\"\n                }\n            }));\n        function actionCreator(arg) {\n            return (dispatch, getState, extra)=>{\n                const requestId = (options === null || options === void 0 ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();\n                const abortController = new AbortController();\n                let abortHandler;\n                let abortReason;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                const promise = async function() {\n                    let finalAction;\n                    try {\n                        var _options_condition, _options_getPendingMeta;\n                        let conditionResult = options === null || options === void 0 ? void 0 : (_options_condition = options.condition) === null || _options_condition === void 0 ? void 0 : _options_condition.call(options, arg, {\n                            getState,\n                            extra\n                        });\n                        if (isThenable(conditionResult)) {\n                            conditionResult = await conditionResult;\n                        }\n                        if (conditionResult === false || abortController.signal.aborted) {\n                            throw {\n                                name: \"ConditionError\",\n                                message: \"Aborted due to condition callback returning false.\"\n                            };\n                        }\n                        const abortedPromise = new Promise((_, reject)=>{\n                            abortHandler = ()=>{\n                                reject({\n                                    name: \"AbortError\",\n                                    message: abortReason || \"Aborted\"\n                                });\n                            };\n                            abortController.signal.addEventListener(\"abort\", abortHandler);\n                        });\n                        dispatch(pending(requestId, arg, options === null || options === void 0 ? void 0 : (_options_getPendingMeta = options.getPendingMeta) === null || _options_getPendingMeta === void 0 ? void 0 : _options_getPendingMeta.call(options, {\n                            requestId,\n                            arg\n                        }, {\n                            getState,\n                            extra\n                        })));\n                        finalAction = await Promise.race([\n                            abortedPromise,\n                            Promise.resolve(payloadCreator(arg, {\n                                dispatch,\n                                getState,\n                                extra,\n                                requestId,\n                                signal: abortController.signal,\n                                abort,\n                                rejectWithValue: (value, meta)=>{\n                                    return new RejectWithValue(value, meta);\n                                },\n                                fulfillWithValue: (value, meta)=>{\n                                    return new FulfillWithMeta(value, meta);\n                                }\n                            })).then((result)=>{\n                                if (result instanceof RejectWithValue) {\n                                    throw result;\n                                }\n                                if (result instanceof FulfillWithMeta) {\n                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                }\n                                return fulfilled(result, requestId, arg);\n                            })\n                        ]);\n                    } catch (err) {\n                        finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n                    } finally{\n                        if (abortHandler) {\n                            abortController.signal.removeEventListener(\"abort\", abortHandler);\n                        }\n                    }\n                    const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                    if (!skipDispatch) {\n                        dispatch(finalAction);\n                    }\n                    return finalAction;\n                }();\n                return Object.assign(promise, {\n                    abort,\n                    requestId,\n                    arg,\n                    unwrap () {\n                        return promise.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending,\n            rejected,\n            fulfilled,\n            settled: isAnyOf(rejected, fulfilled),\n            typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = ()=>createAsyncThunk2;\n    return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/createSlice.ts\nvar asyncThunkSymbol = /* @__PURE__ */ Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n    [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2)=>{\n    ReducerType2[\"reducer\"] = \"reducer\";\n    ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n    ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n    return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n    return \"\".concat(slice, \"/\").concat(actionKey);\n}\nfunction buildCreateSlice() {\n    let { creators } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    var _creators_asyncThunk;\n    const cAT = creators === null || creators === void 0 ? void 0 : (_creators_asyncThunk = creators.asyncThunk) === null || _creators_asyncThunk === void 0 ? void 0 : _creators_asyncThunk[asyncThunkSymbol];\n    return function createSlice2(options) {\n        const { name, reducerPath = name } = options;\n        if (!name) {\n            throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            if (options.initialState === void 0) {\n                console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n            }\n        }\n        const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n        const reducerNames = Object.keys(reducers);\n        const context = {\n            sliceCaseReducersByName: {},\n            sliceCaseReducersByType: {},\n            actionCreators: {},\n            sliceMatchers: []\n        };\n        const contextMethods = {\n            addCase (typeOrActionCreator, reducer2) {\n                const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n                if (!type) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n                }\n                if (type in context.sliceCaseReducersByType) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n                }\n                context.sliceCaseReducersByType[type] = reducer2;\n                return contextMethods;\n            },\n            addMatcher (matcher, reducer2) {\n                context.sliceMatchers.push({\n                    matcher,\n                    reducer: reducer2\n                });\n                return contextMethods;\n            },\n            exposeAction (name2, actionCreator) {\n                context.actionCreators[name2] = actionCreator;\n                return contextMethods;\n            },\n            exposeCaseReducer (name2, reducer2) {\n                context.sliceCaseReducersByName[name2] = reducer2;\n                return contextMethods;\n            }\n        };\n        reducerNames.forEach((reducerName)=>{\n            const reducerDefinition = reducers[reducerName];\n            const reducerDetails = {\n                reducerName,\n                type: getType(name, reducerName),\n                createNotation: typeof options.reducers === \"function\"\n            };\n            if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n                handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n            } else {\n                handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n            }\n        });\n        function buildReducer() {\n            if (true) {\n                if (typeof options.extraReducers === \"object\") {\n                    throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n                options.extraReducers\n            ];\n            const finalCaseReducers = {\n                ...extraReducers,\n                ...context.sliceCaseReducersByType\n            };\n            return createReducer(options.initialState, (builder)=>{\n                for(let key in finalCaseReducers){\n                    builder.addCase(key, finalCaseReducers[key]);\n                }\n                for (let sM of context.sliceMatchers){\n                    builder.addMatcher(sM.matcher, sM.reducer);\n                }\n                for (let m of actionMatchers){\n                    builder.addMatcher(m.matcher, m.reducer);\n                }\n                if (defaultCaseReducer) {\n                    builder.addDefaultCase(defaultCaseReducer);\n                }\n            });\n        }\n        const selectSelf = (state)=>state;\n        const injectedSelectorCache = /* @__PURE__ */ new Map();\n        let _reducer;\n        function reducer(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        }\n        function getInitialState() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n        function makeSelectorProps(reducerPath2) {\n            let injected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n            function selectSlice(state) {\n                let sliceState = state[reducerPath2];\n                if (typeof sliceState === \"undefined\") {\n                    if (injected) {\n                        sliceState = getInitialState();\n                    } else if (true) {\n                        throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n                    }\n                }\n                return sliceState;\n            }\n            function getSelectors() {\n                let selectState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : selectSelf;\n                const selectorCache = emplace(injectedSelectorCache, injected, {\n                    insert: ()=>/* @__PURE__ */ new WeakMap()\n                });\n                return emplace(selectorCache, selectState, {\n                    insert: ()=>{\n                        const map = {};\n                        var _options_selectors;\n                        for (const [name2, selector] of Object.entries((_options_selectors = options.selectors) !== null && _options_selectors !== void 0 ? _options_selectors : {})){\n                            map[name2] = wrapSelector(selector, selectState, getInitialState, injected);\n                        }\n                        return map;\n                    }\n                });\n            }\n            return {\n                reducerPath: reducerPath2,\n                getSelectors,\n                get selectors () {\n                    return getSelectors(selectSlice);\n                },\n                selectSlice\n            };\n        }\n        const slice = {\n            name,\n            reducer,\n            actions: context.actionCreators,\n            caseReducers: context.sliceCaseReducersByName,\n            getInitialState,\n            ...makeSelectorProps(reducerPath),\n            injectInto (injectable) {\n                let { reducerPath: pathOpt, ...config } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                const newReducerPath = pathOpt !== null && pathOpt !== void 0 ? pathOpt : reducerPath;\n                injectable.inject({\n                    reducerPath: newReducerPath,\n                    reducer\n                }, config);\n                return {\n                    ...slice,\n                    ...makeSelectorProps(newReducerPath, true)\n                };\n            }\n        };\n        return slice;\n    };\n}\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n    function wrapper(rootState) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        let sliceState = selectState(rootState);\n        if (typeof sliceState === \"undefined\") {\n            if (injected) {\n                sliceState = getInitialState();\n            } else if (true) {\n                throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n            }\n        }\n        return selector(sliceState, ...args);\n    }\n    wrapper.unwrapped = selector;\n    return wrapper;\n}\nvar createSlice = /* @__PURE__ */ buildCreateSlice();\nfunction buildReducerCreators() {\n    function asyncThunk(payloadCreator, config) {\n        return {\n            _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */ ,\n            payloadCreator,\n            ...config\n        };\n    }\n    asyncThunk.withTypes = ()=>asyncThunk;\n    return {\n        reducer (caseReducer) {\n            return Object.assign({\n                // hack so the wrapping function has the same name as the original\n                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n                [caseReducer.name] () {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    return caseReducer(...args);\n                }\n            }[caseReducer.name], {\n                _reducerDefinitionType: \"reducer\" /* reducer */ \n            });\n        },\n        preparedReducer (prepare, reducer) {\n            return {\n                _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */ ,\n                prepare,\n                reducer\n            };\n        },\n        asyncThunk\n    };\n}\nfunction handleNormalReducerDefinition(param, maybeReducerWithPrepare, context) {\n    let { type, reducerName, createNotation } = param;\n    let caseReducer;\n    let prepareCallback;\n    if (\"reducer\" in maybeReducerWithPrepare) {\n        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n            throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n        }\n        caseReducer = maybeReducerWithPrepare.reducer;\n        prepareCallback = maybeReducerWithPrepare.prepare;\n    } else {\n        caseReducer = maybeReducerWithPrepare;\n    }\n    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */ ;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */ ;\n}\nfunction handleThunkCaseReducerDefinition(param, reducerDefinition, context, cAT) {\n    let { type, reducerName } = param;\n    if (!cAT) {\n        throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n    }\n    const { payloadCreator, fulfilled, pending, rejected, settled, options } = reducerDefinition;\n    const thunk = cAT(type, payloadCreator, options);\n    context.exposeAction(reducerName, thunk);\n    if (fulfilled) {\n        context.addCase(thunk.fulfilled, fulfilled);\n    }\n    if (pending) {\n        context.addCase(thunk.pending, pending);\n    }\n    if (rejected) {\n        context.addCase(thunk.rejected, rejected);\n    }\n    if (settled) {\n        context.addMatcher(thunk.settled, settled);\n    }\n    context.exposeCaseReducer(reducerName, {\n        fulfilled: fulfilled || noop,\n        pending: pending || noop,\n        rejected: rejected || noop,\n        settled: settled || noop\n    });\n}\nfunction noop() {}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory(stateAdapter) {\n    function getInitialState() {\n        let additionalState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, entities = arguments.length > 1 ? arguments[1] : void 0;\n        const state = Object.assign(getInitialEntityState(), additionalState);\n        return entities ? stateAdapter.setAll(state, entities) : state;\n    }\n    return {\n        getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const { createSelector: createSelector2 = createDraftSafeSelector } = options;\n        const selectIds = (state)=>state.ids;\n        const selectEntities = (state)=>state.entities;\n        const selectAll = createSelector2(selectIds, selectEntities, (ids, entities)=>ids.map((id)=>entities[id]));\n        const selectId = (_, id)=>id;\n        const selectById = (entities, id)=>entities[id];\n        const selectTotal = createSelector2(selectIds, (ids)=>ids.length);\n        if (!selectState) {\n            return {\n                selectIds,\n                selectEntities,\n                selectAll,\n                selectTotal,\n                selectById: createSelector2(selectEntities, selectId, selectById)\n            };\n        }\n        const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n        return {\n            selectIds: createSelector2(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createSelector2(selectState, selectAll),\n            selectTotal: createSelector2(selectState, selectTotal),\n            selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n    const operator = createStateOperator((_, state)=>mutator(state));\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        const runMutator = (draft)=>{\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if (isDraftTyped(state)) {\n            runMutator(state);\n            return state;\n        }\n        return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    const key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const added = [];\n    const updated = [];\n    for (const entity of newEntities){\n        const id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        ;\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        let didMutate = false;\n        keys.forEach((key)=>{\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter((id)=>id in state.entities);\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        const original3 = state.entities[update.id];\n        if (original3 === void 0) {\n            return false;\n        }\n        const updated = Object.assign({}, original3, update.changes);\n        const newKey = selectIdValue(updated, selectId);\n        const hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        ;\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        const newKeys = {};\n        const updatesPerEntity = {};\n        updates.forEach((update)=>{\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    // Spreads ignore falsy values, so this works even if there isn't\n                    // an existing update already at this key\n                    changes: {\n                        ...updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null,\n                        ...update.changes\n                    }\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        const didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            const didMutateIds = updates.filter((update)=>takeNewKey(newKeys, update, state)).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.values(state.entities).map((e)=>selectIdValue(e, selectId));\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(selectId);\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        const models = newEntities.filter((model)=>!(selectIdValue(model, selectId) in state.entities));\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        let appliedUpdates = false;\n        for (let update of updates){\n            const entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            const newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach((model)=>{\n            ;\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        const allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        const newSortedIds = allEntities.map(selectId);\n        const { ids } = state;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne,\n        removeMany,\n        removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const { selectId, sortComparer } = {\n        sortComparer: false,\n        selectId: (instance)=>instance.id,\n        ...options\n    };\n    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    const stateFactory = createInitialStateFactory(stateAdapter);\n    const selectorsFactory = createSelectorsFactory();\n    return {\n        selectId,\n        sortComparer,\n        ...stateFactory,\n        ...selectorsFactory,\n        ...stateAdapter\n    };\n}\n// src/listenerMiddleware/index.ts\n\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = \"task-\".concat(cancelled);\nvar taskCompleted = \"task-\".concat(completed);\nvar listenerCancelled = \"\".concat(listener, \"-\").concat(cancelled);\nvar listenerCompleted = \"\".concat(listener, \"-\").concat(completed);\nvar TaskAbortError = class {\n    constructor(code){\n        this.name = \"TaskAbortError\";\n        this.code = code;\n        this.message = \"\".concat(task, \" \").concat(cancelled, \" (reason: \").concat(code, \")\");\n    }\n};\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected)=>{\n    if (typeof func !== \"function\") {\n        throw new Error( false ? 0 : \"\".concat(expected, \" is not a function\"));\n    }\n};\nvar noop2 = ()=>{};\nvar catchRejection = function(promise) {\n    let onError = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;\n    promise.catch(onError);\n    return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback)=>{\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return ()=>abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason)=>{\n    const signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal)=>{\n    if (signal.aborted) {\n        const { reason } = signal;\n        throw new TaskAbortError(reason);\n    }\n};\nfunction raceWithSignal(signal, promise) {\n    let cleanup = noop2;\n    return new Promise((resolve, reject)=>{\n        const notifyRejection = ()=>reject(new TaskAbortError(signal.reason));\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise.finally(()=>cleanup()).then(resolve, reject);\n    }).finally(()=>{\n        cleanup = noop2;\n    });\n}\nvar runTask = async (task2, cleanUp)=>{\n    try {\n        await Promise.resolve();\n        const value = await task2();\n        return {\n            status: \"ok\",\n            value\n        };\n    } catch (error) {\n        return {\n            status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n            error\n        };\n    } finally{\n        cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();\n    }\n};\nvar createPause = (signal)=>{\n    return (promise)=>{\n        return catchRejection(raceWithSignal(signal, promise).then((output)=>{\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = (signal)=>{\n    const pause = createPause(signal);\n    return (timeoutMs)=>{\n        return pause(new Promise((resolve)=>setTimeout(resolve, timeoutMs)));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar { assign } = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises)=>{\n    const linkControllers = (controller)=>addAbortSignalListener(parentAbortSignal, ()=>abortControllerWithReason(controller, parentAbortSignal.reason));\n    return (taskExecutor, opts)=>{\n        assertFunction(taskExecutor, \"taskExecutor\");\n        const childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        const result = runTask(async ()=>{\n            validateActive(parentAbortSignal);\n            validateActive(childAbortController.signal);\n            const result2 = await taskExecutor({\n                pause: createPause(childAbortController.signal),\n                delay: createDelay(childAbortController.signal),\n                signal: childAbortController.signal\n            });\n            validateActive(childAbortController.signal);\n            return result2;\n        }, ()=>abortControllerWithReason(childAbortController, taskCompleted));\n        if (opts === null || opts === void 0 ? void 0 : opts.autoJoin) {\n            parentBlockingPromises.push(result.catch(noop2));\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel () {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = (startListening, signal)=>{\n    const take = async (predicate, timeout)=>{\n        validateActive(signal);\n        let unsubscribe = ()=>{};\n        const tuplePromise = new Promise((resolve, reject)=>{\n            let stopListening = startListening({\n                predicate,\n                effect: (action, listenerApi)=>{\n                    listenerApi.unsubscribe();\n                    resolve([\n                        action,\n                        listenerApi.getState(),\n                        listenerApi.getOriginalState()\n                    ]);\n                }\n            });\n            unsubscribe = ()=>{\n                stopListening();\n                reject();\n            };\n        });\n        const promises = [\n            tuplePromise\n        ];\n        if (timeout != null) {\n            promises.push(new Promise((resolve)=>setTimeout(resolve, timeout, null)));\n        }\n        try {\n            const output = await raceWithSignal(signal, Promise.race(promises));\n            validateActive(signal);\n            return output;\n        } finally{\n            unsubscribe();\n        }\n    };\n    return (predicate, timeout)=>catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options)=>{\n    let { type, actionCreator, matcher, predicate, effect } = options;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate,\n        type,\n        effect\n    };\n};\nvar createListenerEntry = Object.assign((options)=>{\n    const { type, predicate, effect } = getListenerEntryPropsFrom(options);\n    const id = nanoid();\n    const entry = {\n        id,\n        effect,\n        type,\n        predicate,\n        pending: /* @__PURE__ */ new Set(),\n        unsubscribe: ()=>{\n            throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n}, {\n    withTypes: ()=>createListenerEntry\n});\nvar cancelActiveListeners = (entry)=>{\n    entry.pending.forEach((controller)=>{\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = (listenerMap)=>{\n    return ()=>{\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo)=>{\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(()=>{\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = Object.assign(createAction(\"\".concat(alm, \"/add\")), {\n    withTypes: ()=>addListener\n});\nvar clearAllListeners = createAction(\"\".concat(alm, \"/removeAll\"));\nvar removeListener = Object.assign(createAction(\"\".concat(alm, \"/remove\")), {\n    withTypes: ()=>removeListener\n});\nvar defaultErrorHandler = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    console.error(\"\".concat(alm, \"/error\"), ...args);\n};\nvar createListenerMiddleware = function() {\n    let middlewareOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const listenerMap = /* @__PURE__ */ new Map();\n    const { extra, onError = defaultErrorHandler } = middlewareOptions;\n    assertFunction(onError, \"onError\");\n    const insertEntry = (entry)=>{\n        entry.unsubscribe = ()=>listenerMap.delete(entry.id);\n        listenerMap.set(entry.id, entry);\n        return (cancelOptions)=>{\n            entry.unsubscribe();\n            if (cancelOptions === null || cancelOptions === void 0 ? void 0 : cancelOptions.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    const startListening = (options)=>{\n        let entry = find(Array.from(listenerMap.values()), (existingEntry)=>existingEntry.effect === options.effect);\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    Object.assign(startListening, {\n        withTypes: ()=>startListening\n    });\n    const stopListening = (options)=>{\n        const { type, effect, predicate } = getListenerEntryPropsFrom(options);\n        const entry = find(Array.from(listenerMap.values()), (entry2)=>{\n            const matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    Object.assign(stopListening, {\n        withTypes: ()=>stopListening\n    });\n    const notifyListener = async (entry, action, api, getOriginalState)=>{\n        const internalTaskController = new AbortController();\n        const take = createTakePattern(startListening, internalTaskController.signal);\n        const autoJoinPromises = [];\n        try {\n            entry.pending.add(internalTaskController);\n            await Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle\n            assign({}, api, {\n                getOriginalState,\n                condition: (predicate, timeout)=>take(predicate, timeout).then(Boolean),\n                take,\n                delay: createDelay(internalTaskController.signal),\n                pause: createPause(internalTaskController.signal),\n                extra,\n                signal: internalTaskController.signal,\n                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                unsubscribe: entry.unsubscribe,\n                subscribe: ()=>{\n                    listenerMap.set(entry.id, entry);\n                },\n                cancelActiveListeners: ()=>{\n                    entry.pending.forEach((controller, _, set)=>{\n                        if (controller !== internalTaskController) {\n                            abortControllerWithReason(controller, listenerCancelled);\n                            set.delete(controller);\n                        }\n                    });\n                },\n                cancel: ()=>{\n                    abortControllerWithReason(internalTaskController, listenerCancelled);\n                    entry.pending.delete(internalTaskController);\n                },\n                throwIfCancelled: ()=>{\n                    validateActive(internalTaskController.signal);\n                }\n            })));\n        } catch (listenerError) {\n            if (!(listenerError instanceof TaskAbortError)) {\n                safelyNotifyError(onError, listenerError, {\n                    raisedBy: \"effect\"\n                });\n            }\n        } finally{\n            await Promise.all(autoJoinPromises);\n            abortControllerWithReason(internalTaskController, listenerCompleted);\n            entry.pending.delete(internalTaskController);\n        }\n    };\n    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    const middleware = (api)=>(next)=>(action)=>{\n                if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                let originalState = api.getState();\n                const getOriginalState = ()=>{\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error( false ? 0 : \"\".concat(alm, \": getOriginalState can only be called synchronously\"));\n                    }\n                    return originalState;\n                };\n                let result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        const currentState = api.getState();\n                        const listenerEntries = Array.from(listenerMap.values());\n                        for (const entry of listenerEntries){\n                            let runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n    return {\n        middleware,\n        startListening,\n        stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n};\n// src/dynamicMiddleware/index.ts\n\nvar createMiddlewareEntry = (middleware)=>({\n        id: nanoid(),\n        middleware,\n        applied: /* @__PURE__ */ new Map()\n    });\nvar matchInstance = (instanceId)=>(action)=>{\n        var _action_meta;\n        return (action === null || action === void 0 ? void 0 : (_action_meta = action.meta) === null || _action_meta === void 0 ? void 0 : _action_meta.instanceId) === instanceId;\n    };\nvar createDynamicMiddleware = ()=>{\n    const instanceId = nanoid();\n    const middlewareMap = /* @__PURE__ */ new Map();\n    const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", function() {\n        for(var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++){\n            middlewares[_key] = arguments[_key];\n        }\n        return {\n            payload: middlewares,\n            meta: {\n                instanceId\n            }\n        };\n    }), {\n        withTypes: ()=>withMiddleware\n    });\n    const addMiddleware = Object.assign(function addMiddleware2() {\n        for(var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++){\n            middlewares[_key] = arguments[_key];\n        }\n        middlewares.forEach((middleware2)=>{\n            let entry = find(Array.from(middlewareMap.values()), (entry2)=>entry2.middleware === middleware2);\n            if (!entry) {\n                entry = createMiddlewareEntry(middleware2);\n            }\n            middlewareMap.set(entry.id, entry);\n        });\n    }, {\n        withTypes: ()=>addMiddleware\n    });\n    const getFinalMiddleware = (api)=>{\n        const appliedMiddleware = Array.from(middlewareMap.values()).map((entry)=>emplace(entry.applied, api, {\n                insert: ()=>entry.middleware(api)\n            }));\n        return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n    };\n    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n    const middleware = (api)=>(next)=>(action)=>{\n                if (isWithMiddleware(action)) {\n                    addMiddleware(...action.payload);\n                    return api.dispatch;\n                }\n                return getFinalMiddleware(api)(next)(action);\n            };\n    return {\n        middleware,\n        addMiddleware,\n        withMiddleware,\n        instanceId\n    };\n};\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike)=>\"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices)=>slices.flatMap((sliceOrMap)=>isSliceLike(sliceOrMap) ? [\n            [\n                sliceOrMap.reducerPath,\n                sliceOrMap.reducer\n            ]\n        ] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value)=>!!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap)=>emplace(stateProxyMap, state, {\n        insert: ()=>new Proxy(state, {\n                get: (target, prop, receiver)=>{\n                    if (prop === ORIGINAL_STATE) return target;\n                    const result = Reflect.get(target, prop, receiver);\n                    if (typeof result === \"undefined\") {\n                        const reducer = reducerMap[prop.toString()];\n                        if (reducer) {\n                            const reducerResult = reducer(void 0, {\n                                type: nanoid()\n                            });\n                            if (typeof reducerResult === \"undefined\") {\n                                throw new Error( false ? 0 : 'The slice reducer for key \"'.concat(prop.toString(), \"\\\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.\"));\n                            }\n                            return reducerResult;\n                        }\n                    }\n                    return result;\n                }\n            })\n    });\nvar original = (state)=>{\n    if (!isStateProxy(state)) {\n        throw new Error( false ? 0 : \"original must be used on state Proxy\");\n    }\n    return state[ORIGINAL_STATE];\n};\nvar noopReducer = function() {\n    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return state;\n};\nfunction combineSlices() {\n    for(var _len = arguments.length, slices = new Array(_len), _key = 0; _key < _len; _key++){\n        slices[_key] = arguments[_key];\n    }\n    const reducerMap = Object.fromEntries(getReducers(slices));\n    const getReducer = ()=>Object.keys(reducerMap).length ? (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap) : noopReducer;\n    let reducer = getReducer();\n    function combinedReducer(state, action) {\n        return reducer(state, action);\n    }\n    combinedReducer.withLazyLoadedSlices = ()=>combinedReducer;\n    const inject = function(slice) {\n        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const { reducerPath, reducer: reducerToInject } = slice;\n        const currentReducer = reducerMap[reducerPath];\n        if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n            if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                console.error(\"called `inject` to override already-existing reducer \".concat(reducerPath, \" without specifying `overrideExisting: true`\"));\n            }\n            return combinedReducer;\n        }\n        reducerMap[reducerPath] = reducerToInject;\n        reducer = getReducer();\n        return combinedReducer;\n    };\n    const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n        return function selector2(state) {\n            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                args[_key - 1] = arguments[_key];\n            }\n            return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);\n        };\n    }, {\n        original\n    });\n    return Object.assign(combinedReducer, {\n        inject,\n        selector\n    });\n}\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n    return \"Minified Redux Toolkit error #\".concat(code, \"; visit https://redux-toolkit.js.org/Errors?code=\").concat(code, \" for the full message or use the non-minified dev environment for full errors. \");\n}\n //# sourceMappingURL=redux-toolkit.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcmVkdXgtdG9vbGtpdC5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ087QUFDbUY7QUFDaUM7QUFFMUksaUNBQWlDO0FBQ1E7QUFDd0I7QUFDakUsSUFBSWMsaUNBQWlDO3FDQUFJQztRQUFBQTs7SUFDdkMsTUFBTUMsa0JBQWtCUCwrREFBcUJBLElBQUlNO0lBQ2pELE1BQU1FLDJCQUEyQkMsT0FBT0MsTUFBTSxDQUFDO3lDQUFJQztZQUFBQTs7UUFDakQsTUFBTUMsV0FBV0wsbUJBQW1CSTtRQUNwQyxNQUFNRSxrQkFBa0IsU0FBQ0M7NkNBQVVDO2dCQUFBQTs7bUJBQVNILFNBQVNmLDhDQUFPQSxDQUFDaUIsU0FBU3RCLDhDQUFPQSxDQUFDc0IsU0FBU0EsVUFBVUM7O1FBQ2pHTixPQUFPQyxNQUFNLENBQUNHLGlCQUFpQkQ7UUFDL0IsT0FBT0M7SUFDVCxHQUFHO1FBQ0RHLFdBQVcsSUFBTVI7SUFDbkI7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsSUFBSVMsMEJBQTBCWiwrQkFBK0JGLG9EQUFjQTtBQUUzRSx3QkFBd0I7QUFDb0c7QUFFNUgsMkJBQTJCO0FBQ0s7QUFDaEMsSUFBSXNCLHNCQUFzQixLQUE2QixJQUFJQyxPQUFPQyxvQ0FBb0MsR0FBR0QsT0FBT0Msb0NBQW9DLEdBQUc7SUFDckosSUFBSUMsVUFBVUMsTUFBTSxLQUFLLEdBQ3ZCLE9BQU8sS0FBSztJQUNkLElBQUksT0FBT0QsU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUMxQixPQUFPUiwwQ0FBT0E7SUFDaEIsT0FBT0EsMENBQU9BLENBQUNVLEtBQUssQ0FBQyxNQUFNRjtBQUM3QjtBQUNBLElBQUlHLG1CQUFtQixLQUE2QixJQUFJTCxPQUFPTSw0QkFBNEIs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QUNBWCxVQUFVLENBQUNwUixZQUFZLEdBQUdpUztRQUMxQnRhLFVBQVVtYTtRQUNWLE9BQU9DO0lBQ1Q7SUFDQSxNQUFNdm9CLFdBQVdILE9BQU9DLE1BQU0sQ0FBQyxTQUFTOG9CLGFBQWFDLFVBQVUsRUFBRWxRLFdBQVc7UUFDMUUsT0FBTyxTQUFTbVEsVUFBVW5mLEtBQUs7WUFBRTtnQkFBR2pLLEtBQUgsMkJBQU87O1lBQ3RDLE9BQU9tcEIsV0FBV2xCLGlCQUFpQmhQLGNBQWNBLFlBQVloUCxVQUFVakssUUFBUWlLLE9BQU9pZSxnQkFBZ0Jsb0I7UUFDeEc7SUFDRixHQUFHO1FBQ0RYO0lBQ0Y7SUFDQSxPQUFPYyxPQUFPQyxNQUFNLENBQUN5b0IsaUJBQWlCO1FBQ3BDalA7UUFDQXRaO0lBQ0Y7QUFDRjtBQUVBLGdDQUFnQztBQUNoQyxTQUFTb0MsdUJBQXVCOGQsSUFBSTtJQUNsQyxPQUFPLGlDQUF5RkEsT0FBeERBLE1BQUsscURBQXdELE9BQUxBLE1BQUs7QUFDdkc7QUFvREUsQ0FDRixpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0Lm1vZGVybi5tanM/YWQzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IHsgcHJvZHVjZSwgY3VycmVudCBhcyBjdXJyZW50MiwgZnJlZXplLCBvcmlnaW5hbCBhcyBvcmlnaW5hbDIsIGlzRHJhZnQgYXMgaXNEcmFmdDQgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3RvckNyZWF0b3IgYXMgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiwgbHJ1TWVtb2l6ZSwgd2Vha01hcE1lbW9pemUgYXMgd2Vha01hcE1lbW9pemUyIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5cbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xuaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLCB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gXCJyZXNlbGVjdFwiO1xudmFyIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciguLi5hcmdzKTtcbiAgY29uc3QgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyID0gT2JqZWN0LmFzc2lnbigoLi4uYXJnczIpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yMiguLi5hcmdzMik7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gKHZhbHVlLCAuLi5yZXN0KSA9PiBzZWxlY3Rvcihpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyO1xufTtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7XG5cbi8vIHNyYy9jb25maWd1cmVTdG9yZS50c1xuaW1wb3J0IHsgYXBwbHlNaWRkbGV3YXJlLCBjcmVhdGVTdG9yZSwgY29tcG9zZSBhcyBjb21wb3NlMiwgY29tYmluZVJlZHVjZXJzLCBpc1BsYWluT2JqZWN0IGFzIGlzUGxhaW5PYmplY3QyIH0gZnJvbSBcInJlZHV4XCI7XG5cbi8vIHNyYy9kZXZ0b29sc0V4dGVuc2lvbi50c1xuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gXCJyZWR1eFwiO1xudmFyIGNvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIDogZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBjb21wb3NlO1xuICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbnZhciBkZXZUb29sc0VuaGFuY2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIDogZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbihub29wMykge1xuICAgIHJldHVybiBub29wMztcbiAgfTtcbn07XG5cbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xuaW1wb3J0IHsgdGh1bmsgYXMgdGh1bmtNaWRkbGV3YXJlLCB3aXRoRXh0cmFBcmd1bWVudCB9IGZyb20gXCJyZWR1eC10aHVua1wiO1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5pbXBvcnQgeyBpc0FjdGlvbiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvdHNIZWxwZXJzLnRzXG52YXIgaGFzTWF0Y2hGdW5jdGlvbiA9ICh2KSA9PiB7XG4gIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUFjdGlvbikge1xuICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpIHtcbiAgICBpZiAocHJlcGFyZUFjdGlvbikge1xuICAgICAgbGV0IHByZXBhcmVkID0gcHJlcGFyZUFjdGlvbiguLi5hcmdzKTtcbiAgICAgIGlmICghcHJlcGFyZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiBcInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcHJlcGFyZWQucGF5bG9hZCxcbiAgICAgICAgLi4uXCJtZXRhXCIgaW4gcHJlcGFyZWQgJiYge1xuICAgICAgICAgIG1ldGE6IHByZXBhcmVkLm1ldGFcbiAgICAgICAgfSxcbiAgICAgICAgLi4uXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBlcnJvcjogcHJlcGFyZWQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkOiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gKCkgPT4gYCR7dHlwZX1gO1xuICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xuICBhY3Rpb25DcmVhdG9yLm1hdGNoID0gKGFjdGlvbikgPT4gaXNBY3Rpb24oYWN0aW9uKSAmJiBhY3Rpb24udHlwZSA9PT0gdHlwZTtcbiAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XG59XG5mdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIgJiYgXCJ0eXBlXCIgaW4gYWN0aW9uICYmIC8vIGhhc01hdGNoRnVuY3Rpb24gb25seSB3YW50cyBNYXRjaGVycyBidXQgSSBkb24ndCBzZWUgdGhlIHBvaW50IGluIHJld3JpdGluZyBpdFxuICBoYXNNYXRjaEZ1bmN0aW9uKGFjdGlvbik7XG59XG5mdW5jdGlvbiBpc0ZTQShhY3Rpb24pIHtcbiAgcmV0dXJuIGlzQWN0aW9uKGFjdGlvbikgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbXCJ0eXBlXCIsIFwicGF5bG9hZFwiLCBcImVycm9yXCIsIFwibWV0YVwiXS5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuLy8gc3JjL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcbiAgY29uc3Qgc3BsaXRUeXBlID0gdHlwZSA/IGAke3R5cGV9YC5zcGxpdChcIi9cIikgOiBbXTtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IHNwbGl0VHlwZVtzcGxpdFR5cGUubGVuZ3RoIC0gMV0gfHwgXCJhY3Rpb25DcmVhdG9yXCI7XG4gIHJldHVybiBgRGV0ZWN0ZWQgYW4gYWN0aW9uIGNyZWF0b3Igd2l0aCB0eXBlIFwiJHt0eXBlIHx8IFwidW5rbm93blwifVwiIGJlaW5nIGRpc3BhdGNoZWQuIFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSgpKVxcYCBpbnN0ZWFkIG9mIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0pXFxgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuYDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH1cbiAgY29uc3Qge1xuICAgIGlzQWN0aW9uQ3JlYXRvcjogaXNBY3Rpb25DcmVhdG9yMiA9IGlzQWN0aW9uQ3JlYXRvclxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKGlzQWN0aW9uQ3JlYXRvcjIoYWN0aW9uKSkge1xuICAgICAgY29uc29sZS53YXJuKGdldE1lc3NhZ2UoYWN0aW9uLnR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzLnRzXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgaXNEcmFmdGFibGUgfSBmcm9tIFwiaW1tZXJcIjtcbmZ1bmN0aW9uIGdldFRpbWVNZWFzdXJlVXRpbHMobWF4RGVsYXksIGZuTmFtZSkge1xuICBsZXQgZWxhcHNlZCA9IDA7XG4gIHJldHVybiB7XG4gICAgbWVhc3VyZVRpbWUoZm4pIHtcbiAgICAgIGNvbnN0IHN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb25zdCBmaW5pc2hlZCA9IERhdGUubm93KCk7XG4gICAgICAgIGVsYXBzZWQgKz0gZmluaXNoZWQgLSBzdGFydGVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2FybklmRXhjZWVkZWQoKSB7XG4gICAgICBpZiAoZWxhcHNlZCA+IG1heERlbGF5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHtmbk5hbWV9IHRvb2sgJHtlbGFwc2VkfW1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mICR7bWF4RGVsYXl9bXMuIFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxuSXQgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMsIHNvIHlvdSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZmluZChpdGVyYWJsZSwgY29tcGFyYXRvcikge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IoZW50cnkpKSB7XG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG52YXIgVHVwbGUgPSBjbGFzcyBfVHVwbGUgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKC4uLml0ZW1zKSB7XG4gICAgc3VwZXIoLi4uaXRlbXMpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfVHVwbGUucHJvdG90eXBlKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgcmV0dXJuIF9UdXBsZTtcbiAgfVxuICBjb25jYXQoLi4uYXJyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xuICB9XG4gIHByZXBlbmQoLi4uYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XG4gICAgICByZXR1cm4gbmV3IF9UdXBsZSguLi5hcnJbMF0uY29uY2F0KHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyLmNvbmNhdCh0aGlzKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XG4gIHJldHVybiBpc0RyYWZ0YWJsZSh2YWwpID8gY3JlYXRlTmV4dFN0YXRlKHZhbCwgKCkgPT4ge1xuICB9KSA6IHZhbDtcbn1cbmZ1bmN0aW9uIGVtcGxhY2UobWFwLCBrZXksIGhhbmRsZXIpIHtcbiAgaWYgKG1hcC5oYXMoa2V5KSkge1xuICAgIGxldCB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoaGFuZGxlci51cGRhdGUpIHtcbiAgICAgIHZhbHVlID0gaGFuZGxlci51cGRhdGUodmFsdWUsIGtleSwgbWFwKTtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoIWhhbmRsZXIuaW5zZXJ0KVxuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEwKSA6IFwiTm8gaW5zZXJ0IHByb3ZpZGVkIGZvciBrZXkgbm90IGFscmVhZHkgaW4gbWFwXCIpO1xuICBjb25zdCBpbnNlcnRlZCA9IGhhbmRsZXIuaW5zZXJ0KGtleSwgbWFwKTtcbiAgbWFwLnNldChrZXksIGluc2VydGVkKTtcbiAgcmV0dXJuIGluc2VydGVkO1xufVxuXG4vLyBzcmMvaW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0ltbXV0YWJsZURlZmF1bHQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PSBudWxsIHx8IE9iamVjdC5pc0Zyb3plbih2YWx1ZSk7XG59XG5mdW5jdGlvbiB0cmFja0Zvck11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaikge1xuICBjb25zdCB0cmFja2VkUHJvcGVydGllcyA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaik7XG4gIHJldHVybiB7XG4gICAgZGV0ZWN0TXV0YXRpb25zKCkge1xuICAgICAgcmV0dXJuIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIHRyYWNrZWRQcm9wZXJ0aWVzLCBvYmopO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMgPSBbXSwgb2JqLCBwYXRoID0gXCJcIiwgY2hlY2tlZE9iamVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB7XG4gIGNvbnN0IHRyYWNrZWQgPSB7XG4gICAgdmFsdWU6IG9ialxuICB9O1xuICBpZiAoIWlzSW1tdXRhYmxlKG9iaikgJiYgIWNoZWNrZWRPYmplY3RzLmhhcyhvYmopKSB7XG4gICAgY2hlY2tlZE9iamVjdHMuYWRkKG9iaik7XG4gICAgdHJhY2tlZC5jaGlsZHJlbiA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGgpICE9PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhY2tlZDtcbn1cbmZ1bmN0aW9uIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzID0gW10sIHRyYWNrZWRQcm9wZXJ0eSwgb2JqLCBzYW1lUGFyZW50UmVmID0gZmFsc2UsIHBhdGggPSBcIlwiKSB7XG4gIGNvbnN0IHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB2b2lkIDA7XG4gIGNvbnN0IHNhbWVSZWYgPSBwcmV2T2JqID09PSBvYmo7XG4gIGlmIChzYW1lUGFyZW50UmVmICYmICFzYW1lUmVmICYmICFOdW1iZXIuaXNOYU4ob2JqKSkge1xuICAgIHJldHVybiB7XG4gICAgICB3YXNNdXRhdGVkOiB0cnVlLFxuICAgICAgcGF0aFxuICAgIH07XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKHByZXZPYmopIHx8IGlzSW1tdXRhYmxlKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IGtleXNUb0RldGVjdCA9IHt9O1xuICBmb3IgKGxldCBrZXkgaW4gdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XG4gIH1cbiAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gIGZvciAobGV0IGtleSBpbiBrZXlzVG9EZXRlY3QpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbltrZXldLCBvYmpba2V5XSwgc2FtZVJlZiwgbmVzdGVkUGF0aCk7XG4gICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucyA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgc3RyaW5naWZ5MiA9IGZ1bmN0aW9uKG9iaiwgc2VyaWFsaXplciwgaW5kZW50LCBkZWN5Y2xlcikge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZ2V0U2VyaWFsaXplMihzZXJpYWxpemVyLCBkZWN5Y2xlciksIGluZGVudCk7XG4gICAgfSwgZ2V0U2VyaWFsaXplMiA9IGZ1bmN0aW9uKHNlcmlhbGl6ZXIsIGRlY3ljbGVyKSB7XG4gICAgICBsZXQgc3RhY2sgPSBbXSwga2V5cyA9IFtdO1xuICAgICAgaWYgKCFkZWN5Y2xlcilcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbihfLCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfl1cIjtcbiAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XG4gICAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IHN0YWNrLnNwbGljZSh0aGlzUG9zICsgMSkgOiBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPT0gbnVsbCA/IHZhbHVlIDogc2VyaWFsaXplci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnkyLCBnZXRTZXJpYWxpemUgPSBnZXRTZXJpYWxpemUyO1xuICAgIGxldCB7XG4gICAgICBpc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgICAgIGlnbm9yZWRQYXRocyxcbiAgICAgIHdhcm5BZnRlciA9IDMyXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xuICAgIHJldHVybiAoe1xuICAgICAgZ2V0U3RhdGVcbiAgICB9KSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgbGV0IHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgcmV0dXJuIChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkpIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGJldHdlZW4gZGlzcGF0Y2hlcywgaW4gdGhlIHBhdGggJyR7cmVzdWx0LnBhdGggfHwgXCJcIn0nLiAgVGhpcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yLiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xuICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMCkgOiBgQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiAke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9LiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uICR7c3RyaW5naWZ5MihhY3Rpb24pfS4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMiwgaXNQbGFpbk9iamVjdCB9IGZyb20gXCJyZWR1eFwiO1xuZnVuY3Rpb24gaXNQbGFpbih2YWwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKTtcbn1cbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIsIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbiwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzID0gW10sIGNhY2hlKSB7XG4gIGxldCBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgaWYgKCFpc1NlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNhY2hlPy5oYXModmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgZW50cmllcykge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZSgoaWdub3JlZCkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5UGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXN0ZWRWYWx1ZSwgbmVzdGVkUGF0aCwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuICAgICAgaWYgKGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlKSB7XG4gICAgICAgIHJldHVybiBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNhY2hlICYmIGlzTmVzdGVkRnJvemVuKHZhbHVlKSlcbiAgICBjYWNoZS5hZGQodmFsdWUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xuICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IG5lc3RlZFZhbHVlIG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICghaXNOZXN0ZWRGcm96ZW4obmVzdGVkVmFsdWUpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluLFxuICAgICAgZ2V0RW50cmllcyxcbiAgICAgIGlnbm9yZWRBY3Rpb25zID0gW10sXG4gICAgICBpZ25vcmVkQWN0aW9uUGF0aHMgPSBbXCJtZXRhLmFyZ1wiLCBcIm1ldGEuYmFzZVF1ZXJ5TWV0YVwiXSxcbiAgICAgIGlnbm9yZWRQYXRocyA9IFtdLFxuICAgICAgd2FybkFmdGVyID0gMzIsXG4gICAgICBpZ25vcmVTdGF0ZSA9IGZhbHNlLFxuICAgICAgaWdub3JlQWN0aW9ucyA9IGZhbHNlLFxuICAgICAgZGlzYWJsZUNhY2hlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjYWNoZSA9ICFkaXNhYmxlQ2FjaGUgJiYgV2Vha1NldCA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpIDogdm9pZCAwO1xuICAgIHJldHVybiAoc3RvcmVBUEkpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoIWlzQWN0aW9uMihhY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XG4gICAgICBpZiAoIWlnbm9yZUFjdGlvbnMgJiYgIShpZ25vcmVkQWN0aW9ucy5sZW5ndGggJiYgaWdub3JlZEFjdGlvbnMuaW5kZXhPZihhY3Rpb24udHlwZSkgIT09IC0xKSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoYWN0aW9uLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZEFjdGlvblBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiBhbiBhY3Rpb24sIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiBcIiwgYWN0aW9uLCBcIlxcbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL2FjdGlvbnMjd2h5LXNob3VsZC10eXBlLWJlLWEtc3RyaW5nLW9yLWF0LWxlYXN0LXNlcmlhbGl6YWJsZS13aHktc2hvdWxkLW15LWFjdGlvbi10eXBlcy1iZS1jb25zdGFudHMpXCIsIFwiXFxuKFRvIGFsbG93IG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIHNlZTogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy91c2FnZS91c2FnZS1ndWlkZSN3b3JraW5nLXdpdGgtbm9uLXNlcmlhbGl6YWJsZS1kYXRhKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFpZ25vcmVTdGF0ZSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmVBUEkuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoc3RhdGUsIFwiXCIsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcbiAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiB0aGUgc3RhdGUsIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgYFxuVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhpcyBhY3Rpb24gdHlwZTogJHthY3Rpb24udHlwZX0uXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJib29sZWFuXCI7XG59XG52YXIgYnVpbGRHZXREZWZhdWx0TWlkZGxld2FyZSA9ICgpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHRodW5rID0gdHJ1ZSxcbiAgICBpbW11dGFibGVDaGVjayA9IHRydWUsXG4gICAgc2VyaWFsaXphYmxlQ2hlY2sgPSB0cnVlLFxuICAgIGFjdGlvbkNyZWF0b3JDaGVjayA9IHRydWVcbiAgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCBtaWRkbGV3YXJlQXJyYXkgPSBuZXcgVHVwbGUoKTtcbiAgaWYgKHRodW5rKSB7XG4gICAgaWYgKGlzQm9vbGVhbih0aHVuaykpIHtcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHRodW5rTWlkZGxld2FyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHdpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChpbW11dGFibGVDaGVjaykge1xuICAgICAgbGV0IGltbXV0YWJsZU9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xuICAgICAgICBpbW11dGFibGVPcHRpb25zID0gaW1tdXRhYmxlQ2hlY2s7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoaW1tdXRhYmxlT3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXphYmxlQ2hlY2spIHtcbiAgICAgIGxldCBzZXJpYWxpemFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcbiAgICAgICAgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHNlcmlhbGl6YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKHNlcmlhbGl6YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbkNyZWF0b3JDaGVjaykge1xuICAgICAgbGV0IGFjdGlvbkNyZWF0b3JPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XG4gICAgICAgIGFjdGlvbkNyZWF0b3JPcHRpb25zID0gYWN0aW9uQ3JlYXRvckNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUoYWN0aW9uQ3JlYXRvck9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pZGRsZXdhcmVBcnJheTtcbn07XG5cbi8vIHNyYy9hdXRvQmF0Y2hFbmhhbmNlci50c1xudmFyIFNIT1VMRF9BVVRPQkFUQ0ggPSBcIlJUS19hdXRvQmF0Y2hcIjtcbnZhciBwcmVwYXJlQXV0b0JhdGNoZWQgPSAoKSA9PiAocGF5bG9hZCkgPT4gKHtcbiAgcGF5bG9hZCxcbiAgbWV0YToge1xuICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZVxuICB9XG59KTtcbnZhciBjcmVhdGVRdWV1ZVdpdGhUaW1lciA9ICh0aW1lb3V0KSA9PiB7XG4gIHJldHVybiAobm90aWZ5KSA9PiB7XG4gICAgc2V0VGltZW91dChub3RpZnksIHRpbWVvdXQpO1xuICB9O1xufTtcbnZhciByQUYgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogY3JlYXRlUXVldWVXaXRoVGltZXIoMTApO1xudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gKG9wdGlvbnMgPSB7XG4gIHR5cGU6IFwicmFmXCJcbn0pID0+IChuZXh0KSA9PiAoLi4uYXJncykgPT4ge1xuICBjb25zdCBzdG9yZSA9IG5leHQoLi4uYXJncyk7XG4gIGxldCBub3RpZnlpbmcgPSB0cnVlO1xuICBsZXQgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgbGV0IG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSBcInRpY2tcIiA/IHF1ZXVlTWljcm90YXNrIDogb3B0aW9ucy50eXBlID09PSBcInJhZlwiID8gckFGIDogb3B0aW9ucy50eXBlID09PSBcImNhbGxiYWNrXCIgPyBvcHRpb25zLnF1ZXVlTm90aWZpY2F0aW9uIDogY3JlYXRlUXVldWVXaXRoVGltZXIob3B0aW9ucy50aW1lb3V0KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xuICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiBsKCkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0b3JlLCB7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGJhc2UgYHN0b3JlLnN1YnNjcmliZWAgbWV0aG9kIHRvIGtlZXAgb3JpZ2luYWwgbGlzdGVuZXJzXG4gICAgLy8gZnJvbSBydW5uaW5nIGlmIHdlJ3JlIGRlbGF5aW5nIG5vdGlmaWNhdGlvbnNcbiAgICBzdWJzY3JpYmUobGlzdGVuZXIyKSB7XG4gICAgICBjb25zdCB3cmFwcGVkTGlzdGVuZXIgPSAoKSA9PiBub3RpZnlpbmcgJiYgbGlzdGVuZXIyKCk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSh3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcjIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5kaXNwYXRjaGAgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGFjdGlvbnNcbiAgICAvLyBmb3IgdGhlIGBzaG91bGRBdXRvQmF0Y2hgIGZsYWcgYW5kIGRldGVybWluZSBpZiBiYXRjaGluZyBpcyBhY3RpdmVcbiAgICBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vdGlmeWluZyA9ICFhY3Rpb24/Lm1ldGE/LltTSE9VTERfQVVUT0JBVENIXTtcbiAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSAhbm90aWZ5aW5nO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvblF1ZXVlZCkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlQ2FsbGJhY2sobm90aWZ5TGlzdGVuZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdEVuaGFuY2Vycy50c1xudmFyIGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyA9IChtaWRkbGV3YXJlRW5oYW5jZXIpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRFbmhhbmNlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYXV0b0JhdGNoID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IGVuaGFuY2VyQXJyYXkgPSBuZXcgVHVwbGUobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKGF1dG9CYXRjaCkge1xuICAgIGVuaGFuY2VyQXJyYXkucHVzaChhdXRvQmF0Y2hFbmhhbmNlcih0eXBlb2YgYXV0b0JhdGNoID09PSBcIm9iamVjdFwiID8gYXV0b0JhdGNoIDogdm9pZCAwKSk7XG4gIH1cbiAgcmV0dXJuIGVuaGFuY2VyQXJyYXk7XG59O1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbnZhciBJU19QUk9EVUNUSU9OID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xuZnVuY3Rpb24gY29uZmlndXJlU3RvcmUob3B0aW9ucykge1xuICBjb25zdCBnZXREZWZhdWx0TWlkZGxld2FyZSA9IGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUoKTtcbiAgY29uc3Qge1xuICAgIHJlZHVjZXIgPSB2b2lkIDAsXG4gICAgbWlkZGxld2FyZSxcbiAgICBkZXZUb29scyA9IHRydWUsXG4gICAgcHJlbG9hZGVkU3RhdGUgPSB2b2lkIDAsXG4gICAgZW5oYW5jZXJzID0gdm9pZCAwXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgcm9vdFJlZHVjZXI7XG4gIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QyKHJlZHVjZXIpKSB7XG4gICAgcm9vdFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMocmVkdWNlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBcImByZWR1Y2VyYCBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2Vyc1wiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgbWlkZGxld2FyZSAmJiB0eXBlb2YgbWlkZGxld2FyZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMikgOiBcImBtaWRkbGV3YXJlYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IGZpbmFsTWlkZGxld2FyZTtcbiAgaWYgKHR5cGVvZiBtaWRkbGV3YXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlKGdldERlZmF1bHRNaWRkbGV3YXJlKTtcbiAgICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgIUFycmF5LmlzQXJyYXkoZmluYWxNaWRkbGV3YXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMykgOiBcIndoZW4gdXNpbmcgYSBtaWRkbGV3YXJlIGJ1aWxkZXIgZnVuY3Rpb24sIGFuIGFycmF5IG9mIG1pZGRsZXdhcmUgbXVzdCBiZSByZXR1cm5lZFwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gZ2V0RGVmYXVsdE1pZGRsZXdhcmUoKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZmluYWxNaWRkbGV3YXJlLnNvbWUoKGl0ZW0pID0+IHR5cGVvZiBpdGVtICE9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNCkgOiBcImVhY2ggbWlkZGxld2FyZSBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgbGV0IGZpbmFsQ29tcG9zZSA9IGNvbXBvc2UyO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKHtcbiAgICAgIC8vIEVuYWJsZSBjYXB0dXJlIG9mIHN0YWNrIHRyYWNlcyBmb3IgZGlzcGF0Y2hlZCBSZWR1eCBhY3Rpb25zXG4gICAgICB0cmFjZTogIUlTX1BST0RVQ1RJT04sXG4gICAgICAuLi50eXBlb2YgZGV2VG9vbHMgPT09IFwib2JqZWN0XCIgJiYgZGV2VG9vbHNcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtaWRkbGV3YXJlRW5oYW5jZXIgPSBhcHBseU1pZGRsZXdhcmUoLi4uZmluYWxNaWRkbGV3YXJlKTtcbiAgY29uc3QgZ2V0RGVmYXVsdEVuaGFuY2VycyA9IGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyhtaWRkbGV3YXJlRW5oYW5jZXIpO1xuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZW5oYW5jZXJzICYmIHR5cGVvZiBlbmhhbmNlcnMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUpIDogXCJgZW5oYW5jZXJzYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IHN0b3JlRW5oYW5jZXJzID0gdHlwZW9mIGVuaGFuY2VycyA9PT0gXCJmdW5jdGlvblwiID8gZW5oYW5jZXJzKGdldERlZmF1bHRFbmhhbmNlcnMpIDogZ2V0RGVmYXVsdEVuaGFuY2VycygpO1xuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgIUFycmF5LmlzQXJyYXkoc3RvcmVFbmhhbmNlcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiBcImBlbmhhbmNlcnNgIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5XCIpO1xuICB9XG4gIGlmICghSVNfUFJPRFVDVElPTiAmJiBzdG9yZUVuaGFuY2Vycy5zb21lKChpdGVtKSA9PiB0eXBlb2YgaXRlbSAhPT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDcpIDogXCJlYWNoIGVuaGFuY2VyIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZmluYWxNaWRkbGV3YXJlLmxlbmd0aCAmJiAhc3RvcmVFbmhhbmNlcnMuaW5jbHVkZXMobWlkZGxld2FyZUVuaGFuY2VyKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJtaWRkbGV3YXJlcyB3ZXJlIHByb3ZpZGVkLCBidXQgbWlkZGxld2FyZSBlbmhhbmNlciB3YXMgbm90IGluY2x1ZGVkIGluIGZpbmFsIGVuaGFuY2VycyAtIG1ha2Ugc3VyZSB0byBjYWxsIGBnZXREZWZhdWx0RW5oYW5jZXJzYFwiKTtcbiAgfVxuICBjb25zdCBjb21wb3NlZEVuaGFuY2VyID0gZmluYWxDb21wb3NlKC4uLnN0b3JlRW5oYW5jZXJzKTtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKHJvb3RSZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgY29tcG9zZWRFbmhhbmNlcik7XG59XG5cbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZTIsIGlzRHJhZnQgYXMgaXNEcmFmdDIsIGlzRHJhZnRhYmxlIGFzIGlzRHJhZnRhYmxlMiB9IGZyb20gXCJpbW1lclwiO1xuXG4vLyBzcmMvbWFwQnVpbGRlcnMudHNcbmZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXJDYWxsYmFjaykge1xuICBjb25zdCBhY3Rpb25zTWFwID0ge307XG4gIGNvbnN0IGFjdGlvbk1hdGNoZXJzID0gW107XG4gIGxldCBkZWZhdWx0Q2FzZVJlZHVjZXI7XG4gIGNvbnN0IGJ1aWxkZXIgPSB7XG4gICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjYpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkTWF0Y2hlcmBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI3KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBcInN0cmluZ1wiID8gdHlwZU9yQWN0aW9uQ3JlYXRvciA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOCkgOiBcImBidWlsZGVyLmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhY3Rpb24gdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlIGluIGFjdGlvbnNNYXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjkpIDogYFxcYGJ1aWxkZXIuYWRkQ2FzZVxcYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZSAnJHt0eXBlfSdgKTtcbiAgICAgIH1cbiAgICAgIGFjdGlvbnNNYXBbdHlwZV0gPSByZWR1Y2VyO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGRNYXRjaGVyKG1hdGNoZXIsIHJlZHVjZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwKSA6IFwiYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aW9uTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgIG1hdGNoZXIsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGREZWZhdWx0Q2FzZShyZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMSkgOiBcImBidWlsZGVyLmFkZERlZmF1bHRDYXNlYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdENhc2VSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgfTtcbiAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpO1xuICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuZnVuY3Rpb24gaXNTdGF0ZUZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2YgbWFwT3JCdWlsZGVyQ2FsbGJhY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlUmVkdWNlcmAgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVJlZHVjZXJcIik7XG4gICAgfVxuICB9XG4gIGxldCBbYWN0aW9uc01hcCwgZmluYWxBY3Rpb25NYXRjaGVycywgZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdID0gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spO1xuICBsZXQgZ2V0SW5pdGlhbFN0YXRlO1xuICBpZiAoaXNTdGF0ZUZ1bmN0aW9uKGluaXRpYWxTdGF0ZSkpIHtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKCkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZyb3plbkluaXRpYWxTdGF0ZSA9IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUpO1xuICAgIGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGZyb3plbkluaXRpYWxTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCksIGFjdGlvbikge1xuICAgIGxldCBjYXNlUmVkdWNlcnMgPSBbYWN0aW9uc01hcFthY3Rpb24udHlwZV0sIC4uLmZpbmFsQWN0aW9uTWF0Y2hlcnMuZmlsdGVyKCh7XG4gICAgICBtYXRjaGVyXG4gICAgfSkgPT4gbWF0Y2hlcihhY3Rpb24pKS5tYXAoKHtcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXIyXG4gICAgfSkgPT4gcmVkdWNlcjIpXTtcbiAgICBpZiAoY2FzZVJlZHVjZXJzLmZpbHRlcigoY3IpID0+ICEhY3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FzZVJlZHVjZXJzID0gW2ZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXTtcbiAgICB9XG4gICAgcmV0dXJuIGNhc2VSZWR1Y2Vycy5yZWR1Y2UoKHByZXZpb3VzU3RhdGUsIGNhc2VSZWR1Y2VyKSA9PiB7XG4gICAgICBpZiAoY2FzZVJlZHVjZXIpIHtcbiAgICAgICAgaWYgKGlzRHJhZnQyKHByZXZpb3VzU3RhdGUpKSB7XG4gICAgICAgICAgY29uc3QgZHJhZnQgPSBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRHJhZnRhYmxlMihwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKHByZXZpb3VzU3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkpIDogXCJBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMihwcmV2aW91c1N0YXRlLCAoZHJhZnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgfSwgc3RhdGUpO1xuICB9XG4gIHJlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlO1xuICByZXR1cm4gcmVkdWNlcjtcbn1cblxuLy8gc3JjL25hbm9pZC50c1xudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XG52YXIgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSBcIlwiO1xuICBsZXQgaSA9IHNpemU7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG4vLyBzcmMvbWF0Y2hlcnMudHNcbnZhciBtYXRjaGVzID0gKG1hdGNoZXIsIGFjdGlvbikgPT4ge1xuICBpZiAoaGFzTWF0Y2hGdW5jdGlvbihtYXRjaGVyKSkge1xuICAgIHJldHVybiBtYXRjaGVyLm1hdGNoKGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzQW55T2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobWF0Y2hlcikgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWxsT2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuZXZlcnkoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XG4gIGlmICghYWN0aW9uIHx8ICFhY3Rpb24ubWV0YSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzID0gdmFsaWRTdGF0dXMuaW5kZXhPZihhY3Rpb24ubWV0YS5yZXF1ZXN0U3RhdHVzKSA+IC0xO1xuICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQXJyYXkoYSkge1xuICByZXR1cm4gdHlwZW9mIGFbMF0gPT09IFwiZnVuY3Rpb25cIiAmJiBcInBlbmRpbmdcIiBpbiBhWzBdICYmIFwiZnVsZmlsbGVkXCIgaW4gYVswXSAmJiBcInJlamVjdGVkXCIgaW4gYVswXTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZyguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucGVuZGluZyk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZCguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5yZWplY3RlZCk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZFdpdGhWYWx1ZSguLi5hc3luY1RodW5rcykge1xuICBjb25zdCBoYXNGbGFnID0gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XG4gIH07XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XG4gICAgfTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkV2l0aFZhbHVlKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcImZ1bGZpbGxlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5mdWxmaWxsZWQpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbiguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc0FzeW5jVGh1bmtBY3Rpb24oKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXN5bmNUaHVuayBvZiBhc3luY1RodW5rcykge1xuICAgICAgbWF0Y2hlcnMucHVzaChhc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcbiAgICB9XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuXG4vLyBzcmMvY3JlYXRlQXN5bmNUaHVuay50c1xudmFyIGNvbW1vblByb3BlcnRpZXMgPSBbXCJuYW1lXCIsIFwibWVzc2FnZVwiLCBcInN0YWNrXCIsIFwiY29kZVwiXTtcbnZhciBSZWplY3RXaXRoVmFsdWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBheWxvYWQsIG1ldGEpIHtcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgLypcbiAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxuICAqL1xuICBfdHlwZTtcbn07XG52YXIgRnVsZmlsbFdpdGhNZXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIG1pbmlTZXJpYWxpemVFcnJvciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2ltcGxlRXJyb3IgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNpbXBsZUVycm9yW3Byb3BlcnR5XSA9IHZhbHVlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsZUVycm9yO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogU3RyaW5nKHZhbHVlKVxuICB9O1xufTtcbnZhciBjcmVhdGVBc3luY1RodW5rID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jVGh1bmsyKHR5cGVQcmVmaXgsIHBheWxvYWRDcmVhdG9yLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4ubWV0YSB8fCB7fSxcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcGVuZGluZyA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcGVuZGluZ1wiLCAocmVxdWVzdElkLCBhcmcsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkOiB2b2lkIDAsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInBlbmRpbmdcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCByZWplY3RlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcmVqZWN0ZWRcIiwgKGVycm9yLCByZXF1ZXN0SWQsIGFyZywgcGF5bG9hZCwgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWplY3RlZFdpdGhWYWx1ZTogISFwYXlsb2FkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInJlamVjdGVkXCIsXG4gICAgICAgIGFib3J0ZWQ6IGVycm9yPy5uYW1lID09PSBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgY29uZGl0aW9uOiBlcnJvcj8ubmFtZSA9PT0gXCJDb25kaXRpb25FcnJvclwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoYXJnKSB7XG4gICAgICByZXR1cm4gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucz8uaWRHZW5lcmF0b3IgPyBvcHRpb25zLmlkR2VuZXJhdG9yKGFyZykgOiBuYW5vaWQoKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBsZXQgYWJvcnRIYW5kbGVyO1xuICAgICAgICBsZXQgYWJvcnRSZWFzb247XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgIGFib3J0UmVhc29uID0gcmVhc29uO1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgZmluYWxBY3Rpb247XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb25SZXN1bHQgPSBvcHRpb25zPy5jb25kaXRpb24/LihhcmcsIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gYXdhaXQgY29uZGl0aW9uUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCA9PT0gZmFsc2UgfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIG9wdGlvbnM/LmdldFBlbmRpbmdNZXRhPy4oe1xuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRlZFByb21pc2UsIFByb21pc2UucmVzb2x2ZShwYXlsb2FkQ3JlYXRvcihhcmcsIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogKHZhbHVlLCBtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LnBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCByZXN1bHQubWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQsIHJlcXVlc3RJZCwgYXJnKTtcbiAgICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVyciBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSA/IHJlamVjdGVkKG51bGwsIHJlcXVlc3RJZCwgYXJnLCBlcnIucGF5bG9hZCwgZXJyLm1ldGEpIDogcmVqZWN0ZWQoZXJyLCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChhYm9ydEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2tpcERpc3BhdGNoID0gb3B0aW9ucyAmJiAhb3B0aW9ucy5kaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiAmJiByZWplY3RlZC5tYXRjaChmaW5hbEFjdGlvbikgJiYgZmluYWxBY3Rpb24ubWV0YS5jb25kaXRpb247XG4gICAgICAgICAgaWYgKCFza2lwRGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbmFsQWN0aW9uO1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UsIHtcbiAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHVud3JhcCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4odW53cmFwUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWN0aW9uQ3JlYXRvciwge1xuICAgICAgcGVuZGluZyxcbiAgICAgIHJlamVjdGVkLFxuICAgICAgZnVsZmlsbGVkLFxuICAgICAgc2V0dGxlZDogaXNBbnlPZihyZWplY3RlZCwgZnVsZmlsbGVkKSxcbiAgICAgIHR5cGVQcmVmaXhcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBc3luY1RodW5rMi53aXRoVHlwZXMgPSAoKSA9PiBjcmVhdGVBc3luY1RodW5rMjtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyO1xufSkoKTtcbmZ1bmN0aW9uIHVud3JhcFJlc3VsdChhY3Rpb24pIHtcbiAgaWYgKGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlKSB7XG4gICAgdGhyb3cgYWN0aW9uLnBheWxvYWQ7XG4gIH1cbiAgaWYgKGFjdGlvbi5lcnJvcikge1xuICAgIHRocm93IGFjdGlvbi5lcnJvcjtcbiAgfVxuICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XG59XG5mdW5jdGlvbiBpc1RoZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gc3JjL2NyZWF0ZVNsaWNlLnRzXG52YXIgYXN5bmNUaHVua1N5bWJvbCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicnRrLXNsaWNlLWNyZWF0ZWFzeW5jdGh1bmtcIik7XG52YXIgYXN5bmNUaHVua0NyZWF0b3IgPSB7XG4gIFthc3luY1RodW5rU3ltYm9sXTogY3JlYXRlQXN5bmNUaHVua1xufTtcbnZhciBSZWR1Y2VyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlZHVjZXJUeXBlMikgPT4ge1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyXCJdID0gXCJyZWR1Y2VyXCI7XG4gIFJlZHVjZXJUeXBlMltcInJlZHVjZXJXaXRoUHJlcGFyZVwiXSA9IFwicmVkdWNlcldpdGhQcmVwYXJlXCI7XG4gIFJlZHVjZXJUeXBlMltcImFzeW5jVGh1bmtcIl0gPSBcImFzeW5jVGh1bmtcIjtcbiAgcmV0dXJuIFJlZHVjZXJUeXBlMjtcbn0pKFJlZHVjZXJUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGdldFR5cGUoc2xpY2UsIGFjdGlvbktleSkge1xuICByZXR1cm4gYCR7c2xpY2V9LyR7YWN0aW9uS2V5fWA7XG59XG5mdW5jdGlvbiBidWlsZENyZWF0ZVNsaWNlKHtcbiAgY3JlYXRvcnNcbn0gPSB7fSkge1xuICBjb25zdCBjQVQgPSBjcmVhdG9ycz8uYXN5bmNUaHVuaz8uW2FzeW5jVGh1bmtTeW1ib2xdO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU2xpY2UyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlclBhdGggPSBuYW1lXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBcImBuYW1lYCBpcyBhIHJlcXVpcmVkIG9wdGlvbiBmb3IgY3JlYXRlU2xpY2VcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhbiBgaW5pdGlhbFN0YXRlYCB2YWx1ZSB0aGF0IGlzIG5vdCBgdW5kZWZpbmVkYC4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYGluaXRpYWxTdGF0ZWBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZHVjZXJzID0gKHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLnJlZHVjZXJzKGJ1aWxkUmVkdWNlckNyZWF0b3JzKCkpIDogb3B0aW9ucy5yZWR1Y2VycykgfHwge307XG4gICAgY29uc3QgcmVkdWNlck5hbWVzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZToge30sXG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZToge30sXG4gICAgICBhY3Rpb25DcmVhdG9yczoge30sXG4gICAgICBzbGljZU1hdGNoZXJzOiBbXVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dE1ldGhvZHMgPSB7XG4gICAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IFwiYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMykgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSByZWR1Y2VyMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGFkZE1hdGNoZXIobWF0Y2hlciwgcmVkdWNlcjIpIHtcbiAgICAgICAgY29udGV4dC5zbGljZU1hdGNoZXJzLnB1c2goe1xuICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgcmVkdWNlcjogcmVkdWNlcjJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBleHBvc2VBY3Rpb24obmFtZTIsIGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgY29udGV4dC5hY3Rpb25DcmVhdG9yc1tuYW1lMl0gPSBhY3Rpb25DcmVhdG9yO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQ2FzZVJlZHVjZXIobmFtZTIsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbbmFtZTJdID0gcmVkdWNlcjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlZHVjZXJOYW1lcy5mb3JFYWNoKChyZWR1Y2VyTmFtZSkgPT4ge1xuICAgICAgY29uc3QgcmVkdWNlckRlZmluaXRpb24gPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV07XG4gICAgICBjb25zdCByZWR1Y2VyRGV0YWlscyA9IHtcbiAgICAgICAgcmVkdWNlck5hbWUsXG4gICAgICAgIHR5cGU6IGdldFR5cGUobmFtZSwgcmVkdWNlck5hbWUpLFxuICAgICAgICBjcmVhdGVOb3RhdGlvbjogdHlwZW9mIG9wdGlvbnMucmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgfTtcbiAgICAgIGlmIChpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSkge1xuICAgICAgICBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGV0YWlscywgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHRNZXRob2RzLCBjQVQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VyKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXh0cmFSZWR1Y2VycyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE0KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVNsaWNlLmV4dHJhUmVkdWNlcnNgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVTbGljZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgW2V4dHJhUmVkdWNlcnMgPSB7fSwgYWN0aW9uTWF0Y2hlcnMgPSBbXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gdm9pZCAwXSA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG9wdGlvbnMuZXh0cmFSZWR1Y2VycykgOiBbb3B0aW9ucy5leHRyYVJlZHVjZXJzXTtcbiAgICAgIGNvbnN0IGZpbmFsQ2FzZVJlZHVjZXJzID0ge1xuICAgICAgICAuLi5leHRyYVJlZHVjZXJzLFxuICAgICAgICAuLi5jb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlZHVjZXIob3B0aW9ucy5pbml0aWFsU3RhdGUsIChidWlsZGVyKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBmaW5hbENhc2VSZWR1Y2Vycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShrZXksIGZpbmFsQ2FzZVJlZHVjZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNNIG9mIGNvbnRleHQuc2xpY2VNYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihzTS5tYXRjaGVyLCBzTS5yZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBtIG9mIGFjdGlvbk1hdGNoZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKG0ubWF0Y2hlciwgbS5yZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGREZWZhdWx0Q2FzZShkZWZhdWx0Q2FzZVJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0U2VsZiA9IChzdGF0ZSkgPT4gc3RhdGU7XG4gICAgY29uc3QgaW5qZWN0ZWRTZWxlY3RvckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgX3JlZHVjZXI7XG4gICAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKVxuICAgICAgICBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKVxuICAgICAgICBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aDIsIGluamVjdGVkID0gZmFsc2UpIHtcbiAgICAgIGZ1bmN0aW9uIHNlbGVjdFNsaWNlKHN0YXRlKSB7XG4gICAgICAgIGxldCBzbGljZVN0YXRlID0gc3RhdGVbcmVkdWNlclBhdGgyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzbGljZVN0YXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgICAgICBzbGljZVN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE1KSA6IFwic2VsZWN0U2xpY2UgcmV0dXJuZWQgdW5kZWZpbmVkIGZvciBhbiB1bmluamVjdGVkIHNsaWNlIHJlZHVjZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbGljZVN0YXRlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlID0gc2VsZWN0U2VsZikge1xuICAgICAgICBjb25zdCBzZWxlY3RvckNhY2hlID0gZW1wbGFjZShpbmplY3RlZFNlbGVjdG9yQ2FjaGUsIGluamVjdGVkLCB7XG4gICAgICAgICAgaW5zZXJ0OiAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVtcGxhY2Uoc2VsZWN0b3JDYWNoZSwgc2VsZWN0U3RhdGUsIHtcbiAgICAgICAgICBpbnNlcnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZTIsIHNlbGVjdG9yXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnNlbGVjdG9ycyA/PyB7fSkpIHtcbiAgICAgICAgICAgICAgbWFwW25hbWUyXSA9IHdyYXBTZWxlY3RvcihzZWxlY3Rvciwgc2VsZWN0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSwgaW5qZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoMixcbiAgICAgICAgZ2V0U2VsZWN0b3JzLFxuICAgICAgICBnZXQgc2VsZWN0b3JzKCkge1xuICAgICAgICAgIHJldHVybiBnZXRTZWxlY3RvcnMoc2VsZWN0U2xpY2UpO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RTbGljZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2UgPSB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlcixcbiAgICAgIGFjdGlvbnM6IGNvbnRleHQuYWN0aW9uQ3JlYXRvcnMsXG4gICAgICBjYXNlUmVkdWNlcnM6IGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUsXG4gICAgICBnZXRJbml0aWFsU3RhdGUsXG4gICAgICAuLi5tYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aCksXG4gICAgICBpbmplY3RJbnRvKGluamVjdGFibGUsIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHBhdGhPcHQsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5ld1JlZHVjZXJQYXRoID0gcGF0aE9wdCA/PyByZWR1Y2VyUGF0aDtcbiAgICAgICAgaW5qZWN0YWJsZS5pbmplY3Qoe1xuICAgICAgICAgIHJlZHVjZXJQYXRoOiBuZXdSZWR1Y2VyUGF0aCxcbiAgICAgICAgICByZWR1Y2VyXG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2xpY2UsXG4gICAgICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMobmV3UmVkdWNlclBhdGgsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc2xpY2U7XG4gIH07XG59XG5mdW5jdGlvbiB3cmFwU2VsZWN0b3Ioc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCBnZXRJbml0aWFsU3RhdGUsIGluamVjdGVkKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIocm9vdFN0YXRlLCAuLi5hcmdzKSB7XG4gICAgbGV0IHNsaWNlU3RhdGUgPSBzZWxlY3RTdGF0ZShyb290U3RhdGUpO1xuICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHNsaWNlU3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IFwic2VsZWN0U3RhdGUgcmV0dXJuZWQgdW5kZWZpbmVkIGZvciBhbiB1bmluamVjdGVkIHNsaWNlIHJlZHVjZXJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcihzbGljZVN0YXRlLCAuLi5hcmdzKTtcbiAgfVxuICB3cmFwcGVyLnVud3JhcHBlZCA9IHNlbGVjdG9yO1xuICByZXR1cm4gd3JhcHBlcjtcbn1cbnZhciBjcmVhdGVTbGljZSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZENyZWF0ZVNsaWNlKCk7XG5mdW5jdGlvbiBidWlsZFJlZHVjZXJDcmVhdG9ycygpIHtcbiAgZnVuY3Rpb24gYXN5bmNUaHVuayhwYXlsb2FkQ3JlYXRvciwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi8sXG4gICAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cbiAgYXN5bmNUaHVuay53aXRoVHlwZXMgPSAoKSA9PiBhc3luY1RodW5rO1xuICByZXR1cm4ge1xuICAgIHJlZHVjZXIoY2FzZVJlZHVjZXIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgLy8gaGFjayBzbyB0aGUgd3JhcHBpbmcgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgd3JhcHBlciBzbyB0aGUgYHJlZHVjZXJEZWZpbml0aW9uVHlwZWAgaXMgbm90IGFzc2lnbmVkIHRvIHRoZSBvcmlnaW5hbFxuICAgICAgICBbY2FzZVJlZHVjZXIubmFtZV0oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVtjYXNlUmVkdWNlci5uYW1lXSwge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJcIiAvKiByZWR1Y2VyICovXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHByZXBhcmVkUmVkdWNlcihwcmVwYXJlLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLyxcbiAgICAgICAgcHJlcGFyZSxcbiAgICAgICAgcmVkdWNlclxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jVGh1bmtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWUsXG4gIGNyZWF0ZU5vdGF0aW9uXG59LCBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSwgY29udGV4dCkge1xuICBsZXQgY2FzZVJlZHVjZXI7XG4gIGxldCBwcmVwYXJlQ2FsbGJhY2s7XG4gIGlmIChcInJlZHVjZXJcIiBpbiBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkge1xuICAgIGlmIChjcmVhdGVOb3RhdGlvbiAmJiAhaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE3KSA6IFwiUGxlYXNlIHVzZSB0aGUgYGNyZWF0ZS5wcmVwYXJlZFJlZHVjZXJgIG5vdGF0aW9uIGZvciBwcmVwYXJlZCBhY3Rpb24gY3JlYXRvcnMgd2l0aCB0aGUgYGNyZWF0ZWAgbm90YXRpb24uXCIpO1xuICAgIH1cbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnJlZHVjZXI7XG4gICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcbiAgfSBlbHNlIHtcbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlO1xuICB9XG4gIGNvbnRleHQuYWRkQ2FzZSh0eXBlLCBjYXNlUmVkdWNlcikuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIGNhc2VSZWR1Y2VyKS5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHByZXBhcmVDYWxsYmFjayA/IGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQ2FsbGJhY2spIDogY3JlYXRlQWN0aW9uKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi87XG59XG5mdW5jdGlvbiBpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLztcbn1cbmZ1bmN0aW9uIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWVcbn0sIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0LCBjQVQpIHtcbiAgaWYgKCFjQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxOCkgOiBcIkNhbm5vdCB1c2UgYGNyZWF0ZS5hc3luY1RodW5rYCBpbiB0aGUgYnVpbHQtaW4gYGNyZWF0ZVNsaWNlYC4gVXNlIGBidWlsZENyZWF0ZVNsaWNlKHsgY3JlYXRvcnM6IHsgYXN5bmNUaHVuazogYXN5bmNUaHVua0NyZWF0b3IgfSB9KWAgdG8gY3JlYXRlIGEgY3VzdG9taXNlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTbGljZWAuXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICBmdWxmaWxsZWQsXG4gICAgcGVuZGluZyxcbiAgICByZWplY3RlZCxcbiAgICBzZXR0bGVkLFxuICAgIG9wdGlvbnNcbiAgfSA9IHJlZHVjZXJEZWZpbml0aW9uO1xuICBjb25zdCB0aHVuayA9IGNBVCh0eXBlLCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucyk7XG4gIGNvbnRleHQuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCB0aHVuayk7XG4gIGlmIChmdWxmaWxsZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsuZnVsZmlsbGVkLCBmdWxmaWxsZWQpO1xuICB9XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xuICB9XG4gIGlmIChyZWplY3RlZCkge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5yZWplY3RlZCwgcmVqZWN0ZWQpO1xuICB9XG4gIGlmIChzZXR0bGVkKSB7XG4gICAgY29udGV4dC5hZGRNYXRjaGVyKHRodW5rLnNldHRsZWQsIHNldHRsZWQpO1xuICB9XG4gIGNvbnRleHQuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxuICAgIHBlbmRpbmc6IHBlbmRpbmcgfHwgbm9vcCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQgfHwgbm9vcCxcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcbiAgfSk7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vLyBzcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzXG5mdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgaWRzOiBbXSxcbiAgICBlbnRpdGllczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKSB7XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShhZGRpdGlvbmFsU3RhdGUgPSB7fSwgZW50aXRpZXMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSk7XG4gICAgcmV0dXJuIGVudGl0aWVzID8gc3RhdGVBZGFwdGVyLnNldEFsbChzdGF0ZSwgZW50aXRpZXMpIDogc3RhdGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRJbml0aWFsU3RhdGVcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX3NlbGVjdG9ycy50c1xuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpIHtcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzZWxlY3RJZHMgPSAoc3RhdGUpID0+IHN0YXRlLmlkcztcbiAgICBjb25zdCBzZWxlY3RFbnRpdGllcyA9IChzdGF0ZSkgPT4gc3RhdGUuZW50aXRpZXM7XG4gICAgY29uc3Qgc2VsZWN0QWxsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgc2VsZWN0RW50aXRpZXMsIChpZHMsIGVudGl0aWVzKSA9PiBpZHMubWFwKChpZCkgPT4gZW50aXRpZXNbaWRdKSk7XG4gICAgY29uc3Qgc2VsZWN0SWQgPSAoXywgaWQpID0+IGlkO1xuICAgIGNvbnN0IHNlbGVjdEJ5SWQgPSAoZW50aXRpZXMsIGlkKSA9PiBlbnRpdGllc1tpZF07XG4gICAgY29uc3Qgc2VsZWN0VG90YWwgPSBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0SWRzLCAoaWRzKSA9PiBpZHMubGVuZ3RoKTtcbiAgICBpZiAoIXNlbGVjdFN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RJZHMsXG4gICAgICAgIHNlbGVjdEVudGl0aWVzLFxuICAgICAgICBzZWxlY3RBbGwsXG4gICAgICAgIHNlbGVjdFRvdGFsLFxuICAgICAgICBzZWxlY3RCeUlkOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0RW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RFbnRpdGllcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdElkczogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RJZHMpLFxuICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcbiAgICAgIHNlbGVjdEFsbDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RBbGwpLFxuICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0VG90YWwpLFxuICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFNlbGVjdG9yc1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfYWRhcHRlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUzLCBpc0RyYWZ0IGFzIGlzRHJhZnQzIH0gZnJvbSBcImltbWVyXCI7XG52YXIgaXNEcmFmdFR5cGVkID0gaXNEcmFmdDM7XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xuICBjb25zdCBvcGVyYXRvciA9IGNyZWF0ZVN0YXRlT3BlcmF0b3IoKF8sIHN0YXRlKSA9PiBtdXRhdG9yKHN0YXRlKSk7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUsIHZvaWQgMCk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSwgYXJnKSB7XG4gICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xuICAgICAgcmV0dXJuIGlzRlNBKGFyZzIpO1xuICAgIH1cbiAgICBjb25zdCBydW5NdXRhdG9yID0gKGRyYWZ0KSA9PiB7XG4gICAgICBpZiAoaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnKSkge1xuICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzRHJhZnRUeXBlZChzdGF0ZSkpIHtcbiAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMyhzdGF0ZSwgcnVuTXV0YXRvcik7XG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91dGlscy50c1xuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XG4gIGNvbnN0IGtleSA9IHNlbGVjdElkKGVudGl0eSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2V5ID09PSB2b2lkIDApIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuXCIsIFwiWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uXCIsIFwiVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6XCIsIGVudGl0eSwgXCJUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjpcIiwgc2VsZWN0SWQudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xuICAgIGVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhlbnRpdGllcyk7XG4gIH1cbiAgcmV0dXJuIGVudGl0aWVzO1xufVxuZnVuY3Rpb24gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSB7XG4gIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gIGNvbnN0IGFkZGVkID0gW107XG4gIGNvbnN0IHVwZGF0ZWQgPSBbXTtcbiAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICBjb25zdCBpZCA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKGlkIGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICB1cGRhdGVkLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgY2hhbmdlczogZW50aXR5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkZWQucHVzaChlbnRpdHkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2FkZGVkLCB1cGRhdGVkXTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKSB7XG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgY29uc3Qga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoIShrZXkgaW4gc3RhdGUuZW50aXRpZXMpKSB7XG4gICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xuICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU1hbnlNdXRhYmx5KGtleXMsIHN0YXRlKSB7XG4gICAgbGV0IGRpZE11dGF0ZSA9IGZhbHNlO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1trZXldO1xuICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkaWRNdXRhdGUpIHtcbiAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5maWx0ZXIoKGlkKSA9PiBpZCBpbiBzdGF0ZS5lbnRpdGllcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XG4gICAgICBpZHM6IFtdLFxuICAgICAgZW50aXRpZXM6IHt9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XG4gICAgY29uc3Qgb3JpZ2luYWwzID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICBpZiAob3JpZ2luYWwzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsMywgdXBkYXRlLmNoYW5nZXMpO1xuICAgIGNvbnN0IG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xuICAgIGNvbnN0IGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xuICAgIGlmIChoYXNOZXdLZXkpIHtcbiAgICAgIGtleXNbdXBkYXRlLmlkXSA9IG5ld0tleTtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XG4gICAgcmV0dXJuIGhhc05ld0tleTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5ld0tleXMgPSB7fTtcbiAgICBjb25zdCB1cGRhdGVzUGVyRW50aXR5ID0ge307XG4gICAgdXBkYXRlcy5mb3JFYWNoKCh1cGRhdGUpID0+IHtcbiAgICAgIGlmICh1cGRhdGUuaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xuICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXG4gICAgICAgICAgLy8gU3ByZWFkcyBpZ25vcmUgZmFsc3kgdmFsdWVzLCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgdGhlcmUgaXNuJ3RcbiAgICAgICAgICAvLyBhbiBleGlzdGluZyB1cGRhdGUgYWxyZWFkeSBhdCB0aGlzIGtleVxuICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgIC4uLnVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA/IHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXS5jaGFuZ2VzIDogbnVsbCxcbiAgICAgICAgICAgIC4uLnVwZGF0ZS5jaGFuZ2VzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xuICAgIGNvbnN0IGRpZE11dGF0ZUVudGl0aWVzID0gdXBkYXRlcy5sZW5ndGggPiAwO1xuICAgIGlmIChkaWRNdXRhdGVFbnRpdGllcykge1xuICAgICAgY29uc3QgZGlkTXV0YXRlSWRzID0gdXBkYXRlcy5maWx0ZXIoKHVwZGF0ZSkgPT4gdGFrZU5ld0tleShuZXdLZXlzLCB1cGRhdGUsIHN0YXRlKSkubGVuZ3RoID4gMDtcbiAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcbiAgICAgICAgc3RhdGUuaWRzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcykubWFwKChlKSA9PiBzZWxlY3RJZFZhbHVlKGUsIHNlbGVjdElkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlQWxsOiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IocmVtb3ZlQWxsTXV0YWJseSksXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KSxcbiAgICByZW1vdmVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlT25lTXV0YWJseSksXG4gICAgcmVtb3ZlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3NvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIHNvcnQpIHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbFxuICB9ID0gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gYWRkTWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGNvbnN0IG1vZGVscyA9IG5ld0VudGl0aWVzLmZpbHRlcigobW9kZWwpID0+ICEoc2VsZWN0SWRWYWx1ZShtb2RlbCwgc2VsZWN0SWQpIGluIHN0YXRlLmVudGl0aWVzKSk7XG4gICAgaWYgKG1vZGVscy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1lcmdlKG1vZGVscywgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGlmIChuZXdFbnRpdGllcy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1lcmdlKG5ld0VudGl0aWVzLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcbiAgICBsZXQgYXBwbGllZFVwZGF0ZXMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgICAgY29uc3QgZW50aXR5ID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYXBwbGllZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgT2JqZWN0LmFzc2lnbihlbnRpdHksIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgIGNvbnN0IG5ld0lkID0gc2VsZWN0SWQoZW50aXR5KTtcbiAgICAgIGlmICh1cGRhdGUuaWQgIT09IG5ld0lkKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgICBzdGF0ZS5lbnRpdGllc1tuZXdJZF0gPSBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcHBsaWVkVXBkYXRlcykge1xuICAgICAgcmVzb3J0RW50aXRpZXMoc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWRdID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XG4gICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhcmVBcnJheXNFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoICYmIGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2UobW9kZWxzLCBzdGF0ZSkge1xuICAgIG1vZGVscy5mb3JFYWNoKChtb2RlbCkgPT4ge1xuICAgICAgO1xuICAgICAgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQobW9kZWwpXSA9IG1vZGVsO1xuICAgIH0pO1xuICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZXNvcnRFbnRpdGllcyhzdGF0ZSkge1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcyk7XG4gICAgYWxsRW50aXRpZXMuc29ydChzb3J0KTtcbiAgICBjb25zdCBuZXdTb3J0ZWRJZHMgPSBhbGxFbnRpdGllcy5tYXAoc2VsZWN0SWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkc1xuICAgIH0gPSBzdGF0ZTtcbiAgICBpZiAoIWFyZUFycmF5c0VxdWFsKGlkcywgbmV3U29ydGVkSWRzKSkge1xuICAgICAgc3RhdGUuaWRzID0gbmV3U29ydGVkSWRzO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbCxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9jcmVhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlclxuICB9ID0ge1xuICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXG4gICAgc2VsZWN0SWQ6IChpbnN0YW5jZSkgPT4gaW5zdGFuY2UuaWQsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBzdGF0ZUFkYXB0ZXIgPSBzb3J0Q29tcGFyZXIgPyBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIHNvcnRDb21wYXJlcikgOiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCk7XG4gIGNvbnN0IHN0YXRlRmFjdG9yeSA9IGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKTtcbiAgY29uc3Qgc2VsZWN0b3JzRmFjdG9yeSA9IGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RJZCxcbiAgICBzb3J0Q29tcGFyZXIsXG4gICAgLi4uc3RhdGVGYWN0b3J5LFxuICAgIC4uLnNlbGVjdG9yc0ZhY3RvcnksXG4gICAgLi4uc3RhdGVBZGFwdGVyXG4gIH07XG59XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMyB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2V4Y2VwdGlvbnMudHNcbnZhciB0YXNrID0gXCJ0YXNrXCI7XG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XG52YXIgY29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcbnZhciBjYW5jZWxsZWQgPSBcImNhbmNlbGxlZFwiO1xudmFyIHRhc2tDYW5jZWxsZWQgPSBgdGFzay0ke2NhbmNlbGxlZH1gO1xudmFyIHRhc2tDb21wbGV0ZWQgPSBgdGFzay0ke2NvbXBsZXRlZH1gO1xudmFyIGxpc3RlbmVyQ2FuY2VsbGVkID0gYCR7bGlzdGVuZXJ9LSR7Y2FuY2VsbGVkfWA7XG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBgJHtsaXN0ZW5lcn0tJHtjb21wbGV0ZWR9YDtcbnZhciBUYXNrQWJvcnRFcnJvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5tZXNzYWdlID0gYCR7dGFza30gJHtjYW5jZWxsZWR9IChyZWFzb246ICR7Y29kZX0pYDtcbiAgfVxuICBuYW1lID0gXCJUYXNrQWJvcnRFcnJvclwiO1xuICBtZXNzYWdlO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS91dGlscy50c1xudmFyIGFzc2VydEZ1bmN0aW9uID0gKGZ1bmMsIGV4cGVjdGVkKSA9PiB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzIpIDogYCR7ZXhwZWN0ZWR9IGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG4gIH1cbn07XG52YXIgbm9vcDIgPSAoKSA9PiB7XG59O1xudmFyIGNhdGNoUmVqZWN0aW9uID0gKHByb21pc2UsIG9uRXJyb3IgPSBub29wMikgPT4ge1xuICBwcm9taXNlLmNhdGNoKG9uRXJyb3IpO1xuICByZXR1cm4gcHJvbWlzZTtcbn07XG52YXIgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IChhYm9ydFNpZ25hbCwgY2FsbGJhY2spID0+IHtcbiAgYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbGxiYWNrLCB7XG4gICAgb25jZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuICgpID0+IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjayk7XG59O1xudmFyIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24gPSAoYWJvcnRDb250cm9sbGVyLCByZWFzb24pID0+IHtcbiAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogcmVhc29uLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICA7XG4gIGFib3J0Q29udHJvbGxlci5hYm9ydChyZWFzb24pO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS90YXNrLnRzXG52YXIgdmFsaWRhdGVBY3RpdmUgPSAoc2lnbmFsKSA9PiB7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlYXNvblxuICAgIH0gPSBzaWduYWw7XG4gICAgdGhyb3cgbmV3IFRhc2tBYm9ydEVycm9yKHJlYXNvbik7XG4gIH1cbn07XG5mdW5jdGlvbiByYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpIHtcbiAgbGV0IGNsZWFudXAgPSBub29wMjtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBub3RpZnlSZWplY3Rpb24gPSAoKSA9PiByZWplY3QobmV3IFRhc2tBYm9ydEVycm9yKHNpZ25hbC5yZWFzb24pKTtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIG5vdGlmeVJlamVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IGNsZWFudXAoKSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICBjbGVhbnVwID0gbm9vcDI7XG4gIH0pO1xufVxudmFyIHJ1blRhc2sgPSBhc3luYyAodGFzazIsIGNsZWFuVXApID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRhc2syKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IGVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIGNsZWFuVXA/LigpO1xuICB9XG59O1xudmFyIGNyZWF0ZVBhdXNlID0gKHNpZ25hbCkgPT4ge1xuICByZXR1cm4gKHByb21pc2UpID0+IHtcbiAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKS50aGVuKChvdXRwdXQpID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pKTtcbiAgfTtcbn07XG52YXIgY3JlYXRlRGVsYXkgPSAoc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHBhdXNlID0gY3JlYXRlUGF1c2Uoc2lnbmFsKTtcbiAgcmV0dXJuICh0aW1lb3V0TXMpID0+IHtcbiAgICByZXR1cm4gcGF1c2UobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1zKSkpO1xuICB9O1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xudmFyIHtcbiAgYXNzaWduXG59ID0gT2JqZWN0O1xudmFyIElOVEVSTkFMX05JTF9UT0tFTiA9IHt9O1xudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XG52YXIgY3JlYXRlRm9yayA9IChwYXJlbnRBYm9ydFNpZ25hbCwgcGFyZW50QmxvY2tpbmdQcm9taXNlcykgPT4ge1xuICBjb25zdCBsaW5rQ29udHJvbGxlcnMgPSAoY29udHJvbGxlcikgPT4gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihwYXJlbnRBYm9ydFNpZ25hbCwgKCkgPT4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBwYXJlbnRBYm9ydFNpZ25hbC5yZWFzb24pKTtcbiAgcmV0dXJuICh0YXNrRXhlY3V0b3IsIG9wdHMpID0+IHtcbiAgICBhc3NlcnRGdW5jdGlvbih0YXNrRXhlY3V0b3IsIFwidGFza0V4ZWN1dG9yXCIpO1xuICAgIGNvbnN0IGNoaWxkQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XG4gICAgY29uc3QgcmVzdWx0ID0gcnVuVGFzayhhc3luYyAoKSA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShwYXJlbnRBYm9ydFNpZ25hbCk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHRhc2tFeGVjdXRvcih7XG4gICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgc2lnbmFsOiBjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH0sICgpID0+IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDb21wbGV0ZWQpKTtcbiAgICBpZiAob3B0cz8uYXV0b0pvaW4pIHtcbiAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQuY2F0Y2gobm9vcDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogY3JlYXRlUGF1c2UocGFyZW50QWJvcnRTaWduYWwpKHJlc3VsdCksXG4gICAgICBjYW5jZWwoKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xudmFyIGNyZWF0ZVRha2VQYXR0ZXJuID0gKHN0YXJ0TGlzdGVuaW5nLCBzaWduYWwpID0+IHtcbiAgY29uc3QgdGFrZSA9IGFzeW5jIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHtcbiAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgIGxldCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICB9O1xuICAgIGNvbnN0IHR1cGxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBzdG9wTGlzdGVuaW5nID0gc3RhcnRMaXN0ZW5pbmcoe1xuICAgICAgICBwcmVkaWNhdGUsXG4gICAgICAgIGVmZmVjdDogKGFjdGlvbiwgbGlzdGVuZXJBcGkpID0+IHtcbiAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJlc29sdmUoW2FjdGlvbiwgbGlzdGVuZXJBcGkuZ2V0U3RhdGUoKSwgbGlzdGVuZXJBcGkuZ2V0T3JpZ2luYWxTdGF0ZSgpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIHN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHByb21pc2VzID0gW3R1cGxlUHJvbWlzZV07XG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0LCBudWxsKSkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSk7XG59O1xudmFyIGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20gPSAob3B0aW9ucykgPT4ge1xuICBsZXQge1xuICAgIHR5cGUsXG4gICAgYWN0aW9uQ3JlYXRvcixcbiAgICBtYXRjaGVyLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlKSB7XG4gICAgcHJlZGljYXRlID0gY3JlYXRlQWN0aW9uKHR5cGUpLm1hdGNoO1xuICB9IGVsc2UgaWYgKGFjdGlvbkNyZWF0b3IpIHtcbiAgICB0eXBlID0gYWN0aW9uQ3JlYXRvci50eXBlO1xuICAgIHByZWRpY2F0ZSA9IGFjdGlvbkNyZWF0b3IubWF0Y2g7XG4gIH0gZWxzZSBpZiAobWF0Y2hlcikge1xuICAgIHByZWRpY2F0ZSA9IG1hdGNoZXI7XG4gIH0gZWxzZSBpZiAocHJlZGljYXRlKSB7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjEpIDogXCJDcmVhdGluZyBvciByZW1vdmluZyBhIGxpc3RlbmVyIHJlcXVpcmVzIG9uZSBvZiB0aGUga25vd24gZmllbGRzIGZvciBtYXRjaGluZyBhbiBhY3Rpb25cIik7XG4gIH1cbiAgYXNzZXJ0RnVuY3Rpb24oZWZmZWN0LCBcIm9wdGlvbnMubGlzdGVuZXJcIik7XG4gIHJldHVybiB7XG4gICAgcHJlZGljYXRlLFxuICAgIHR5cGUsXG4gICAgZWZmZWN0XG4gIH07XG59O1xudmFyIGNyZWF0ZUxpc3RlbmVyRW50cnkgPSBPYmplY3QuYXNzaWduKChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIGNvbnN0IGlkID0gbmFub2lkKCk7XG4gIGNvbnN0IGVudHJ5ID0ge1xuICAgIGlkLFxuICAgIGVmZmVjdCxcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBwZW5kaW5nOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMikgOiBcIlVuc3Vic2NyaWJlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlbnRyeTtcbn0sIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiBjcmVhdGVMaXN0ZW5lckVudHJ5XG59KTtcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSAoZW50cnkpID0+IHtcbiAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gIH0pO1xufTtcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IChsaXN0ZW5lck1hcCkgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVyTWFwLmZvckVhY2goY2FuY2VsQWN0aXZlTGlzdGVuZXJzKTtcbiAgICBsaXN0ZW5lck1hcC5jbGVhcigpO1xuICB9O1xufTtcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykgPT4ge1xuICB0cnkge1xuICAgIGVycm9ySGFuZGxlcihlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pO1xuICB9IGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XG4gICAgfSwgMCk7XG4gIH1cbn07XG52YXIgYWRkTGlzdGVuZXIgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihgJHthbG19L2FkZGApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gYWRkTGlzdGVuZXJcbn0pO1xudmFyIGNsZWFyQWxsTGlzdGVuZXJzID0gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlQWxsYCk7XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZWApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gcmVtb3ZlTGlzdGVuZXJcbn0pO1xudmFyIGRlZmF1bHRFcnJvckhhbmRsZXIgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmVycm9yKGAke2FsbX0vZXJyb3JgLCAuLi5hcmdzKTtcbn07XG52YXIgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlID0gKG1pZGRsZXdhcmVPcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB7XG4gICAgZXh0cmEsXG4gICAgb25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXJcbiAgfSA9IG1pZGRsZXdhcmVPcHRpb25zO1xuICBhc3NlcnRGdW5jdGlvbihvbkVycm9yLCBcIm9uRXJyb3JcIik7XG4gIGNvbnN0IGluc2VydEVudHJ5ID0gKGVudHJ5KSA9PiB7XG4gICAgZW50cnkudW5zdWJzY3JpYmUgPSAoKSA9PiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpO1xuICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgIHJldHVybiAoY2FuY2VsT3B0aW9ucykgPT4ge1xuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChjYW5jZWxPcHRpb25zPy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCBzdGFydExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgbGV0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgKGV4aXN0aW5nRW50cnkpID0+IGV4aXN0aW5nRW50cnkuZWZmZWN0ID09PSBvcHRpb25zLmVmZmVjdCk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgZW50cnkgPSBjcmVhdGVMaXN0ZW5lckVudHJ5KG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zZXJ0RW50cnkoZW50cnkpO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXJ0TGlzdGVuaW5nLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdGFydExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGVmZmVjdCxcbiAgICAgIHByZWRpY2F0ZVxuICAgIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hQcmVkaWNhdGVPclR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVudHJ5Mi50eXBlID09PSB0eXBlIDogZW50cnkyLnByZWRpY2F0ZSA9PT0gcHJlZGljYXRlO1xuICAgICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5Mi5lZmZlY3QgPT09IGVmZmVjdDtcbiAgICB9KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob3B0aW9ucy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEhZW50cnk7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RvcExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RvcExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXIgPSBhc3luYyAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJuYWxUYXNrQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0YWtlID0gY3JlYXRlVGFrZVBhdHRlcm4oc3RhcnRMaXN0ZW5pbmcsIGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBhdXRvSm9pblByb21pc2VzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICAvLyBVc2UgYXNzaWduKCkgcmF0aGVyIHRoYW4gLi4uIHRvIGF2b2lkIGV4dHJhIGhlbHBlciBmdW5jdGlvbnMgYWRkZWQgdG8gYnVuZGxlXG4gICAgICAgIGFzc2lnbih7fSwgYXBpLCB7XG4gICAgICAgICAgZ2V0T3JpZ2luYWxTdGF0ZSxcbiAgICAgICAgICBjb25kaXRpb246IChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHRha2UocHJlZGljYXRlLCB0aW1lb3V0KS50aGVuKEJvb2xlYW4pLFxuICAgICAgICAgIHRha2UsXG4gICAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgZm9yazogY3JlYXRlRm9yayhpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCwgYXV0b0pvaW5Qcm9taXNlcyksXG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGVudHJ5LnVuc3Vic2NyaWJlLFxuICAgICAgICAgIHN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlciwgXywgc2V0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgc2V0LmRlbGV0ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgZW50cnkucGVuZGluZy5kZWxldGUoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkOiAoKSA9PiB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSk7XG4gICAgfSBjYXRjaCAobGlzdGVuZXJFcnJvcikge1xuICAgICAgaWYgKCEobGlzdGVuZXJFcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yKSkge1xuICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBsaXN0ZW5lckVycm9yLCB7XG4gICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGF1dG9Kb2luUHJvbWlzZXMpO1xuICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNvbXBsZXRlZCk7XG4gICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlID0gY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUobGlzdGVuZXJNYXApO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoIWlzQWN0aW9uMyhhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoYWRkTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKGNsZWFyQWxsTGlzdGVuZXJzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZW1vdmVMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RvcExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XG4gICAgfVxuICAgIGxldCBvcmlnaW5hbFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZ2V0T3JpZ2luYWxTdGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmIChvcmlnaW5hbFN0YXRlID09PSBJTlRFUk5BTF9OSUxfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjMpIDogYCR7YWxtfTogZ2V0T3JpZ2luYWxTdGF0ZSBjYW4gb25seSBiZSBjYWxsZWQgc3luY2hyb25vdXNseWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XG4gICAgfTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBpZiAobGlzdGVuZXJNYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGxpc3RlbmVyRW50cmllcykge1xuICAgICAgICAgIGxldCBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgICAgfSBjYXRjaCAocHJlZGljYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xuICAgICAgICAgICAgICByYWlzZWRCeTogXCJwcmVkaWNhdGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcihlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBzdGFydExpc3RlbmluZyxcbiAgICBzdG9wTGlzdGVuaW5nLFxuICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxuICB9O1xufTtcblxuLy8gc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzXG5pbXBvcnQgeyBjb21wb3NlIGFzIGNvbXBvc2UzIH0gZnJvbSBcInJlZHV4XCI7XG52YXIgY3JlYXRlTWlkZGxld2FyZUVudHJ5ID0gKG1pZGRsZXdhcmUpID0+ICh7XG4gIGlkOiBuYW5vaWQoKSxcbiAgbWlkZGxld2FyZSxcbiAgYXBwbGllZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxufSk7XG52YXIgbWF0Y2hJbnN0YW5jZSA9IChpbnN0YW5jZUlkKSA9PiAoYWN0aW9uKSA9PiBhY3Rpb24/Lm1ldGE/Lmluc3RhbmNlSWQgPT09IGluc3RhbmNlSWQ7XG52YXIgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlSWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgbWlkZGxld2FyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oXCJkeW5hbWljTWlkZGxld2FyZS9hZGRcIiwgKC4uLm1pZGRsZXdhcmVzKSA9PiAoe1xuICAgIHBheWxvYWQ6IG1pZGRsZXdhcmVzLFxuICAgIG1ldGE6IHtcbiAgICAgIGluc3RhbmNlSWRcbiAgICB9XG4gIH0pKSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gd2l0aE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGFkZE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGFkZE1pZGRsZXdhcmUyKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4gZW50cnkyLm1pZGRsZXdhcmUgPT09IG1pZGRsZXdhcmUyKTtcbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgZW50cnkgPSBjcmVhdGVNaWRkbGV3YXJlRW50cnkobWlkZGxld2FyZTIpO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZU1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICB9KTtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gYWRkTWlkZGxld2FyZVxuICB9KTtcbiAgY29uc3QgZ2V0RmluYWxNaWRkbGV3YXJlID0gKGFwaSkgPT4ge1xuICAgIGNvbnN0IGFwcGxpZWRNaWRkbGV3YXJlID0gQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKS5tYXAoKGVudHJ5KSA9PiBlbXBsYWNlKGVudHJ5LmFwcGxpZWQsIGFwaSwge1xuICAgICAgaW5zZXJ0OiAoKSA9PiBlbnRyeS5taWRkbGV3YXJlKGFwaSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIGNvbXBvc2UzKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcbiAgfTtcbiAgY29uc3QgaXNXaXRoTWlkZGxld2FyZSA9IGlzQWxsT2Yod2l0aE1pZGRsZXdhcmUsIG1hdGNoSW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNXaXRoTWlkZGxld2FyZShhY3Rpb24pKSB7XG4gICAgICBhZGRNaWRkbGV3YXJlKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBnZXRGaW5hbE1pZGRsZXdhcmUoYXBpKShuZXh0KShhY3Rpb24pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgYWRkTWlkZGxld2FyZSxcbiAgICB3aXRoTWlkZGxld2FyZSxcbiAgICBpbnN0YW5jZUlkXG4gIH07XG59O1xuXG4vLyBzcmMvY29tYmluZVNsaWNlcy50c1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIGFzIGNvbWJpbmVSZWR1Y2VyczIgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZSkgPT4gXCJyZWR1Y2VyUGF0aFwiIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gXCJzdHJpbmdcIjtcbnZhciBnZXRSZWR1Y2VycyA9IChzbGljZXMpID0+IHNsaWNlcy5mbGF0TWFwKChzbGljZU9yTWFwKSA9PiBpc1NsaWNlTGlrZShzbGljZU9yTWFwKSA/IFtbc2xpY2VPck1hcC5yZWR1Y2VyUGF0aCwgc2xpY2VPck1hcC5yZWR1Y2VyXV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XG52YXIgT1JJR0lOQUxfU1RBVEUgPSBTeW1ib2wuZm9yKFwicnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsXCIpO1xudmFyIGlzU3RhdGVQcm94eSA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW09SSUdJTkFMX1NUQVRFXTtcbnZhciBzdGF0ZVByb3h5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgY3JlYXRlU3RhdGVQcm94eSA9IChzdGF0ZSwgcmVkdWNlck1hcCkgPT4gZW1wbGFjZShzdGF0ZVByb3h5TWFwLCBzdGF0ZSwge1xuICBpbnNlcnQ6ICgpID0+IG5ldyBQcm94eShzdGF0ZSwge1xuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIGlmIChwcm9wID09PSBPUklHSU5BTF9TVEFURSlcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcC50b1N0cmluZygpXTtcbiAgICAgICAgaWYgKHJlZHVjZXIpIHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VyUmVzdWx0ID0gcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgICAgICAgIHR5cGU6IG5hbm9pZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWR1Y2VyUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZHVjZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KVxufSk7XG52YXIgb3JpZ2luYWwgPSAoc3RhdGUpID0+IHtcbiAgaWYgKCFpc1N0YXRlUHJveHkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjUpIDogXCJvcmlnaW5hbCBtdXN0IGJlIHVzZWQgb24gc3RhdGUgUHJveHlcIik7XG4gIH1cbiAgcmV0dXJuIHN0YXRlW09SSUdJTkFMX1NUQVRFXTtcbn07XG52YXIgbm9vcFJlZHVjZXIgPSAoc3RhdGUgPSB7fSkgPT4gc3RhdGU7XG5mdW5jdGlvbiBjb21iaW5lU2xpY2VzKC4uLnNsaWNlcykge1xuICBjb25zdCByZWR1Y2VyTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldFJlZHVjZXJzKHNsaWNlcykpO1xuICBjb25zdCBnZXRSZWR1Y2VyID0gKCkgPT4gT2JqZWN0LmtleXMocmVkdWNlck1hcCkubGVuZ3RoID8gY29tYmluZVJlZHVjZXJzMihyZWR1Y2VyTWFwKSA6IG5vb3BSZWR1Y2VyO1xuICBsZXQgcmVkdWNlciA9IGdldFJlZHVjZXIoKTtcbiAgZnVuY3Rpb24gY29tYmluZWRSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICByZXR1cm4gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgfVxuICBjb21iaW5lZFJlZHVjZXIud2l0aExhenlMb2FkZWRTbGljZXMgPSAoKSA9PiBjb21iaW5lZFJlZHVjZXI7XG4gIGNvbnN0IGluamVjdCA9IChzbGljZSwgY29uZmlnID0ge30pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXJUb0luamVjdFxuICAgIH0gPSBzbGljZTtcbiAgICBjb25zdCBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdO1xuICAgIGlmICghY29uZmlnLm92ZXJyaWRlRXhpc3RpbmcgJiYgY3VycmVudFJlZHVjZXIgJiYgY3VycmVudFJlZHVjZXIgIT09IHJlZHVjZXJUb0luamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgY2FsbGVkIFxcYGluamVjdFxcYCB0byBvdmVycmlkZSBhbHJlYWR5LWV4aXN0aW5nIHJlZHVjZXIgJHtyZWR1Y2VyUGF0aH0gd2l0aG91dCBzcGVjaWZ5aW5nIFxcYG92ZXJyaWRlRXhpc3Rpbmc6IHRydWVcXGBgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gICAgfVxuICAgIHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdID0gcmVkdWNlclRvSW5qZWN0O1xuICAgIHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgfTtcbiAgY29uc3Qgc2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIG1ha2VTZWxlY3RvcihzZWxlY3RvckZuLCBzZWxlY3RTdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZWxlY3RvcjIoc3RhdGUsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvckZuKGNyZWF0ZVN0YXRlUHJveHkoc2VsZWN0U3RhdGUgPyBzZWxlY3RTdGF0ZShzdGF0ZSwgLi4uYXJncykgOiBzdGF0ZSwgcmVkdWNlck1hcCksIC4uLmFyZ3MpO1xuICAgIH07XG4gIH0sIHtcbiAgICBvcmlnaW5hbFxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29tYmluZWRSZWR1Y2VyLCB7XG4gICAgaW5qZWN0LFxuICAgIHNlbGVjdG9yXG4gIH0pO1xufVxuXG4vLyBzcmMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS50c1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHJldHVybiBgTWluaWZpZWQgUmVkdXggVG9vbGtpdCBlcnJvciAjJHtjb2RlfTsgdmlzaXQgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9FcnJvcnM/Y29kZT0ke2NvZGV9IGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuIGA7XG59XG5leHBvcnQge1xuICBSZWR1Y2VyVHlwZSxcbiAgU0hPVUxEX0FVVE9CQVRDSCxcbiAgVGFza0Fib3J0RXJyb3IsXG4gIFR1cGxlLFxuICBhZGRMaXN0ZW5lcixcbiAgYXN5bmNUaHVua0NyZWF0b3IsXG4gIGF1dG9CYXRjaEVuaGFuY2VyLFxuICBidWlsZENyZWF0ZVNsaWNlLFxuICBjbGVhckFsbExpc3RlbmVycyxcbiAgY29tYmluZVNsaWNlcyxcbiAgY29uZmlndXJlU3RvcmUsXG4gIGNyZWF0ZUFjdGlvbixcbiAgY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZUFzeW5jVGh1bmssXG4gIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IsXG4gIGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlLFxuICBjcmVhdGVFbnRpdHlBZGFwdGVyLFxuICBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSxcbiAgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUsXG4gIGNyZWF0ZVJlZHVjZXIsXG4gIGNyZWF0ZVNlbGVjdG9yLFxuICBjcmVhdGVTZWxlY3RvckNyZWF0b3IyIGFzIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVTbGljZSxcbiAgY3VycmVudDIgYXMgY3VycmVudCxcbiAgZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlLFxuICBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlLFxuICBmcmVlemUsXG4gIGlzQWN0aW9uQ3JlYXRvcixcbiAgaXNBbGxPZixcbiAgaXNBbnlPZixcbiAgaXNBc3luY1RodW5rQWN0aW9uLFxuICBpc0RyYWZ0NCBhcyBpc0RyYWZ0LFxuICBpc0ZTQSBhcyBpc0ZsdXhTdGFuZGFyZEFjdGlvbixcbiAgaXNGdWxmaWxsZWQsXG4gIGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgaXNQZW5kaW5nLFxuICBpc1BsYWluLFxuICBpc1JlamVjdGVkLFxuICBpc1JlamVjdGVkV2l0aFZhbHVlLFxuICBscnVNZW1vaXplLFxuICBtaW5pU2VyaWFsaXplRXJyb3IsXG4gIG5hbm9pZCxcbiAgb3JpZ2luYWwyIGFzIG9yaWdpbmFsLFxuICBwcmVwYXJlQXV0b0JhdGNoZWQsXG4gIHJlbW92ZUxpc3RlbmVyLFxuICB1bndyYXBSZXN1bHQsXG4gIHdlYWtNYXBNZW1vaXplMiBhcyB3ZWFrTWFwTWVtb2l6ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHV4LXRvb2xraXQubW9kZXJuLm1qcy5tYXAiXSwibmFtZXMiOlsicHJvZHVjZSIsImN1cnJlbnQiLCJjdXJyZW50MiIsImZyZWV6ZSIsIm9yaWdpbmFsIiwib3JpZ2luYWwyIiwiaXNEcmFmdCIsImlzRHJhZnQ0IiwiY3JlYXRlU2VsZWN0b3IiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IyIiwibHJ1TWVtb2l6ZSIsIndlYWtNYXBNZW1vaXplIiwid2Vha01hcE1lbW9pemUyIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yIiwiYXJncyIsImNyZWF0ZVNlbGVjdG9yMiIsImNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMiIsIk9iamVjdCIsImFzc2lnbiIsImFyZ3MyIiwic2VsZWN0b3IiLCJ3cmFwcGVkU2VsZWN0b3IiLCJ2YWx1ZSIsInJlc3QiLCJ3aXRoVHlwZXMiLCJjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciIsImFwcGx5TWlkZGxld2FyZSIsImNyZWF0ZVN0b3JlIiwiY29tcG9zZSIsImNvbXBvc2UyIiwiY29tYmluZVJlZHVjZXJzIiwiaXNQbGFpbk9iamVjdCIsImlzUGxhaW5PYmplY3QyIiwiY29tcG9zZVdpdGhEZXZUb29scyIsIndpbmRvdyIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFwcGx5IiwiZGV2VG9vbHNFbmhhbmNlciIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJub29wMyIsInRodW5rIiwidGh1bmtNaWRkbGV3YXJlIiwid2l0aEV4dHJhQXJndW1lbnQiLCJpc0FjdGlvbiIsImhhc01hdGNoRnVuY3Rpb24iLCJ2IiwibWF0Y2giLCJjcmVhdGVBY3Rpb24iLCJ0eXBlIiwicHJlcGFyZUFjdGlvbiIsImFjdGlvbkNyZWF0b3IiLCJwcmVwYXJlZCIsIkVycm9yIiwicHJvY2VzcyIsImZvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJwYXlsb2FkIiwibWV0YSIsImVycm9yIiwidG9TdHJpbmciLCJhY3Rpb24iLCJpc0FjdGlvbkNyZWF0b3IiLCJpc0ZTQSIsImtleXMiLCJldmVyeSIsImlzVmFsaWRLZXkiLCJrZXkiLCJpbmRleE9mIiwiZ2V0TWVzc2FnZSIsInNwbGl0VHlwZSIsInNwbGl0IiwiYWN0aW9uTmFtZSIsImNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlIiwib3B0aW9ucyIsIm5leHQiLCJpc0FjdGlvbkNyZWF0b3IyIiwiY29uc29sZSIsIndhcm4iLCJjcmVhdGVOZXh0U3RhdGUiLCJpc0RyYWZ0YWJsZSIsImdldFRpbWVNZWFzdXJlVXRpbHMiLCJtYXhEZWxheSIsImZuTmFtZSIsImVsYXBzZWQiLCJtZWFzdXJlVGltZSIsImZuIiwic3RhcnRlZCIsIkRhdGUiLCJub3ciLCJmaW5pc2hlZCIsIndhcm5JZkV4Y2VlZGVkIiwiZmluZCIsIml0ZXJhYmxlIiwiY29tcGFyYXRvciIsImVudHJ5IiwiVHVwbGUiLCJfVHVwbGUiLCJBcnJheSIsIlN5bWJvbCIsInNwZWNpZXMiLCJjb25jYXQiLCJhcnIiLCJwcmVwZW5kIiwiaXNBcnJheSIsImNvbnN0cnVjdG9yIiwiaXRlbXMiLCJzZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImZyZWV6ZURyYWZ0YWJsZSIsInZhbCIsImVtcGxhY2UiLCJtYXAiLCJoYW5kbGVyIiwiaGFzIiwiZ2V0IiwidXBkYXRlIiwic2V0IiwiaW5zZXJ0IiwiaW5zZXJ0ZWQiLCJpc0ltbXV0YWJsZURlZmF1bHQiLCJpc0Zyb3plbiIsInRyYWNrRm9yTXV0YXRpb25zIiwiaXNJbW11dGFibGUiLCJpZ25vcmVQYXRocyIsIm9iaiIsInRyYWNrZWRQcm9wZXJ0aWVzIiwidHJhY2tQcm9wZXJ0aWVzIiwiZGV0ZWN0TXV0YXRpb25zIiwicGF0aCIsImNoZWNrZWRPYmplY3RzIiwiU2V0IiwidHJhY2tlZCIsImFkZCIsImNoaWxkcmVuIiwiY2hpbGRQYXRoIiwiaWdub3JlZFBhdGhzIiwidHJhY2tlZFByb3BlcnR5Iiwic2FtZVBhcmVudFJlZiIsInByZXZPYmoiLCJzYW1lUmVmIiwiTnVtYmVyIiwiaXNOYU4iLCJ3YXNNdXRhdGVkIiwia2V5c1RvRGV0ZWN0IiwiaGFzSWdub3JlZFBhdGhzIiwibmVzdGVkUGF0aCIsImhhc01hdGNoZXMiLCJzb21lIiwiaWdub3JlZCIsIlJlZ0V4cCIsInRlc3QiLCJyZXN1bHQiLCJjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJzdHJpbmdpZnkyIiwic2VyaWFsaXplciIsImluZGVudCIsImRlY3ljbGVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldFNlcmlhbGl6ZTIiLCJzdGFjayIsIl8iLCJzbGljZSIsImpvaW4iLCJ0aGlzUG9zIiwic3BsaWNlIiwicHVzaCIsIkluZmluaXR5IiwiY2FsbCIsImdldFNlcmlhbGl6ZSIsIndhcm5BZnRlciIsInRyYWNrIiwiYmluZCIsImdldFN0YXRlIiwic3RhdGUiLCJ0cmFja2VyIiwibWVhc3VyZVV0aWxzIiwiZGlzcGF0Y2hlZEFjdGlvbiIsImlzQWN0aW9uMiIsImlzUGxhaW4iLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJjYWNoZSIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImVudHJpZXMiLCJuZXN0ZWRWYWx1ZSIsImlzTmVzdGVkRnJvemVuIiwidmFsdWVzIiwiY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwiaWdub3JlZEFjdGlvbnMiLCJpZ25vcmVkQWN0aW9uUGF0aHMiLCJpZ25vcmVTdGF0ZSIsImlnbm9yZUFjdGlvbnMiLCJkaXNhYmxlQ2FjaGUiLCJXZWFrU2V0Iiwic3RvcmVBUEkiLCJmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlIiwiZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlIiwiaXNCb29sZWFuIiwieCIsImJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJnZXREZWZhdWx0TWlkZGxld2FyZSIsImltbXV0YWJsZUNoZWNrIiwic2VyaWFsaXphYmxlQ2hlY2siLCJhY3Rpb25DcmVhdG9yQ2hlY2siLCJtaWRkbGV3YXJlQXJyYXkiLCJleHRyYUFyZ3VtZW50IiwiaW1tdXRhYmxlT3B0aW9ucyIsInVuc2hpZnQiLCJzZXJpYWxpemFibGVPcHRpb25zIiwiYWN0aW9uQ3JlYXRvck9wdGlvbnMiLCJTSE9VTERfQVVUT0JBVENIIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwiY3JlYXRlUXVldWVXaXRoVGltZXIiLCJ0aW1lb3V0Iiwibm90aWZ5Iiwic2V0VGltZW91dCIsInJBRiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImF1dG9CYXRjaEVuaGFuY2VyIiwic3RvcmUiLCJub3RpZnlpbmciLCJzaG91bGROb3RpZnlBdEVuZE9mVGljayIsIm5vdGlmaWNhdGlvblF1ZXVlZCIsImxpc3RlbmVycyIsInF1ZXVlQ2FsbGJhY2siLCJxdWV1ZU1pY3JvdGFzayIsInF1ZXVlTm90aWZpY2F0aW9uIiwibm90aWZ5TGlzdGVuZXJzIiwiZm9yRWFjaCIsImwiLCJzdWJzY3JpYmUiLCJsaXN0ZW5lcjIiLCJ3cmFwcGVkTGlzdGVuZXIiLCJ1bnN1YnNjcmliZSIsImRlbGV0ZSIsImRpc3BhdGNoIiwiYnVpbGRHZXREZWZhdWx0RW5oYW5jZXJzIiwibWlkZGxld2FyZUVuaGFuY2VyIiwiZ2V0RGVmYXVsdEVuaGFuY2VycyIsImF1dG9CYXRjaCIsImVuaGFuY2VyQXJyYXkiLCJJU19QUk9EVUNUSU9OIiwiY29uZmlndXJlU3RvcmUiLCJyZWR1Y2VyIiwibWlkZGxld2FyZSIsImRldlRvb2xzIiwicHJlbG9hZGVkU3RhdGUiLCJlbmhhbmNlcnMiLCJyb290UmVkdWNlciIsImZpbmFsTWlkZGxld2FyZSIsIml0ZW0iLCJmaW5hbENvbXBvc2UiLCJ0cmFjZSIsInN0b3JlRW5oYW5jZXJzIiwiaW5jbHVkZXMiLCJjb21wb3NlZEVuaGFuY2VyIiwiY3JlYXRlTmV4dFN0YXRlMiIsImlzRHJhZnQyIiwiaXNEcmFmdGFibGUyIiwiZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2siLCJidWlsZGVyQ2FsbGJhY2siLCJhY3Rpb25zTWFwIiwiYWN0aW9uTWF0Y2hlcnMiLCJkZWZhdWx0Q2FzZVJlZHVjZXIiLCJidWlsZGVyIiwiYWRkQ2FzZSIsInR5cGVPckFjdGlvbkNyZWF0b3IiLCJhZGRNYXRjaGVyIiwibWF0Y2hlciIsImFkZERlZmF1bHRDYXNlIiwiaXNTdGF0ZUZ1bmN0aW9uIiwiY3JlYXRlUmVkdWNlciIsImluaXRpYWxTdGF0ZSIsIm1hcE9yQnVpbGRlckNhbGxiYWNrIiwiZmluYWxBY3Rpb25NYXRjaGVycyIsImZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyIiwiZ2V0SW5pdGlhbFN0YXRlIiwiZnJvemVuSW5pdGlhbFN0YXRlIiwiY2FzZVJlZHVjZXJzIiwiZmlsdGVyIiwicmVkdWNlcjIiLCJjciIsInJlZHVjZSIsInByZXZpb3VzU3RhdGUiLCJjYXNlUmVkdWNlciIsImRyYWZ0IiwidXJsQWxwaGFiZXQiLCJuYW5vaWQiLCJzaXplIiwiaWQiLCJpIiwiTWF0aCIsInJhbmRvbSIsIm1hdGNoZXMiLCJpc0FueU9mIiwibWF0Y2hlcnMiLCJpc0FsbE9mIiwiaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEiLCJ2YWxpZFN0YXR1cyIsImhhc1ZhbGlkUmVxdWVzdElkIiwicmVxdWVzdElkIiwiaGFzVmFsaWRSZXF1ZXN0U3RhdHVzIiwicmVxdWVzdFN0YXR1cyIsImlzQXN5bmNUaHVua0FycmF5IiwiYSIsImlzUGVuZGluZyIsImFzeW5jVGh1bmtzIiwiYXN5bmNUaHVuayIsInBlbmRpbmciLCJjb21iaW5lZE1hdGNoZXIiLCJpc1JlamVjdGVkIiwicmVqZWN0ZWQiLCJpc1JlamVjdGVkV2l0aFZhbHVlIiwiaGFzRmxhZyIsInJlamVjdGVkV2l0aFZhbHVlIiwiaXNGdWxmaWxsZWQiLCJmdWxmaWxsZWQiLCJpc0FzeW5jVGh1bmtBY3Rpb24iLCJjb21tb25Qcm9wZXJ0aWVzIiwiUmVqZWN0V2l0aFZhbHVlIiwiRnVsZmlsbFdpdGhNZXRhIiwibWluaVNlcmlhbGl6ZUVycm9yIiwic2ltcGxlRXJyb3IiLCJwcm9wZXJ0eSIsIm1lc3NhZ2UiLCJTdHJpbmciLCJjcmVhdGVBc3luY1RodW5rIiwiY3JlYXRlQXN5bmNUaHVuazIiLCJ0eXBlUHJlZml4IiwicGF5bG9hZENyZWF0b3IiLCJhcmciLCJzZXJpYWxpemVFcnJvciIsImFib3J0ZWQiLCJuYW1lIiwiY29uZGl0aW9uIiwiZXh0cmEiLCJpZEdlbmVyYXRvciIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImFib3J0SGFuZGxlciIsImFib3J0UmVhc29uIiwiYWJvcnQiLCJyZWFzb24iLCJwcm9taXNlIiwiZmluYWxBY3Rpb24iLCJjb25kaXRpb25SZXN1bHQiLCJpc1RoZW5hYmxlIiwic2lnbmFsIiwiYWJvcnRlZFByb21pc2UiLCJQcm9taXNlIiwicmVqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldFBlbmRpbmdNZXRhIiwicmFjZSIsInJlc29sdmUiLCJyZWplY3RXaXRoVmFsdWUiLCJmdWxmaWxsV2l0aFZhbHVlIiwidGhlbiIsImVyciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJza2lwRGlzcGF0Y2giLCJkaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiIsInVud3JhcCIsInVud3JhcFJlc3VsdCIsInNldHRsZWQiLCJhc3luY1RodW5rU3ltYm9sIiwiZm9yIiwiYXN5bmNUaHVua0NyZWF0b3IiLCJSZWR1Y2VyVHlwZSIsIlJlZHVjZXJUeXBlMiIsImdldFR5cGUiLCJhY3Rpb25LZXkiLCJidWlsZENyZWF0ZVNsaWNlIiwiY3JlYXRvcnMiLCJjQVQiLCJjcmVhdGVTbGljZTIiLCJyZWR1Y2VyUGF0aCIsInJlZHVjZXJzIiwiYnVpbGRSZWR1Y2VyQ3JlYXRvcnMiLCJyZWR1Y2VyTmFtZXMiLCJjb250ZXh0Iiwic2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUiLCJzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSIsImFjdGlvbkNyZWF0b3JzIiwic2xpY2VNYXRjaGVycyIsImNvbnRleHRNZXRob2RzIiwiZXhwb3NlQWN0aW9uIiwibmFtZTIiLCJleHBvc2VDYXNlUmVkdWNlciIsInJlZHVjZXJOYW1lIiwicmVkdWNlckRlZmluaXRpb24iLCJyZWR1Y2VyRGV0YWlscyIsImNyZWF0ZU5vdGF0aW9uIiwiaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbiIsImhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uIiwiaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24iLCJidWlsZFJlZHVjZXIiLCJleHRyYVJlZHVjZXJzIiwiZmluYWxDYXNlUmVkdWNlcnMiLCJzTSIsIm0iLCJzZWxlY3RTZWxmIiwiaW5qZWN0ZWRTZWxlY3RvckNhY2hlIiwiTWFwIiwiX3JlZHVjZXIiLCJtYWtlU2VsZWN0b3JQcm9wcyIsInJlZHVjZXJQYXRoMiIsImluamVjdGVkIiwic2VsZWN0U2xpY2UiLCJzbGljZVN0YXRlIiwiZ2V0U2VsZWN0b3JzIiwic2VsZWN0U3RhdGUiLCJzZWxlY3RvckNhY2hlIiwiV2Vha01hcCIsInNlbGVjdG9ycyIsIndyYXBTZWxlY3RvciIsImFjdGlvbnMiLCJpbmplY3RJbnRvIiwiaW5qZWN0YWJsZSIsInBhdGhPcHQiLCJjb25maWciLCJuZXdSZWR1Y2VyUGF0aCIsImluamVjdCIsIndyYXBwZXIiLCJyb290U3RhdGUiLCJ1bndyYXBwZWQiLCJjcmVhdGVTbGljZSIsIl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUiLCJwcmVwYXJlZFJlZHVjZXIiLCJwcmVwYXJlIiwibWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUiLCJwcmVwYXJlQ2FsbGJhY2siLCJpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uIiwibm9vcCIsImdldEluaXRpYWxFbnRpdHlTdGF0ZSIsImlkcyIsImVudGl0aWVzIiwiY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSIsInN0YXRlQWRhcHRlciIsImFkZGl0aW9uYWxTdGF0ZSIsInNldEFsbCIsImNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkiLCJzZWxlY3RJZHMiLCJzZWxlY3RFbnRpdGllcyIsInNlbGVjdEFsbCIsInNlbGVjdElkIiwic2VsZWN0QnlJZCIsInNlbGVjdFRvdGFsIiwic2VsZWN0R2xvYmFsaXplZEVudGl0aWVzIiwiY3JlYXRlTmV4dFN0YXRlMyIsImlzRHJhZnQzIiwiaXNEcmFmdFR5cGVkIiwiY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yIiwibXV0YXRvciIsIm9wZXJhdG9yIiwiY3JlYXRlU3RhdGVPcGVyYXRvciIsIm9wZXJhdGlvbiIsImlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50IiwiYXJnMiIsInJ1bk11dGF0b3IiLCJzZWxlY3RJZFZhbHVlIiwiZW50aXR5IiwiZW5zdXJlRW50aXRpZXNBcnJheSIsInNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMiLCJuZXdFbnRpdGllcyIsImFkZGVkIiwidXBkYXRlZCIsImNoYW5nZXMiLCJjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlciIsImFkZE9uZU11dGFibHkiLCJhZGRNYW55TXV0YWJseSIsInNldE9uZU11dGFibHkiLCJzZXRNYW55TXV0YWJseSIsInNldEFsbE11dGFibHkiLCJyZW1vdmVPbmVNdXRhYmx5IiwicmVtb3ZlTWFueU11dGFibHkiLCJkaWRNdXRhdGUiLCJyZW1vdmVBbGxNdXRhYmx5IiwidGFrZU5ld0tleSIsIm9yaWdpbmFsMyIsIm5ld0tleSIsImhhc05ld0tleSIsInVwZGF0ZU9uZU11dGFibHkiLCJ1cGRhdGVNYW55TXV0YWJseSIsInVwZGF0ZXMiLCJuZXdLZXlzIiwidXBkYXRlc1BlckVudGl0eSIsImRpZE11dGF0ZUVudGl0aWVzIiwiZGlkTXV0YXRlSWRzIiwiZSIsInVwc2VydE9uZU11dGFibHkiLCJ1cHNlcnRNYW55TXV0YWJseSIsInJlbW92ZUFsbCIsImFkZE9uZSIsImFkZE1hbnkiLCJzZXRPbmUiLCJzZXRNYW55IiwidXBkYXRlT25lIiwidXBkYXRlTWFueSIsInVwc2VydE9uZSIsInVwc2VydE1hbnkiLCJyZW1vdmVPbmUiLCJyZW1vdmVNYW55IiwiY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyIiwic29ydCIsIm1vZGVscyIsIm1vZGVsIiwibWVyZ2UiLCJhcHBsaWVkVXBkYXRlcyIsIm5ld0lkIiwicmVzb3J0RW50aXRpZXMiLCJhcmVBcnJheXNFcXVhbCIsImIiLCJhbGxFbnRpdGllcyIsIm5ld1NvcnRlZElkcyIsImNyZWF0ZUVudGl0eUFkYXB0ZXIiLCJzb3J0Q29tcGFyZXIiLCJpbnN0YW5jZSIsInN0YXRlRmFjdG9yeSIsInNlbGVjdG9yc0ZhY3RvcnkiLCJpc0FjdGlvbjMiLCJ0YXNrIiwibGlzdGVuZXIiLCJjb21wbGV0ZWQiLCJjYW5jZWxsZWQiLCJ0YXNrQ2FuY2VsbGVkIiwidGFza0NvbXBsZXRlZCIsImxpc3RlbmVyQ2FuY2VsbGVkIiwibGlzdGVuZXJDb21wbGV0ZWQiLCJUYXNrQWJvcnRFcnJvciIsImNvZGUiLCJhc3NlcnRGdW5jdGlvbiIsImZ1bmMiLCJleHBlY3RlZCIsIm5vb3AyIiwiY2F0Y2hSZWplY3Rpb24iLCJvbkVycm9yIiwiY2F0Y2giLCJhZGRBYm9ydFNpZ25hbExpc3RlbmVyIiwiYWJvcnRTaWduYWwiLCJjYWxsYmFjayIsIm9uY2UiLCJhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWxpZGF0ZUFjdGl2ZSIsInJhY2VXaXRoU2lnbmFsIiwiY2xlYW51cCIsIm5vdGlmeVJlamVjdGlvbiIsImZpbmFsbHkiLCJydW5UYXNrIiwidGFzazIiLCJjbGVhblVwIiwic3RhdHVzIiwiY3JlYXRlUGF1c2UiLCJvdXRwdXQiLCJjcmVhdGVEZWxheSIsInBhdXNlIiwidGltZW91dE1zIiwiSU5URVJOQUxfTklMX1RPS0VOIiwiYWxtIiwiY3JlYXRlRm9yayIsInBhcmVudEFib3J0U2lnbmFsIiwicGFyZW50QmxvY2tpbmdQcm9taXNlcyIsImxpbmtDb250cm9sbGVycyIsImNvbnRyb2xsZXIiLCJ0YXNrRXhlY3V0b3IiLCJvcHRzIiwiY2hpbGRBYm9ydENvbnRyb2xsZXIiLCJyZXN1bHQyIiwiZGVsYXkiLCJhdXRvSm9pbiIsImNhbmNlbCIsImNyZWF0ZVRha2VQYXR0ZXJuIiwic3RhcnRMaXN0ZW5pbmciLCJ0YWtlIiwicHJlZGljYXRlIiwidHVwbGVQcm9taXNlIiwic3RvcExpc3RlbmluZyIsImVmZmVjdCIsImxpc3RlbmVyQXBpIiwiZ2V0T3JpZ2luYWxTdGF0ZSIsInByb21pc2VzIiwiZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSIsImNyZWF0ZUxpc3RlbmVyRW50cnkiLCJjYW5jZWxBY3RpdmVMaXN0ZW5lcnMiLCJjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSIsImxpc3RlbmVyTWFwIiwiY2xlYXIiLCJzYWZlbHlOb3RpZnlFcnJvciIsImVycm9ySGFuZGxlciIsImVycm9yVG9Ob3RpZnkiLCJlcnJvckluZm8iLCJlcnJvckhhbmRsZXJFcnJvciIsImFkZExpc3RlbmVyIiwiY2xlYXJBbGxMaXN0ZW5lcnMiLCJyZW1vdmVMaXN0ZW5lciIsImRlZmF1bHRFcnJvckhhbmRsZXIiLCJjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlT3B0aW9ucyIsImluc2VydEVudHJ5IiwiY2FuY2VsT3B0aW9ucyIsImNhbmNlbEFjdGl2ZSIsImZyb20iLCJleGlzdGluZ0VudHJ5IiwiZW50cnkyIiwibWF0Y2hQcmVkaWNhdGVPclR5cGUiLCJub3RpZnlMaXN0ZW5lciIsImFwaSIsImludGVybmFsVGFza0NvbnRyb2xsZXIiLCJhdXRvSm9pblByb21pc2VzIiwiQm9vbGVhbiIsImZvcmsiLCJ0aHJvd0lmQ2FuY2VsbGVkIiwibGlzdGVuZXJFcnJvciIsInJhaXNlZEJ5IiwiYWxsIiwiY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJvcmlnaW5hbFN0YXRlIiwiY3VycmVudFN0YXRlIiwibGlzdGVuZXJFbnRyaWVzIiwicnVuTGlzdGVuZXIiLCJwcmVkaWNhdGVFcnJvciIsImNsZWFyTGlzdGVuZXJzIiwiY29tcG9zZTMiLCJjcmVhdGVNaWRkbGV3YXJlRW50cnkiLCJhcHBsaWVkIiwibWF0Y2hJbnN0YW5jZSIsImluc3RhbmNlSWQiLCJjcmVhdGVEeW5hbWljTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVNYXAiLCJ3aXRoTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVzIiwiYWRkTWlkZGxld2FyZSIsImFkZE1pZGRsZXdhcmUyIiwibWlkZGxld2FyZTIiLCJnZXRGaW5hbE1pZGRsZXdhcmUiLCJhcHBsaWVkTWlkZGxld2FyZSIsImlzV2l0aE1pZGRsZXdhcmUiLCJjb21iaW5lUmVkdWNlcnMyIiwiaXNTbGljZUxpa2UiLCJtYXliZVNsaWNlTGlrZSIsImdldFJlZHVjZXJzIiwic2xpY2VzIiwiZmxhdE1hcCIsInNsaWNlT3JNYXAiLCJPUklHSU5BTF9TVEFURSIsImlzU3RhdGVQcm94eSIsInN0YXRlUHJveHlNYXAiLCJjcmVhdGVTdGF0ZVByb3h5IiwicmVkdWNlck1hcCIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsInJlZHVjZXJSZXN1bHQiLCJub29wUmVkdWNlciIsImNvbWJpbmVTbGljZXMiLCJmcm9tRW50cmllcyIsImdldFJlZHVjZXIiLCJjb21iaW5lZFJlZHVjZXIiLCJ3aXRoTGF6eUxvYWRlZFNsaWNlcyIsInJlZHVjZXJUb0luamVjdCIsImN1cnJlbnRSZWR1Y2VyIiwib3ZlcnJpZGVFeGlzdGluZyIsIm1ha2VTZWxlY3RvciIsInNlbGVjdG9yRm4iLCJzZWxlY3RvcjIiLCJpc0ZsdXhTdGFuZGFyZEFjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/immer/dist/immer.mjs":
/*!*******************************************!*\
  !*** ./node_modules/immer/dist/immer.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: function() { return /* binding */ Immer2; },\n/* harmony export */   applyPatches: function() { return /* binding */ applyPatches; },\n/* harmony export */   castDraft: function() { return /* binding */ castDraft; },\n/* harmony export */   castImmutable: function() { return /* binding */ castImmutable; },\n/* harmony export */   createDraft: function() { return /* binding */ createDraft; },\n/* harmony export */   current: function() { return /* binding */ current; },\n/* harmony export */   enableMapSet: function() { return /* binding */ enableMapSet; },\n/* harmony export */   enablePatches: function() { return /* binding */ enablePatches; },\n/* harmony export */   finishDraft: function() { return /* binding */ finishDraft; },\n/* harmony export */   freeze: function() { return /* binding */ freeze; },\n/* harmony export */   immerable: function() { return /* binding */ DRAFTABLE; },\n/* harmony export */   isDraft: function() { return /* binding */ isDraft; },\n/* harmony export */   isDraftable: function() { return /* binding */ isDraftable; },\n/* harmony export */   nothing: function() { return /* binding */ NOTHING; },\n/* harmony export */   original: function() { return /* binding */ original; },\n/* harmony export */   produce: function() { return /* binding */ produce; },\n/* harmony export */   produceWithPatches: function() { return /* binding */ produceWithPatches; },\n/* harmony export */   setAutoFreeze: function() { return /* binding */ setAutoFreeze; },\n/* harmony export */   setUseStrictShallowCopy: function() { return /* binding */ setUseStrictShallowCopy; }\n/* harmony export */ });\n// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\n// src/utils/errors.ts\nvar errors =  true ? [\n    // All error codes, starting by 0:\n    function(plugin) {\n        return \"The plugin for '\".concat(plugin, \"' has not been loaded into Immer. To enable the plugin, import and call `enable\").concat(plugin, \"()` when initializing your application.\");\n    },\n    function(thing) {\n        return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\".concat(thing, \"'\");\n    },\n    \"This object has been frozen and should not be mutated\",\n    function(data) {\n        return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n    },\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n    \"Immer forbids circular references\",\n    \"The first or second argument to `produce` must be a function\",\n    \"The third argument to `produce` must be a function or undefined\",\n    \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n    \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n    function(thing) {\n        return \"'current' expects a draft, got: \".concat(thing);\n    },\n    \"Object.defineProperty() cannot be used on an Immer draft\",\n    \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n    \"Immer only supports deleting array indices\",\n    \"Immer only supports setting array indices and the 'length' property\",\n    function(thing) {\n        return \"'original' expects a draft, got: \".concat(thing);\n    }\n] : 0;\nfunction die(error) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (true) {\n        const e = errors[error];\n        const msg = typeof e === \"function\" ? e.apply(null, args) : e;\n        throw new Error(\"[Immer] \".concat(msg));\n    }\n    throw new Error(\"[Immer] minified error nr: \".concat(error, \". Full error at: https://bit.ly/3cXEKWf\"));\n}\n// src/utils/common.ts\nvar getPrototypeOf = Object.getPrototypeOf;\nfunction isDraft(value) {\n    return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n    var _value_constructor;\n    if (!value) return false;\n    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value_constructor = value.constructor) === null || _value_constructor === void 0 ? void 0 : _value_constructor[DRAFTABLE]) || isMap(value) || isSet(value);\n}\nvar objectCtorString = Object.prototype.constructor.toString();\nfunction isPlainObject(value) {\n    if (!value || typeof value !== \"object\") return false;\n    const proto = getPrototypeOf(value);\n    if (proto === null) {\n        return true;\n    }\n    const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n    if (Ctor === Object) return true;\n    return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n    if (!isDraft(value)) die(15, value);\n    return value[DRAFT_STATE].base_;\n}\nfunction each(obj, iter) {\n    if (getArchtype(obj) === 0 /* Object */ ) {\n        Reflect.ownKeys(obj).forEach((key)=>{\n            iter(key, obj[key], obj);\n        });\n    } else {\n        obj.forEach((entry, index)=>iter(index, entry, obj));\n    }\n}\nfunction getArchtype(thing) {\n    const state = thing[DRAFT_STATE];\n    return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */  : isMap(thing) ? 2 /* Map */  : isSet(thing) ? 3 /* Set */  : 0 /* Object */ ;\n}\nfunction has(thing, prop) {\n    return getArchtype(thing) === 2 /* Map */  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n    return getArchtype(thing) === 2 /* Map */  ? thing.get(prop) : thing[prop];\n}\nfunction set(thing, propOrOldValue, value) {\n    const t = getArchtype(thing);\n    if (t === 2 /* Map */ ) thing.set(propOrOldValue, value);\n    else if (t === 3 /* Set */ ) {\n        thing.add(value);\n    } else thing[propOrOldValue] = value;\n}\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nfunction isMap(target) {\n    return target instanceof Map;\n}\nfunction isSet(target) {\n    return target instanceof Set;\n}\nfunction latest(state) {\n    return state.copy_ || state.base_;\n}\nfunction shallowCopy(base, strict) {\n    if (isMap(base)) {\n        return new Map(base);\n    }\n    if (isSet(base)) {\n        return new Set(base);\n    }\n    if (Array.isArray(base)) return Array.prototype.slice.call(base);\n    if (!strict && isPlainObject(base)) {\n        if (!getPrototypeOf(base)) {\n            const obj = /* @__PURE__ */ Object.create(null);\n            return Object.assign(obj, base);\n        }\n        return {\n            ...base\n        };\n    }\n    const descriptors = Object.getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    let keys = Reflect.ownKeys(descriptors);\n    for(let i = 0; i < keys.length; i++){\n        const key = keys[i];\n        const desc = descriptors[key];\n        if (desc.writable === false) {\n            desc.writable = true;\n            desc.configurable = true;\n        }\n        if (desc.get || desc.set) descriptors[key] = {\n            configurable: true,\n            writable: true,\n            // could live with !!desc.set as well here...\n            enumerable: desc.enumerable,\n            value: base[key]\n        };\n    }\n    return Object.create(getPrototypeOf(base), descriptors);\n}\nfunction freeze(obj) {\n    let deep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n    if (getArchtype(obj) > 1) {\n        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n    }\n    Object.freeze(obj);\n    if (deep) Object.entries(obj).forEach((param)=>{\n        let [key, value] = param;\n        return freeze(value, true);\n    });\n    return obj;\n}\nfunction dontMutateFrozenCollections() {\n    die(2);\n}\nfunction isFrozen(obj) {\n    return Object.isFrozen(obj);\n}\n// src/utils/plugins.ts\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n    const plugin = plugins[pluginKey];\n    if (!plugin) {\n        die(0, pluginKey);\n    }\n    return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n}\n// src/core/scope.ts\nvar currentScope;\nfunction getCurrentScope() {\n    return currentScope;\n}\nfunction createScope(parent_, immer_) {\n    return {\n        drafts_: [],\n        parent_,\n        immer_,\n        // Whenever the modified draft contains a draft from another scope, we\n        // need to prevent auto-freezing so the unowned draft can be finalized.\n        canAutoFreeze_: true,\n        unfinalizedDrafts_: 0\n    };\n}\nfunction usePatchesInScope(scope, patchListener) {\n    if (patchListener) {\n        getPlugin(\"Patches\");\n        scope.patches_ = [];\n        scope.inversePatches_ = [];\n        scope.patchListener_ = patchListener;\n    }\n}\nfunction revokeScope(scope) {\n    leaveScope(scope);\n    scope.drafts_.forEach(revokeDraft);\n    scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n    if (scope === currentScope) {\n        currentScope = scope.parent_;\n    }\n}\nfunction enterScope(immer2) {\n    return currentScope = createScope(currentScope, immer2);\n}\nfunction revokeDraft(draft) {\n    const state = draft[DRAFT_STATE];\n    if (state.type_ === 0 /* Object */  || state.type_ === 1 /* Array */ ) state.revoke_();\n    else state.revoked_ = true;\n}\n// src/core/finalize.ts\nfunction processResult(result, scope) {\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\n    const baseDraft = scope.drafts_[0];\n    const isReplaced = result !== void 0 && result !== baseDraft;\n    if (isReplaced) {\n        if (baseDraft[DRAFT_STATE].modified_) {\n            revokeScope(scope);\n            die(4);\n        }\n        if (isDraftable(result)) {\n            result = finalize(scope, result);\n            if (!scope.parent_) maybeFreeze(scope, result);\n        }\n        if (scope.patches_) {\n            getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);\n        }\n    } else {\n        result = finalize(scope, baseDraft, []);\n    }\n    revokeScope(scope);\n    if (scope.patches_) {\n        scope.patchListener_(scope.patches_, scope.inversePatches_);\n    }\n    return result !== NOTHING ? result : void 0;\n}\nfunction finalize(rootScope, value, path) {\n    if (isFrozen(value)) return value;\n    const state = value[DRAFT_STATE];\n    if (!state) {\n        each(value, (key, childValue)=>finalizeProperty(rootScope, state, value, key, childValue, path));\n        return value;\n    }\n    if (state.scope_ !== rootScope) return value;\n    if (!state.modified_) {\n        maybeFreeze(rootScope, state.base_, true);\n        return state.base_;\n    }\n    if (!state.finalized_) {\n        state.finalized_ = true;\n        state.scope_.unfinalizedDrafts_--;\n        const result = state.copy_;\n        let resultEach = result;\n        let isSet2 = false;\n        if (state.type_ === 3 /* Set */ ) {\n            resultEach = new Set(result);\n            result.clear();\n            isSet2 = true;\n        }\n        each(resultEach, (key, childValue)=>finalizeProperty(rootScope, state, result, key, childValue, path, isSet2));\n        maybeFreeze(rootScope, result, false);\n        if (path && rootScope.patches_) {\n            getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);\n        }\n    }\n    return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n    if ( true && childValue === targetObject) die(5);\n    if (isDraft(childValue)) {\n        const path = rootPath && parentState && parentState.type_ !== 3 /* Set */  && // Set objects are atomic since they have no keys.\n        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\n        const res = finalize(rootScope, childValue, path);\n        set(targetObject, prop, res);\n        if (isDraft(res)) {\n            rootScope.canAutoFreeze_ = false;\n        } else return;\n    } else if (targetIsSet) {\n        targetObject.add(childValue);\n    }\n    if (isDraftable(childValue) && !isFrozen(childValue)) {\n        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n            return;\n        }\n        finalize(rootScope, childValue);\n        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== \"symbol\" && Object.prototype.propertyIsEnumerable.call(targetObject, prop)) maybeFreeze(rootScope, childValue);\n    }\n}\nfunction maybeFreeze(scope, value) {\n    let deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n        freeze(value, deep);\n    }\n}\n// src/core/proxy.ts\nfunction createProxyProxy(base, parent) {\n    const isArray = Array.isArray(base);\n    const state = {\n        type_: isArray ? 1 /* Array */  : 0 /* Object */ ,\n        // Track which produce call this is associated with.\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        // True for both shallow and deep changes.\n        modified_: false,\n        // Used during finalization.\n        finalized_: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned_: {},\n        // The parent draft state.\n        parent_: parent,\n        // The base state.\n        base_: base,\n        // The base proxy.\n        draft_: null,\n        // set below\n        // The base copy with any updated values.\n        copy_: null,\n        // Called by the `produce` function.\n        revoke_: null,\n        isManual_: false\n    };\n    let target = state;\n    let traps = objectTraps;\n    if (isArray) {\n        target = [\n            state\n        ];\n        traps = arrayTraps;\n    }\n    const { revoke, proxy } = Proxy.revocable(target, traps);\n    state.draft_ = proxy;\n    state.revoke_ = revoke;\n    return proxy;\n}\nvar objectTraps = {\n    get (state, prop) {\n        if (prop === DRAFT_STATE) return state;\n        const source = latest(state);\n        if (!has(source, prop)) {\n            return readPropFromProto(state, source, prop);\n        }\n        const value = source[prop];\n        if (state.finalized_ || !isDraftable(value)) {\n            return value;\n        }\n        if (value === peek(state.base_, prop)) {\n            prepareCopy(state);\n            return state.copy_[prop] = createProxy(value, state);\n        }\n        return value;\n    },\n    has (state, prop) {\n        return prop in latest(state);\n    },\n    ownKeys (state) {\n        return Reflect.ownKeys(latest(state));\n    },\n    set (state, prop, value) {\n        const desc = getDescriptorFromProto(latest(state), prop);\n        if (desc === null || desc === void 0 ? void 0 : desc.set) {\n            desc.set.call(state.draft_, value);\n            return true;\n        }\n        if (!state.modified_) {\n            const current2 = peek(latest(state), prop);\n            const currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];\n            if (currentState && currentState.base_ === value) {\n                state.copy_[prop] = value;\n                state.assigned_[prop] = false;\n                return true;\n            }\n            if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;\n            prepareCopy(state);\n            markChanged(state);\n        }\n        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'\n        (value !== void 0 || prop in state.copy_) || // special case: NaN\n        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;\n        state.copy_[prop] = value;\n        state.assigned_[prop] = true;\n        return true;\n    },\n    deleteProperty (state, prop) {\n        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n            state.assigned_[prop] = false;\n            prepareCopy(state);\n            markChanged(state);\n        } else {\n            delete state.assigned_[prop];\n        }\n        if (state.copy_) {\n            delete state.copy_[prop];\n        }\n        return true;\n    },\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n    // the same guarantee in ES5 mode.\n    getOwnPropertyDescriptor (state, prop) {\n        const owner = latest(state);\n        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n        if (!desc) return desc;\n        return {\n            writable: true,\n            configurable: state.type_ !== 1 /* Array */  || prop !== \"length\",\n            enumerable: desc.enumerable,\n            value: owner[prop]\n        };\n    },\n    defineProperty () {\n        die(11);\n    },\n    getPrototypeOf (state) {\n        return getPrototypeOf(state.base_);\n    },\n    setPrototypeOf () {\n        die(12);\n    }\n};\nvar arrayTraps = {};\neach(objectTraps, (key, fn)=>{\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0];\n        return fn.apply(this, arguments);\n    };\n});\narrayTraps.deleteProperty = function(state, prop) {\n    if ( true && isNaN(parseInt(prop))) die(13);\n    return arrayTraps.set.call(this, state, prop, void 0);\n};\narrayTraps.set = function(state, prop, value) {\n    if ( true && prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n    return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\nfunction peek(draft, prop) {\n    const state = draft[DRAFT_STATE];\n    const source = state ? latest(state) : draft;\n    return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n    var // This is a very special case, if the prop is a getter defined by the\n    // prototype, we should invoke it with the draft as context!\n    _desc_get;\n    const desc = getDescriptorFromProto(source, prop);\n    return desc ? \"value\" in desc ? desc.value : (_desc_get = desc.get) === null || _desc_get === void 0 ? void 0 : _desc_get.call(state.draft_) : void 0;\n}\nfunction getDescriptorFromProto(source, prop) {\n    if (!(prop in source)) return void 0;\n    let proto = getPrototypeOf(source);\n    while(proto){\n        const desc = Object.getOwnPropertyDescriptor(proto, prop);\n        if (desc) return desc;\n        proto = getPrototypeOf(proto);\n    }\n    return void 0;\n}\nfunction markChanged(state) {\n    if (!state.modified_) {\n        state.modified_ = true;\n        if (state.parent_) {\n            markChanged(state.parent_);\n        }\n    }\n}\nfunction prepareCopy(state) {\n    if (!state.copy_) {\n        state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);\n    }\n}\n// src/core/immerClass.ts\nvar Immer2 = class {\n    createDraft(base) {\n        if (!isDraftable(base)) die(8);\n        if (isDraft(base)) base = current(base);\n        const scope = enterScope(this);\n        const proxy = createProxy(base, void 0);\n        proxy[DRAFT_STATE].isManual_ = true;\n        leaveScope(scope);\n        return proxy;\n    }\n    finishDraft(draft, patchListener) {\n        const state = draft && draft[DRAFT_STATE];\n        if (!state || !state.isManual_) die(9);\n        const { scope_: scope } = state;\n        usePatchesInScope(scope, patchListener);\n        return processResult(void 0, scope);\n    }\n    /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */ setAutoFreeze(value) {\n        this.autoFreeze_ = value;\n    }\n    /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */ setUseStrictShallowCopy(value) {\n        this.useStrictShallowCopy_ = value;\n    }\n    applyPatches(base, patches) {\n        let i;\n        for(i = patches.length - 1; i >= 0; i--){\n            const patch = patches[i];\n            if (patch.path.length === 0 && patch.op === \"replace\") {\n                base = patch.value;\n                break;\n            }\n        }\n        if (i > -1) {\n            patches = patches.slice(i + 1);\n        }\n        const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n        if (isDraft(base)) {\n            return applyPatchesImpl(base, patches);\n        }\n        return this.produce(base, (draft)=>applyPatchesImpl(draft, patches));\n    }\n    constructor(config){\n        this.autoFreeze_ = true;\n        this.useStrictShallowCopy_ = false;\n        /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */ this.produce = (base, recipe, patchListener)=>{\n            if (typeof base === \"function\" && typeof recipe !== \"function\") {\n                const defaultBase = recipe;\n                recipe = base;\n                const self = this;\n                return function curriedProduce() {\n                    let base2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultBase;\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    return self.produce(base2, (draft)=>recipe.call(this, draft, ...args));\n                };\n            }\n            if (typeof recipe !== \"function\") die(6);\n            if (patchListener !== void 0 && typeof patchListener !== \"function\") die(7);\n            let result;\n            if (isDraftable(base)) {\n                const scope = enterScope(this);\n                const proxy = createProxy(base, void 0);\n                let hasError = true;\n                try {\n                    result = recipe(proxy);\n                    hasError = false;\n                } finally{\n                    if (hasError) revokeScope(scope);\n                    else leaveScope(scope);\n                }\n                usePatchesInScope(scope, patchListener);\n                return processResult(result, scope);\n            } else if (!base || typeof base !== \"object\") {\n                result = recipe(base);\n                if (result === void 0) result = base;\n                if (result === NOTHING) result = void 0;\n                if (this.autoFreeze_) freeze(result, true);\n                if (patchListener) {\n                    const p = [];\n                    const ip = [];\n                    getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n                    patchListener(p, ip);\n                }\n                return result;\n            } else die(1, base);\n        };\n        this.produceWithPatches = (base, recipe)=>{\n            if (typeof base === \"function\") {\n                var _this = this;\n                return function(state) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    return _this.produceWithPatches(state, (draft)=>base(draft, ...args));\n                };\n            }\n            let patches, inversePatches;\n            const result = this.produce(base, recipe, (p, ip)=>{\n                patches = p;\n                inversePatches = ip;\n            });\n            return [\n                result,\n                patches,\n                inversePatches\n            ];\n        };\n        if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === \"boolean\") this.setAutoFreeze(config.autoFreeze);\n        if (typeof (config === null || config === void 0 ? void 0 : config.useStrictShallowCopy) === \"boolean\") this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n    }\n};\nfunction createProxy(value, parent) {\n    const draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\n    const scope = parent ? parent.scope_ : getCurrentScope();\n    scope.drafts_.push(draft);\n    return draft;\n}\n// src/core/current.ts\nfunction current(value) {\n    if (!isDraft(value)) die(10, value);\n    return currentImpl(value);\n}\nfunction currentImpl(value) {\n    if (!isDraftable(value) || isFrozen(value)) return value;\n    const state = value[DRAFT_STATE];\n    let copy;\n    if (state) {\n        if (!state.modified_) return state.base_;\n        state.finalized_ = true;\n        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n    } else {\n        copy = shallowCopy(value, true);\n    }\n    each(copy, (key, childValue)=>{\n        set(copy, key, currentImpl(childValue));\n    });\n    if (state) {\n        state.finalized_ = false;\n    }\n    return copy;\n}\n// src/plugins/patches.ts\nfunction enablePatches() {\n    const errorOffset = 16;\n    if (true) {\n        errors.push('Sets cannot have \"replace\" patches.', function(op) {\n            return \"Unsupported patch operation: \" + op;\n        }, function(path) {\n            return \"Cannot apply patch, path doesn't resolve: \" + path;\n        }, \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\");\n    }\n    const REPLACE = \"replace\";\n    const ADD = \"add\";\n    const REMOVE = \"remove\";\n    function generatePatches_(state, basePath, patches, inversePatches) {\n        switch(state.type_){\n            case 0 /* Object */ :\n            case 2 /* Map */ :\n                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n            case 1 /* Array */ :\n                return generateArrayPatches(state, basePath, patches, inversePatches);\n            case 3 /* Set */ :\n                return generateSetPatches(state, basePath, patches, inversePatches);\n        }\n    }\n    function generateArrayPatches(state, basePath, patches, inversePatches) {\n        let { base_, assigned_ } = state;\n        let copy_ = state.copy_;\n        if (copy_.length < base_.length) {\n            ;\n            [base_, copy_] = [\n                copy_,\n                base_\n            ];\n            [patches, inversePatches] = [\n                inversePatches,\n                patches\n            ];\n        }\n        for(let i = 0; i < base_.length; i++){\n            if (assigned_[i] && copy_[i] !== base_[i]) {\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REPLACE,\n                    path,\n                    // Need to maybe clone it, as it can in fact be the original value\n                    // due to the base/copy inversion at the start of this function\n                    value: clonePatchValueIfNeeded(copy_[i])\n                });\n                inversePatches.push({\n                    op: REPLACE,\n                    path,\n                    value: clonePatchValueIfNeeded(base_[i])\n                });\n            }\n        }\n        for(let i = base_.length; i < copy_.length; i++){\n            const path = basePath.concat([\n                i\n            ]);\n            patches.push({\n                op: ADD,\n                path,\n                // Need to maybe clone it, as it can in fact be the original value\n                // due to the base/copy inversion at the start of this function\n                value: clonePatchValueIfNeeded(copy_[i])\n            });\n        }\n        for(let i = copy_.length - 1; base_.length <= i; --i){\n            const path = basePath.concat([\n                i\n            ]);\n            inversePatches.push({\n                op: REMOVE,\n                path\n            });\n        }\n    }\n    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n        const { base_, copy_ } = state;\n        each(state.assigned_, (key, assignedValue)=>{\n            const origValue = get(base_, key);\n            const value = get(copy_, key);\n            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n            if (origValue === value && op === REPLACE) return;\n            const path = basePath.concat(key);\n            patches.push(op === REMOVE ? {\n                op,\n                path\n            } : {\n                op,\n                path,\n                value\n            });\n            inversePatches.push(op === ADD ? {\n                op: REMOVE,\n                path\n            } : op === REMOVE ? {\n                op: ADD,\n                path,\n                value: clonePatchValueIfNeeded(origValue)\n            } : {\n                op: REPLACE,\n                path,\n                value: clonePatchValueIfNeeded(origValue)\n            });\n        });\n    }\n    function generateSetPatches(state, basePath, patches, inversePatches) {\n        let { base_, copy_ } = state;\n        let i = 0;\n        base_.forEach((value)=>{\n            if (!copy_.has(value)) {\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REMOVE,\n                    path,\n                    value\n                });\n                inversePatches.unshift({\n                    op: ADD,\n                    path,\n                    value\n                });\n            }\n            i++;\n        });\n        i = 0;\n        copy_.forEach((value)=>{\n            if (!base_.has(value)) {\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: ADD,\n                    path,\n                    value\n                });\n                inversePatches.unshift({\n                    op: REMOVE,\n                    path,\n                    value\n                });\n            }\n            i++;\n        });\n    }\n    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n        patches.push({\n            op: REPLACE,\n            path: [],\n            value: replacement === NOTHING ? void 0 : replacement\n        });\n        inversePatches.push({\n            op: REPLACE,\n            path: [],\n            value: baseValue\n        });\n    }\n    function applyPatches_(draft, patches) {\n        patches.forEach((patch)=>{\n            const { path, op } = patch;\n            let base = draft;\n            for(let i = 0; i < path.length - 1; i++){\n                const parentType = getArchtype(base);\n                let p = path[i];\n                if (typeof p !== \"string\" && typeof p !== \"number\") {\n                    p = \"\" + p;\n                }\n                if ((parentType === 0 /* Object */  || parentType === 1 /* Array */ ) && (p === \"__proto__\" || p === \"constructor\")) die(errorOffset + 3);\n                if (typeof base === \"function\" && p === \"prototype\") die(errorOffset + 3);\n                base = get(base, p);\n                if (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"));\n            }\n            const type = getArchtype(base);\n            const value = deepClonePatchValue(patch.value);\n            const key = path[path.length - 1];\n            switch(op){\n                case REPLACE:\n                    switch(type){\n                        case 2 /* Map */ :\n                            return base.set(key, value);\n                        case 3 /* Set */ :\n                            die(errorOffset);\n                        default:\n                            return base[key] = value;\n                    }\n                case ADD:\n                    switch(type){\n                        case 1 /* Array */ :\n                            return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n                        case 2 /* Map */ :\n                            return base.set(key, value);\n                        case 3 /* Set */ :\n                            return base.add(value);\n                        default:\n                            return base[key] = value;\n                    }\n                case REMOVE:\n                    switch(type){\n                        case 1 /* Array */ :\n                            return base.splice(key, 1);\n                        case 2 /* Map */ :\n                            return base.delete(key);\n                        case 3 /* Set */ :\n                            return base.delete(patch.value);\n                        default:\n                            return delete base[key];\n                    }\n                default:\n                    die(errorOffset + 1, op);\n            }\n        });\n        return draft;\n    }\n    function deepClonePatchValue(obj) {\n        if (!isDraftable(obj)) return obj;\n        if (Array.isArray(obj)) return obj.map(deepClonePatchValue);\n        if (isMap(obj)) return new Map(Array.from(obj.entries()).map((param)=>{\n            let [k, v] = param;\n            return [\n                k,\n                deepClonePatchValue(v)\n            ];\n        }));\n        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n        const cloned = Object.create(getPrototypeOf(obj));\n        for(const key in obj)cloned[key] = deepClonePatchValue(obj[key]);\n        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n        return cloned;\n    }\n    function clonePatchValueIfNeeded(obj) {\n        if (isDraft(obj)) {\n            return deepClonePatchValue(obj);\n        } else return obj;\n    }\n    loadPlugin(\"Patches\", {\n        applyPatches_,\n        generatePatches_,\n        generateReplacementPatches_\n    });\n}\n// src/plugins/mapset.ts\nfunction enableMapSet() {\n    class DraftMap extends Map {\n        get size() {\n            return latest(this[DRAFT_STATE]).size;\n        }\n        has(key) {\n            return latest(this[DRAFT_STATE]).has(key);\n        }\n        set(key, value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!latest(state).has(key) || latest(state).get(key) !== value) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_.set(key, true);\n                state.copy_.set(key, value);\n                state.assigned_.set(key, true);\n            }\n            return this;\n        }\n        delete(key) {\n            if (!this.has(key)) {\n                return false;\n            }\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareMapCopy(state);\n            markChanged(state);\n            if (state.base_.has(key)) {\n                state.assigned_.set(key, false);\n            } else {\n                state.assigned_.delete(key);\n            }\n            state.copy_.delete(key);\n            return true;\n        }\n        clear() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_ = /* @__PURE__ */ new Map();\n                each(state.base_, (key)=>{\n                    state.assigned_.set(key, false);\n                });\n                state.copy_.clear();\n            }\n        }\n        forEach(cb, thisArg) {\n            const state = this[DRAFT_STATE];\n            latest(state).forEach((_value, key, _map)=>{\n                cb.call(thisArg, this.get(key), key, this);\n            });\n        }\n        get(key) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            const value = latest(state).get(key);\n            if (state.finalized_ || !isDraftable(value)) {\n                return value;\n            }\n            if (value !== state.base_.get(key)) {\n                return value;\n            }\n            const draft = createProxy(value, state);\n            prepareMapCopy(state);\n            state.copy_.set(key, draft);\n            return draft;\n        }\n        keys() {\n            return latest(this[DRAFT_STATE]).keys();\n        }\n        values() {\n            const iterator = this.keys();\n            return {\n                [Symbol.iterator]: ()=>this.values(),\n                next: ()=>{\n                    const r = iterator.next();\n                    if (r.done) return r;\n                    const value = this.get(r.value);\n                    return {\n                        done: false,\n                        value\n                    };\n                }\n            };\n        }\n        entries() {\n            const iterator = this.keys();\n            return {\n                [Symbol.iterator]: ()=>this.entries(),\n                next: ()=>{\n                    const r = iterator.next();\n                    if (r.done) return r;\n                    const value = this.get(r.value);\n                    return {\n                        done: false,\n                        value: [\n                            r.value,\n                            value\n                        ]\n                    };\n                }\n            };\n        }\n        [(DRAFT_STATE, Symbol.iterator)]() {\n            return this.entries();\n        }\n        constructor(target, parent){\n            super();\n            this[DRAFT_STATE] = {\n                type_: 2 /* Map */ ,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: void 0,\n                assigned_: void 0,\n                base_: target,\n                draft_: this,\n                isManual_: false,\n                revoked_: false\n            };\n        }\n    }\n    function proxyMap_(target, parent) {\n        return new DraftMap(target, parent);\n    }\n    function prepareMapCopy(state) {\n        if (!state.copy_) {\n            state.assigned_ = /* @__PURE__ */ new Map();\n            state.copy_ = new Map(state.base_);\n        }\n    }\n    class DraftSet extends Set {\n        get size() {\n            return latest(this[DRAFT_STATE]).size;\n        }\n        has(value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!state.copy_) {\n                return state.base_.has(value);\n            }\n            if (state.copy_.has(value)) return true;\n            if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n            return false;\n        }\n        add(value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!this.has(value)) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.add(value);\n            }\n            return this;\n        }\n        delete(value) {\n            if (!this.has(value)) {\n                return false;\n            }\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            markChanged(state);\n            return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */ false);\n        }\n        clear() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.clear();\n            }\n        }\n        values() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.values();\n        }\n        entries() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.entries();\n        }\n        keys() {\n            return this.values();\n        }\n        [(DRAFT_STATE, Symbol.iterator)]() {\n            return this.values();\n        }\n        forEach(cb, thisArg) {\n            const iterator = this.values();\n            let result = iterator.next();\n            while(!result.done){\n                cb.call(thisArg, result.value, result.value, this);\n                result = iterator.next();\n            }\n        }\n        constructor(target, parent){\n            super();\n            this[DRAFT_STATE] = {\n                type_: 3 /* Set */ ,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: void 0,\n                base_: target,\n                draft_: this,\n                drafts_: /* @__PURE__ */ new Map(),\n                revoked_: false,\n                isManual_: false\n            };\n        }\n    }\n    function proxySet_(target, parent) {\n        return new DraftSet(target, parent);\n    }\n    function prepareSetCopy(state) {\n        if (!state.copy_) {\n            state.copy_ = /* @__PURE__ */ new Set();\n            state.base_.forEach((value)=>{\n                if (isDraftable(value)) {\n                    const draft = createProxy(value, state);\n                    state.drafts_.set(value, draft);\n                    state.copy_.add(draft);\n                } else {\n                    state.copy_.add(value);\n                }\n            });\n        }\n    }\n    function assertUnrevoked(state) {\n        if (state.revoked_) die(3, JSON.stringify(latest(state)));\n    }\n    loadPlugin(\"MapSet\", {\n        proxyMap_,\n        proxySet_\n    });\n}\n// src/immer.ts\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);\nvar applyPatches = immer.applyPatches.bind(immer);\nvar createDraft = immer.createDraft.bind(immer);\nvar finishDraft = immer.finishDraft.bind(immer);\nfunction castDraft(value) {\n    return value;\n}\nfunction castImmutable(value) {\n    return value;\n}\n //# sourceMappingURL=immer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsbUJBQW1CO0FBQ25CLElBQUlBLFVBQVVDLE9BQU9DLEdBQUcsQ0FBQztBQUN6QixJQUFJQyxZQUFZRixPQUFPQyxHQUFHLENBQUM7QUFDM0IsSUFBSUUsY0FBY0gsT0FBT0MsR0FBRyxDQUFDO0FBRTdCLHNCQUFzQjtBQUN0QixJQUFJRyxTQUFTQyxLQUFxQyxHQUFHO0lBQ25ELGtDQUFrQztJQUNsQyxTQUFTQyxNQUFNO1FBQ2IsT0FBTyxtQkFBNEdBLE9BQXpGQSxRQUFPLG1GQUF5RixPQUFQQSxRQUFPO0lBQzVIO0lBQ0EsU0FBU0MsS0FBSztRQUNaLE9BQU8sc0pBQTRKLE9BQU5BLE9BQU07SUFDcks7SUFDQTtJQUNBLFNBQVNDLElBQUk7UUFDWCxPQUFPLHlIQUF5SEE7SUFDbEk7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTRCxLQUFLO1FBQ1osT0FBTyxtQ0FBeUMsT0FBTkE7SUFDNUM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVNBLEtBQUs7UUFDWixPQUFPLG9DQUEwQyxPQUFOQTtJQUM3QztDQUdELEdBQUcsQ0FBRTtBQUNOLFNBQVNFLElBQUlDLEtBQUs7SUFBRTtRQUFHQyxLQUFILDJCQUFPOztJQUN6QixJQUFJTixJQUFxQyxFQUFFO1FBQ3pDLE1BQU1PLElBQUlSLE1BQU0sQ0FBQ00sTUFBTTtRQUN2QixNQUFNRyxNQUFNLE9BQU9ELE1BQU0sYUFBYUEsRUFBRUUsS0FBSyxDQUFDLE1BQU1ILFFBQVFDO1FBQzVELE1BQU0sSUFBSUcsTUFBTSxXQUFlLE9BQUpGO0lBQzdCO0lBQ0EsTUFBTSxJQUFJRSxNQUNSLDhCQUFvQyxPQUFOTCxPQUFNO0FBRXhDO0FBRUEsc0JBQXNCO0FBQ3RCLElBQUlNLGlCQUFpQkMsT0FBT0QsY0FBYztBQUMxQyxT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U2tOLGdCQUFnQnRMLEtBQUs7UUFDNUIsSUFBSUEsTUFBTWlFLFFBQVEsRUFDaEJ2RyxJQUFJLEdBQUd5TyxLQUFLQyxTQUFTLENBQUNyTCxPQUFPZjtJQUNqQztJQUNBMEMsV0FBVyxVQUFVO1FBQUUyRztRQUFXQztJQUFVO0FBQzlDO0FBRUEsZUFBZTtBQUNmLElBQUkrQyxRQUFRLElBQUkxRTtBQUNoQixJQUFJWSxVQUFVOEQsTUFBTTlELE9BQU87QUFDM0IsSUFBSVUscUJBQXFCb0QsTUFBTXBELGtCQUFrQixDQUFDcUQsSUFBSSxDQUNwREQ7QUFFRixJQUFJdEUsZ0JBQWdCc0UsTUFBTXRFLGFBQWEsQ0FBQ3VFLElBQUksQ0FBQ0Q7QUFDN0MsSUFBSXJFLDBCQUEwQnFFLE1BQU1yRSx1QkFBdUIsQ0FBQ3NFLElBQUksQ0FBQ0Q7QUFDakUsSUFBSXBFLGVBQWVvRSxNQUFNcEUsWUFBWSxDQUFDcUUsSUFBSSxDQUFDRDtBQUMzQyxJQUFJekUsY0FBY3lFLE1BQU16RSxXQUFXLENBQUMwRSxJQUFJLENBQUNEO0FBQ3pDLElBQUl2RSxjQUFjdUUsTUFBTXZFLFdBQVcsQ0FBQ3dFLElBQUksQ0FBQ0Q7QUFDekMsU0FBU0UsVUFBVW5PLEtBQUs7SUFDdEIsT0FBT0E7QUFDVDtBQUNBLFNBQVNvTyxjQUFjcE8sS0FBSztJQUMxQixPQUFPQTtBQUNUO0FBcUJFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLm1qcz9hNGY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy9lbnYudHNcbnZhciBOT1RISU5HID0gU3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIik7XG52YXIgRFJBRlRBQkxFID0gU3ltYm9sLmZvcihcImltbWVyLWRyYWZ0YWJsZVwiKTtcbnZhciBEUkFGVF9TVEFURSA9IFN5bWJvbC5mb3IoXCJpbW1lci1zdGF0ZVwiKTtcblxuLy8gc3JjL3V0aWxzL2Vycm9ycy50c1xudmFyIGVycm9ycyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFtcbiAgLy8gQWxsIGVycm9yIGNvZGVzLCBzdGFydGluZyBieSAwOlxuICBmdW5jdGlvbihwbHVnaW4pIHtcbiAgICByZXR1cm4gYFRoZSBwbHVnaW4gZm9yICcke3BsdWdpbn0nIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBcXGBlbmFibGUke3BsdWdpbn0oKVxcYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLmA7XG4gIH0sXG4gIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIGBwcm9kdWNlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGluZ3MgdGhhdCBhcmUgZHJhZnRhYmxlOiBwbGFpbiBvYmplY3RzLCBhcnJheXMsIE1hcCwgU2V0IG9yIGNsYXNzZXMgdGhhdCBhcmUgbWFya2VkIHdpdGggJ1tpbW1lcmFibGVdOiB0cnVlJy4gR290ICcke3RoaW5nfSdgO1xuICB9LFxuICBcIlRoaXMgb2JqZWN0IGhhcyBiZWVuIGZyb3plbiBhbmQgc2hvdWxkIG5vdCBiZSBtdXRhdGVkXCIsXG4gIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiICsgZGF0YTtcbiAgfSxcbiAgXCJBbiBpbW1lciBwcm9kdWNlciByZXR1cm5lZCBhIG5ldyB2YWx1ZSAqYW5kKiBtb2RpZmllZCBpdHMgZHJhZnQuIEVpdGhlciByZXR1cm4gYSBuZXcgdmFsdWUgKm9yKiBtb2RpZnkgdGhlIGRyYWZ0LlwiLFxuICBcIkltbWVyIGZvcmJpZHMgY2lyY3VsYXIgcmVmZXJlbmNlc1wiLFxuICBcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLFxuICBcIlRoZSB0aGlyZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZFwiLFxuICBcIkZpcnN0IGFyZ3VtZW50IHRvIGBjcmVhdGVEcmFmdGAgbXVzdCBiZSBhIHBsYWluIG9iamVjdCwgYW4gYXJyYXksIG9yIGFuIGltbWVyYWJsZSBvYmplY3RcIixcbiAgXCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsXG4gIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIGAnY3VycmVudCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YDtcbiAgfSxcbiAgXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICBcIk9iamVjdC5zZXRQcm90b3R5cGVPZigpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXG4gIFwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsXG4gIFwiSW1tZXIgb25seSBzdXBwb3J0cyBzZXR0aW5nIGFycmF5IGluZGljZXMgYW5kIHRoZSAnbGVuZ3RoJyBwcm9wZXJ0eVwiLFxuICBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBgJ29yaWdpbmFsJyBleHBlY3RzIGEgZHJhZnQsIGdvdDogJHt0aGluZ31gO1xuICB9XG4gIC8vIE5vdGU6IGlmIG1vcmUgZXJyb3JzIGFyZSBhZGRlZCwgdGhlIGVycm9yT2Zmc2V0IGluIFBhdGNoZXMudHMgc2hvdWxkIGJlIGluY3JlYXNlZFxuICAvLyBTZWUgUGF0Y2hlcy50cyBmb3IgYWRkaXRpb25hbCBlcnJvcnNcbl0gOiBbXTtcbmZ1bmN0aW9uIGRpZShlcnJvciwgLi4uYXJncykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgZSA9IGVycm9yc1tlcnJvcl07XG4gICAgY29uc3QgbXNnID0gdHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIiA/IGUuYXBwbHkobnVsbCwgYXJncykgOiBlO1xuICAgIHRocm93IG5ldyBFcnJvcihgW0ltbWVyXSAke21zZ31gKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFtJbW1lcl0gbWluaWZpZWQgZXJyb3IgbnI6ICR7ZXJyb3J9LiBGdWxsIGVycm9yIGF0OiBodHRwczovL2JpdC5seS8zY1hFS1dmYFxuICApO1xufVxuXG4vLyBzcmMvdXRpbHMvY29tbW9uLnRzXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5mdW5jdGlvbiBpc0RyYWZ0KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICEhdmFsdWVbRFJBRlRfU1RBVEVdO1xufVxuZnVuY3Rpb24gaXNEcmFmdGFibGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAhIXZhbHVlW0RSQUZUQUJMRV0gfHwgISF2YWx1ZS5jb25zdHJ1Y3Rvcj8uW0RSQUZUQUJMRV0gfHwgaXNNYXAodmFsdWUpIHx8IGlzU2V0KHZhbHVlKTtcbn1cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBDdG9yID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIGlmIChDdG9yID09PSBPYmplY3QpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSBcImZ1bmN0aW9uXCIgJiYgRnVuY3Rpb24udG9TdHJpbmcuY2FsbChDdG9yKSA9PT0gb2JqZWN0Q3RvclN0cmluZztcbn1cbmZ1bmN0aW9uIG9yaWdpbmFsKHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdCh2YWx1ZSkpXG4gICAgZGllKDE1LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZVtEUkFGVF9TVEFURV0uYmFzZV87XG59XG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcikge1xuICBpZiAoZ2V0QXJjaHR5cGUob2JqKSA9PT0gMCAvKiBPYmplY3QgKi8pIHtcbiAgICBSZWZsZWN0Lm93bktleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGl0ZXIoa2V5LCBvYmpba2V5XSwgb2JqKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmouZm9yRWFjaCgoZW50cnksIGluZGV4KSA9PiBpdGVyKGluZGV4LCBlbnRyeSwgb2JqKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFyY2h0eXBlKHRoaW5nKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpbmdbRFJBRlRfU1RBVEVdO1xuICByZXR1cm4gc3RhdGUgPyBzdGF0ZS50eXBlXyA6IEFycmF5LmlzQXJyYXkodGhpbmcpID8gMSAvKiBBcnJheSAqLyA6IGlzTWFwKHRoaW5nKSA/IDIgLyogTWFwICovIDogaXNTZXQodGhpbmcpID8gMyAvKiBTZXQgKi8gOiAwIC8qIE9iamVjdCAqLztcbn1cbmZ1bmN0aW9uIGhhcyh0aGluZywgcHJvcCkge1xuICByZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSAyIC8qIE1hcCAqLyA/IHRoaW5nLmhhcyhwcm9wKSA6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGluZywgcHJvcCk7XG59XG5mdW5jdGlvbiBnZXQodGhpbmcsIHByb3ApIHtcbiAgcmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gMiAvKiBNYXAgKi8gPyB0aGluZy5nZXQocHJvcCkgOiB0aGluZ1twcm9wXTtcbn1cbmZ1bmN0aW9uIHNldCh0aGluZywgcHJvcE9yT2xkVmFsdWUsIHZhbHVlKSB7XG4gIGNvbnN0IHQgPSBnZXRBcmNodHlwZSh0aGluZyk7XG4gIGlmICh0ID09PSAyIC8qIE1hcCAqLylcbiAgICB0aGluZy5zZXQocHJvcE9yT2xkVmFsdWUsIHZhbHVlKTtcbiAgZWxzZSBpZiAodCA9PT0gMyAvKiBTZXQgKi8pIHtcbiAgICB0aGluZy5hZGQodmFsdWUpO1xuICB9IGVsc2VcbiAgICB0aGluZ1twcm9wT3JPbGRWYWx1ZV0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuZnVuY3Rpb24gaXNNYXAodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBNYXA7XG59XG5mdW5jdGlvbiBpc1NldCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIFNldDtcbn1cbmZ1bmN0aW9uIGxhdGVzdChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuY29weV8gfHwgc3RhdGUuYmFzZV87XG59XG5mdW5jdGlvbiBzaGFsbG93Q29weShiYXNlLCBzdHJpY3QpIHtcbiAgaWYgKGlzTWFwKGJhc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoYmFzZSk7XG4gIH1cbiAgaWYgKGlzU2V0KGJhc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoYmFzZSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYmFzZSkpXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJhc2UpO1xuICBpZiAoIXN0cmljdCAmJiBpc1BsYWluT2JqZWN0KGJhc2UpKSB7XG4gICAgaWYgKCFnZXRQcm90b3R5cGVPZihiYXNlKSkge1xuICAgICAgY29uc3Qgb2JqID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIGJhc2UpO1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5iYXNlIH07XG4gIH1cbiAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhiYXNlKTtcbiAgZGVsZXRlIGRlc2NyaXB0b3JzW0RSQUZUX1NUQVRFXTtcbiAgbGV0IGtleXMgPSBSZWZsZWN0Lm93bktleXMoZGVzY3JpcHRvcnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IGRlc2MgPSBkZXNjcmlwdG9yc1trZXldO1xuICAgIGlmIChkZXNjLndyaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldClcbiAgICAgIGRlc2NyaXB0b3JzW2tleV0gPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIC8vIGNvdWxkIGxpdmUgd2l0aCAhIWRlc2Muc2V0IGFzIHdlbGwgaGVyZS4uLlxuICAgICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICAgIHZhbHVlOiBiYXNlW2tleV1cbiAgICAgIH07XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUoZ2V0UHJvdG90eXBlT2YoYmFzZSksIGRlc2NyaXB0b3JzKTtcbn1cbmZ1bmN0aW9uIGZyZWV6ZShvYmosIGRlZXAgPSBmYWxzZSkge1xuICBpZiAoaXNGcm96ZW4ob2JqKSB8fCBpc0RyYWZ0KG9iaikgfHwgIWlzRHJhZnRhYmxlKG9iaikpXG4gICAgcmV0dXJuIG9iajtcbiAgaWYgKGdldEFyY2h0eXBlKG9iaikgPiAxKSB7XG4gICAgb2JqLnNldCA9IG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zO1xuICB9XG4gIE9iamVjdC5mcmVlemUob2JqKTtcbiAgaWYgKGRlZXApXG4gICAgT2JqZWN0LmVudHJpZXMob2JqKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IGZyZWV6ZSh2YWx1ZSwgdHJ1ZSkpO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zKCkge1xuICBkaWUoMik7XG59XG5mdW5jdGlvbiBpc0Zyb3plbihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5pc0Zyb3plbihvYmopO1xufVxuXG4vLyBzcmMvdXRpbHMvcGx1Z2lucy50c1xudmFyIHBsdWdpbnMgPSB7fTtcbmZ1bmN0aW9uIGdldFBsdWdpbihwbHVnaW5LZXkpIHtcbiAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1twbHVnaW5LZXldO1xuICBpZiAoIXBsdWdpbikge1xuICAgIGRpZSgwLCBwbHVnaW5LZXkpO1xuICB9XG4gIHJldHVybiBwbHVnaW47XG59XG5mdW5jdGlvbiBsb2FkUGx1Z2luKHBsdWdpbktleSwgaW1wbGVtZW50YXRpb24pIHtcbiAgaWYgKCFwbHVnaW5zW3BsdWdpbktleV0pXG4gICAgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb247XG59XG5cbi8vIHNyYy9jb3JlL3Njb3BlLnRzXG52YXIgY3VycmVudFNjb3BlO1xuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICByZXR1cm4gY3VycmVudFNjb3BlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2NvcGUocGFyZW50XywgaW1tZXJfKSB7XG4gIHJldHVybiB7XG4gICAgZHJhZnRzXzogW10sXG4gICAgcGFyZW50XyxcbiAgICBpbW1lcl8sXG4gICAgLy8gV2hlbmV2ZXIgdGhlIG1vZGlmaWVkIGRyYWZ0IGNvbnRhaW5zIGEgZHJhZnQgZnJvbSBhbm90aGVyIHNjb3BlLCB3ZVxuICAgIC8vIG5lZWQgdG8gcHJldmVudCBhdXRvLWZyZWV6aW5nIHNvIHRoZSB1bm93bmVkIGRyYWZ0IGNhbiBiZSBmaW5hbGl6ZWQuXG4gICAgY2FuQXV0b0ZyZWV6ZV86IHRydWUsXG4gICAgdW5maW5hbGl6ZWREcmFmdHNfOiAwXG4gIH07XG59XG5mdW5jdGlvbiB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcikge1xuICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIik7XG4gICAgc2NvcGUucGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5pbnZlcnNlUGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyA9IHBhdGNoTGlzdGVuZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJldm9rZVNjb3BlKHNjb3BlKSB7XG4gIGxlYXZlU2NvcGUoc2NvcGUpO1xuICBzY29wZS5kcmFmdHNfLmZvckVhY2gocmV2b2tlRHJhZnQpO1xuICBzY29wZS5kcmFmdHNfID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGxlYXZlU2NvcGUoc2NvcGUpIHtcbiAgaWYgKHNjb3BlID09PSBjdXJyZW50U2NvcGUpIHtcbiAgICBjdXJyZW50U2NvcGUgPSBzY29wZS5wYXJlbnRfO1xuICB9XG59XG5mdW5jdGlvbiBlbnRlclNjb3BlKGltbWVyMikge1xuICByZXR1cm4gY3VycmVudFNjb3BlID0gY3JlYXRlU2NvcGUoY3VycmVudFNjb3BlLCBpbW1lcjIpO1xufVxuZnVuY3Rpb24gcmV2b2tlRHJhZnQoZHJhZnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGlmIChzdGF0ZS50eXBlXyA9PT0gMCAvKiBPYmplY3QgKi8gfHwgc3RhdGUudHlwZV8gPT09IDEgLyogQXJyYXkgKi8pXG4gICAgc3RhdGUucmV2b2tlXygpO1xuICBlbHNlXG4gICAgc3RhdGUucmV2b2tlZF8gPSB0cnVlO1xufVxuXG4vLyBzcmMvY29yZS9maW5hbGl6ZS50c1xuZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKSB7XG4gIHNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA9IHNjb3BlLmRyYWZ0c18ubGVuZ3RoO1xuICBjb25zdCBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfWzBdO1xuICBjb25zdCBpc1JlcGxhY2VkID0gcmVzdWx0ICE9PSB2b2lkIDAgJiYgcmVzdWx0ICE9PSBiYXNlRHJhZnQ7XG4gIGlmIChpc1JlcGxhY2VkKSB7XG4gICAgaWYgKGJhc2VEcmFmdFtEUkFGVF9TVEFURV0ubW9kaWZpZWRfKSB7XG4gICAgICByZXZva2VTY29wZShzY29wZSk7XG4gICAgICBkaWUoNCk7XG4gICAgfVxuICAgIGlmIChpc0RyYWZ0YWJsZShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgcmVzdWx0KTtcbiAgICAgIGlmICghc2NvcGUucGFyZW50XylcbiAgICAgICAgbWF5YmVGcmVlemUoc2NvcGUsIHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oXG4gICAgICAgIGJhc2VEcmFmdFtEUkFGVF9TVEFURV0uYmFzZV8sXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgc2NvcGUucGF0Y2hlc18sXG4gICAgICAgIHNjb3BlLmludmVyc2VQYXRjaGVzX1xuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIGJhc2VEcmFmdCwgW10pO1xuICB9XG4gIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgaWYgKHNjb3BlLnBhdGNoZXNfKSB7XG4gICAgc2NvcGUucGF0Y2hMaXN0ZW5lcl8oc2NvcGUucGF0Y2hlc18sIHNjb3BlLmludmVyc2VQYXRjaGVzXyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplKHJvb3RTY29wZSwgdmFsdWUsIHBhdGgpIHtcbiAgaWYgKGlzRnJvemVuKHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdO1xuICBpZiAoIXN0YXRlKSB7XG4gICAgZWFjaChcbiAgICAgIHZhbHVlLFxuICAgICAgKGtleSwgY2hpbGRWYWx1ZSkgPT4gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCB2YWx1ZSwga2V5LCBjaGlsZFZhbHVlLCBwYXRoKVxuICAgICk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChzdGF0ZS5zY29wZV8gIT09IHJvb3RTY29wZSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgbWF5YmVGcmVlemUocm9vdFNjb3BlLCBzdGF0ZS5iYXNlXywgdHJ1ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmJhc2VfO1xuICB9XG4gIGlmICghc3RhdGUuZmluYWxpemVkXykge1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xuICAgIHN0YXRlLnNjb3BlXy51bmZpbmFsaXplZERyYWZ0c18tLTtcbiAgICBjb25zdCByZXN1bHQgPSBzdGF0ZS5jb3B5XztcbiAgICBsZXQgcmVzdWx0RWFjaCA9IHJlc3VsdDtcbiAgICBsZXQgaXNTZXQyID0gZmFsc2U7XG4gICAgaWYgKHN0YXRlLnR5cGVfID09PSAzIC8qIFNldCAqLykge1xuICAgICAgcmVzdWx0RWFjaCA9IG5ldyBTZXQocmVzdWx0KTtcbiAgICAgIHJlc3VsdC5jbGVhcigpO1xuICAgICAgaXNTZXQyID0gdHJ1ZTtcbiAgICB9XG4gICAgZWFjaChcbiAgICAgIHJlc3VsdEVhY2gsXG4gICAgICAoa2V5LCBjaGlsZFZhbHVlKSA9PiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHJlc3VsdCwga2V5LCBjaGlsZFZhbHVlLCBwYXRoLCBpc1NldDIpXG4gICAgKTtcbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHJlc3VsdCwgZmFsc2UpO1xuICAgIGlmIChwYXRoICYmIHJvb3RTY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVBhdGNoZXNfKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcm9vdFNjb3BlLnBhdGNoZXNfLFxuICAgICAgICByb290U2NvcGUuaW52ZXJzZVBhdGNoZXNfXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGUuY29weV87XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgcGFyZW50U3RhdGUsIHRhcmdldE9iamVjdCwgcHJvcCwgY2hpbGRWYWx1ZSwgcm9vdFBhdGgsIHRhcmdldElzU2V0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY2hpbGRWYWx1ZSA9PT0gdGFyZ2V0T2JqZWN0KVxuICAgIGRpZSg1KTtcbiAgaWYgKGlzRHJhZnQoY2hpbGRWYWx1ZSkpIHtcbiAgICBjb25zdCBwYXRoID0gcm9vdFBhdGggJiYgcGFyZW50U3RhdGUgJiYgcGFyZW50U3RhdGUudHlwZV8gIT09IDMgLyogU2V0ICovICYmIC8vIFNldCBvYmplY3RzIGFyZSBhdG9taWMgc2luY2UgdGhleSBoYXZlIG5vIGtleXMuXG4gICAgIWhhcyhwYXJlbnRTdGF0ZS5hc3NpZ25lZF8sIHByb3ApID8gcm9vdFBhdGguY29uY2F0KHByb3ApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlcyA9IGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSwgcGF0aCk7XG4gICAgc2V0KHRhcmdldE9iamVjdCwgcHJvcCwgcmVzKTtcbiAgICBpZiAoaXNEcmFmdChyZXMpKSB7XG4gICAgICByb290U2NvcGUuY2FuQXV0b0ZyZWV6ZV8gPSBmYWxzZTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0YXJnZXRJc1NldCkge1xuICAgIHRhcmdldE9iamVjdC5hZGQoY2hpbGRWYWx1ZSk7XG4gIH1cbiAgaWYgKGlzRHJhZnRhYmxlKGNoaWxkVmFsdWUpICYmICFpc0Zyb3plbihjaGlsZFZhbHVlKSkge1xuICAgIGlmICghcm9vdFNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiByb290U2NvcGUudW5maW5hbGl6ZWREcmFmdHNfIDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaW5hbGl6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpO1xuICAgIGlmICgoIXBhcmVudFN0YXRlIHx8ICFwYXJlbnRTdGF0ZS5zY29wZV8ucGFyZW50XykgJiYgdHlwZW9mIHByb3AgIT09IFwic3ltYm9sXCIgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldE9iamVjdCwgcHJvcCkpXG4gICAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBtYXliZUZyZWV6ZShzY29wZSwgdmFsdWUsIGRlZXAgPSBmYWxzZSkge1xuICBpZiAoIXNjb3BlLnBhcmVudF8gJiYgc2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHNjb3BlLmNhbkF1dG9GcmVlemVfKSB7XG4gICAgZnJlZXplKHZhbHVlLCBkZWVwKTtcbiAgfVxufVxuXG4vLyBzcmMvY29yZS9wcm94eS50c1xuZnVuY3Rpb24gY3JlYXRlUHJveHlQcm94eShiYXNlLCBwYXJlbnQpIHtcbiAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSk7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHR5cGVfOiBpc0FycmF5ID8gMSAvKiBBcnJheSAqLyA6IDAgLyogT2JqZWN0ICovLFxuICAgIC8vIFRyYWNrIHdoaWNoIHByb2R1Y2UgY2FsbCB0aGlzIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAvLyBUcnVlIGZvciBib3RoIHNoYWxsb3cgYW5kIGRlZXAgY2hhbmdlcy5cbiAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgIC8vIFVzZWQgZHVyaW5nIGZpbmFsaXphdGlvbi5cbiAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAvLyBUcmFjayB3aGljaCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBhc3NpZ25lZCAodHJ1ZSkgb3IgZGVsZXRlZCAoZmFsc2UpLlxuICAgIGFzc2lnbmVkXzoge30sXG4gICAgLy8gVGhlIHBhcmVudCBkcmFmdCBzdGF0ZS5cbiAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgLy8gVGhlIGJhc2Ugc3RhdGUuXG4gICAgYmFzZV86IGJhc2UsXG4gICAgLy8gVGhlIGJhc2UgcHJveHkuXG4gICAgZHJhZnRfOiBudWxsLFxuICAgIC8vIHNldCBiZWxvd1xuICAgIC8vIFRoZSBiYXNlIGNvcHkgd2l0aCBhbnkgdXBkYXRlZCB2YWx1ZXMuXG4gICAgY29weV86IG51bGwsXG4gICAgLy8gQ2FsbGVkIGJ5IHRoZSBgcHJvZHVjZWAgZnVuY3Rpb24uXG4gICAgcmV2b2tlXzogbnVsbCxcbiAgICBpc01hbnVhbF86IGZhbHNlXG4gIH07XG4gIGxldCB0YXJnZXQgPSBzdGF0ZTtcbiAgbGV0IHRyYXBzID0gb2JqZWN0VHJhcHM7XG4gIGlmIChpc0FycmF5KSB7XG4gICAgdGFyZ2V0ID0gW3N0YXRlXTtcbiAgICB0cmFwcyA9IGFycmF5VHJhcHM7XG4gIH1cbiAgY29uc3QgeyByZXZva2UsIHByb3h5IH0gPSBQcm94eS5yZXZvY2FibGUodGFyZ2V0LCB0cmFwcyk7XG4gIHN0YXRlLmRyYWZ0XyA9IHByb3h5O1xuICBzdGF0ZS5yZXZva2VfID0gcmV2b2tlO1xuICByZXR1cm4gcHJveHk7XG59XG52YXIgb2JqZWN0VHJhcHMgPSB7XG4gIGdldChzdGF0ZSwgcHJvcCkge1xuICAgIGlmIChwcm9wID09PSBEUkFGVF9TVEFURSlcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBjb25zdCBzb3VyY2UgPSBsYXRlc3Qoc3RhdGUpO1xuICAgIGlmICghaGFzKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgIHJldHVybiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzb3VyY2VbcHJvcF07XG4gICAgaWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApKSB7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV9bcHJvcF0gPSBjcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGhhcyhzdGF0ZSwgcHJvcCkge1xuICAgIHJldHVybiBwcm9wIGluIGxhdGVzdChzdGF0ZSk7XG4gIH0sXG4gIG93bktleXMoc3RhdGUpIHtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKGxhdGVzdChzdGF0ZSkpO1xuICB9LFxuICBzZXQoc3RhdGUsIHByb3AsIHZhbHVlKSB7XG4gICAgY29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8obGF0ZXN0KHN0YXRlKSwgcHJvcCk7XG4gICAgaWYgKGRlc2M/LnNldCkge1xuICAgICAgZGVzYy5zZXQuY2FsbChzdGF0ZS5kcmFmdF8sIHZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgICAgY29uc3QgY3VycmVudDIgPSBwZWVrKGxhdGVzdChzdGF0ZSksIHByb3ApO1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gY3VycmVudDI/LltEUkFGVF9TVEFURV07XG4gICAgICBpZiAoY3VycmVudFN0YXRlICYmIGN1cnJlbnRTdGF0ZS5iYXNlXyA9PT0gdmFsdWUpIHtcbiAgICAgICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzKHZhbHVlLCBjdXJyZW50MikgJiYgKHZhbHVlICE9PSB2b2lkIDAgfHwgaGFzKHN0YXRlLmJhc2VfLCBwcm9wKSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29weV9bcHJvcF0gPT09IHZhbHVlICYmIC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIG5ldyBwcm9wcyB3aXRoIHZhbHVlICd1bmRlZmluZWQnXG4gICAgKHZhbHVlICE9PSB2b2lkIDAgfHwgcHJvcCBpbiBzdGF0ZS5jb3B5XykgfHwgLy8gc3BlY2lhbCBjYXNlOiBOYU5cbiAgICBOdW1iZXIuaXNOYU4odmFsdWUpICYmIE51bWJlci5pc05hTihzdGF0ZS5jb3B5X1twcm9wXSkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBzdGF0ZS5jb3B5X1twcm9wXSA9IHZhbHVlO1xuICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5KHN0YXRlLCBwcm9wKSB7XG4gICAgaWYgKHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApICE9PSB2b2lkIDAgfHwgcHJvcCBpbiBzdGF0ZS5iYXNlXykge1xuICAgICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gZmFsc2U7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5hc3NpZ25lZF9bcHJvcF07XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3B5Xykge1xuICAgICAgZGVsZXRlIHN0YXRlLmNvcHlfW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gTm90ZTogV2UgbmV2ZXIgY29lcmNlIGBkZXNjLnZhbHVlYCBpbnRvIGFuIEltbWVyIGRyYWZ0LCBiZWNhdXNlIHdlIGNhbid0IG1ha2VcbiAgLy8gdGhlIHNhbWUgZ3VhcmFudGVlIGluIEVTNSBtb2RlLlxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3RhdGUsIHByb3ApIHtcbiAgICBjb25zdCBvd25lciA9IGxhdGVzdChzdGF0ZSk7XG4gICAgY29uc3QgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG93bmVyLCBwcm9wKTtcbiAgICBpZiAoIWRlc2MpXG4gICAgICByZXR1cm4gZGVzYztcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHN0YXRlLnR5cGVfICE9PSAxIC8qIEFycmF5ICovIHx8IHByb3AgIT09IFwibGVuZ3RoXCIsXG4gICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICB2YWx1ZTogb3duZXJbcHJvcF1cbiAgICB9O1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICBkaWUoMTEpO1xuICB9LFxuICBnZXRQcm90b3R5cGVPZihzdGF0ZSkge1xuICAgIHJldHVybiBnZXRQcm90b3R5cGVPZihzdGF0ZS5iYXNlXyk7XG4gIH0sXG4gIHNldFByb3RvdHlwZU9mKCkge1xuICAgIGRpZSgxMik7XG4gIH1cbn07XG52YXIgYXJyYXlUcmFwcyA9IHt9O1xuZWFjaChvYmplY3RUcmFwcywgKGtleSwgZm4pID0+IHtcbiAgYXJyYXlUcmFwc1trZXldID0gZnVuY3Rpb24oKSB7XG4gICAgYXJndW1lbnRzWzBdID0gYXJndW1lbnRzWzBdWzBdO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5hcnJheVRyYXBzLmRlbGV0ZVByb3BlcnR5ID0gZnVuY3Rpb24oc3RhdGUsIHByb3ApIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc05hTihwYXJzZUludChwcm9wKSkpXG4gICAgZGllKDEzKTtcbiAgcmV0dXJuIGFycmF5VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGUsIHByb3AsIHZvaWQgMCk7XG59O1xuYXJyYXlUcmFwcy5zZXQgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcm9wICE9PSBcImxlbmd0aFwiICYmIGlzTmFOKHBhcnNlSW50KHByb3ApKSlcbiAgICBkaWUoMTQpO1xuICByZXR1cm4gb2JqZWN0VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGVbMF0sIHByb3AsIHZhbHVlLCBzdGF0ZVswXSk7XG59O1xuZnVuY3Rpb24gcGVlayhkcmFmdCwgcHJvcCkge1xuICBjb25zdCBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgY29uc3Qgc291cmNlID0gc3RhdGUgPyBsYXRlc3Qoc3RhdGUpIDogZHJhZnQ7XG4gIHJldHVybiBzb3VyY2VbcHJvcF07XG59XG5mdW5jdGlvbiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKSB7XG4gIGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCk7XG4gIHJldHVybiBkZXNjID8gYHZhbHVlYCBpbiBkZXNjID8gZGVzYy52YWx1ZSA6IChcbiAgICAvLyBUaGlzIGlzIGEgdmVyeSBzcGVjaWFsIGNhc2UsIGlmIHRoZSBwcm9wIGlzIGEgZ2V0dGVyIGRlZmluZWQgYnkgdGhlXG4gICAgLy8gcHJvdG90eXBlLCB3ZSBzaG91bGQgaW52b2tlIGl0IHdpdGggdGhlIGRyYWZ0IGFzIGNvbnRleHQhXG4gICAgZGVzYy5nZXQ/LmNhbGwoc3RhdGUuZHJhZnRfKVxuICApIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhzb3VyY2UsIHByb3ApIHtcbiAgaWYgKCEocHJvcCBpbiBzb3VyY2UpKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGxldCBwcm90byA9IGdldFByb3RvdHlwZU9mKHNvdXJjZSk7XG4gIHdoaWxlIChwcm90bykge1xuICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKTtcbiAgICBpZiAoZGVzYylcbiAgICAgIHJldHVybiBkZXNjO1xuICAgIHByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBtYXJrQ2hhbmdlZChzdGF0ZSkge1xuICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgIHN0YXRlLm1vZGlmaWVkXyA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnBhcmVudF8pIHtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlLnBhcmVudF8pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZUNvcHkoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgIHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoXG4gICAgICBzdGF0ZS5iYXNlXyxcbiAgICAgIHN0YXRlLnNjb3BlXy5pbW1lcl8udXNlU3RyaWN0U2hhbGxvd0NvcHlfXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvY29yZS9pbW1lckNsYXNzLnRzXG52YXIgSW1tZXIyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdHJ1ZTtcbiAgICB0aGlzLnVzZVN0cmljdFNoYWxsb3dDb3B5XyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxuICAgICAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xuICAgICAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxuICAgICAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXG4gICAgICpcbiAgICAgKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcbiAgICAgKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxuICAgICAqXG4gICAgICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXG4gICAgICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVjaXBlIC0gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb3h5IG9mIHRoZSBiYXNlIHN0YXRlIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB3aGljaCBjYW4gYmUgZnJlZWx5IG1vZGlmaWVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGF0Y2hMaXN0ZW5lciAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdGhlIHBhdGNoZXMgcHJvZHVjZWQgaGVyZVxuICAgICAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxuICAgICAqL1xuICAgIHRoaXMucHJvZHVjZSA9IChiYXNlLCByZWNpcGUsIHBhdGNoTGlzdGVuZXIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBkZWZhdWx0QmFzZSA9IHJlY2lwZTtcbiAgICAgICAgcmVjaXBlID0gYmFzZTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjdXJyaWVkUHJvZHVjZShiYXNlMiA9IGRlZmF1bHRCYXNlLCAuLi5hcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYucHJvZHVjZShiYXNlMiwgKGRyYWZ0KSA9PiByZWNpcGUuY2FsbCh0aGlzLCBkcmFmdCwgLi4uYXJncykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZGllKDYpO1xuICAgICAgaWYgKHBhdGNoTGlzdGVuZXIgIT09IHZvaWQgMCAmJiB0eXBlb2YgcGF0Y2hMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBkaWUoNyk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgaWYgKGlzRHJhZnRhYmxlKGJhc2UpKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gZW50ZXJTY29wZSh0aGlzKTtcbiAgICAgICAgY29uc3QgcHJveHkgPSBjcmVhdGVQcm94eShiYXNlLCB2b2lkIDApO1xuICAgICAgICBsZXQgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlY2lwZShwcm94eSk7XG4gICAgICAgICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoaGFzRXJyb3IpXG4gICAgICAgICAgICByZXZva2VTY29wZShzY29wZSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGVhdmVTY29wZShzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWJhc2UgfHwgdHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVjaXBlKGJhc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gTk9USElORylcbiAgICAgICAgICByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGlmICh0aGlzLmF1dG9GcmVlemVfKVxuICAgICAgICAgIGZyZWV6ZShyZXN1bHQsIHRydWUpO1xuICAgICAgICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgICAgICAgIGNvbnN0IHAgPSBbXTtcbiAgICAgICAgICBjb25zdCBpcCA9IFtdO1xuICAgICAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGJhc2UsIHJlc3VsdCwgcCwgaXApO1xuICAgICAgICAgIHBhdGNoTGlzdGVuZXIocCwgaXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZGllKDEsIGJhc2UpO1xuICAgIH07XG4gICAgdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMgPSAoYmFzZSwgcmVjaXBlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gKHN0YXRlLCAuLi5hcmdzKSA9PiB0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyhzdGF0ZSwgKGRyYWZ0KSA9PiBiYXNlKGRyYWZ0LCAuLi5hcmdzKSk7XG4gICAgICB9XG4gICAgICBsZXQgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXM7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnByb2R1Y2UoYmFzZSwgcmVjaXBlLCAocCwgaXApID0+IHtcbiAgICAgICAgcGF0Y2hlcyA9IHA7XG4gICAgICAgIGludmVyc2VQYXRjaGVzID0gaXA7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc107XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZz8uYXV0b0ZyZWV6ZSA9PT0gXCJib29sZWFuXCIpXG4gICAgICB0aGlzLnNldEF1dG9GcmVlemUoY29uZmlnLmF1dG9GcmVlemUpO1xuICAgIGlmICh0eXBlb2YgY29uZmlnPy51c2VTdHJpY3RTaGFsbG93Q29weSA9PT0gXCJib29sZWFuXCIpXG4gICAgICB0aGlzLnNldFVzZVN0cmljdFNoYWxsb3dDb3B5KGNvbmZpZy51c2VTdHJpY3RTaGFsbG93Q29weSk7XG4gIH1cbiAgY3JlYXRlRHJhZnQoYmFzZSkge1xuICAgIGlmICghaXNEcmFmdGFibGUoYmFzZSkpXG4gICAgICBkaWUoOCk7XG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpXG4gICAgICBiYXNlID0gY3VycmVudChiYXNlKTtcbiAgICBjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgY29uc3QgcHJveHkgPSBjcmVhdGVQcm94eShiYXNlLCB2b2lkIDApO1xuICAgIHByb3h5W0RSQUZUX1NUQVRFXS5pc01hbnVhbF8gPSB0cnVlO1xuICAgIGxlYXZlU2NvcGUoc2NvcGUpO1xuICAgIHJldHVybiBwcm94eTtcbiAgfVxuICBmaW5pc2hEcmFmdChkcmFmdCwgcGF0Y2hMaXN0ZW5lcikge1xuICAgIGNvbnN0IHN0YXRlID0gZHJhZnQgJiYgZHJhZnRbRFJBRlRfU1RBVEVdO1xuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmlzTWFudWFsXylcbiAgICAgIGRpZSg5KTtcbiAgICBjb25zdCB7IHNjb3BlXzogc2NvcGUgfSA9IHN0YXRlO1xuICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcbiAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdCh2b2lkIDAsIHNjb3BlKTtcbiAgfVxuICAvKipcbiAgICogUGFzcyB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZnJlZXplIGFsbCBjb3BpZXMgY3JlYXRlZCBieSBJbW1lci5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYXV0by1mcmVlemluZyBpcyBlbmFibGVkLlxuICAgKi9cbiAgc2V0QXV0b0ZyZWV6ZSh2YWx1ZSkge1xuICAgIHRoaXMuYXV0b0ZyZWV6ZV8gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUGFzcyB0cnVlIHRvIGVuYWJsZSBzdHJpY3Qgc2hhbGxvdyBjb3B5LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpbW1lciBkb2VzIG5vdCBjb3B5IHRoZSBvYmplY3QgZGVzY3JpcHRvcnMgc3VjaCBhcyBnZXR0ZXIsIHNldHRlciBhbmQgbm9uLWVudW1yYWJsZSBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkodmFsdWUpIHtcbiAgICB0aGlzLnVzZVN0cmljdFNoYWxsb3dDb3B5XyA9IHZhbHVlO1xuICB9XG4gIGFwcGx5UGF0Y2hlcyhiYXNlLCBwYXRjaGVzKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gcGF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwICYmIHBhdGNoLm9wID09PSBcInJlcGxhY2VcIikge1xuICAgICAgICBiYXNlID0gcGF0Y2gudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBwYXRjaGVzID0gcGF0Y2hlcy5zbGljZShpICsgMSk7XG4gICAgfVxuICAgIGNvbnN0IGFwcGx5UGF0Y2hlc0ltcGwgPSBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmFwcGx5UGF0Y2hlc187XG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpIHtcbiAgICAgIHJldHVybiBhcHBseVBhdGNoZXNJbXBsKGJhc2UsIHBhdGNoZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9kdWNlKFxuICAgICAgYmFzZSxcbiAgICAgIChkcmFmdCkgPT4gYXBwbHlQYXRjaGVzSW1wbChkcmFmdCwgcGF0Y2hlcylcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlUHJveHkodmFsdWUsIHBhcmVudCkge1xuICBjb25zdCBkcmFmdCA9IGlzTWFwKHZhbHVlKSA/IGdldFBsdWdpbihcIk1hcFNldFwiKS5wcm94eU1hcF8odmFsdWUsIHBhcmVudCkgOiBpc1NldCh2YWx1ZSkgPyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlTZXRfKHZhbHVlLCBwYXJlbnQpIDogY3JlYXRlUHJveHlQcm94eSh2YWx1ZSwgcGFyZW50KTtcbiAgY29uc3Qgc2NvcGUgPSBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCk7XG4gIHNjb3BlLmRyYWZ0c18ucHVzaChkcmFmdCk7XG4gIHJldHVybiBkcmFmdDtcbn1cblxuLy8gc3JjL2NvcmUvY3VycmVudC50c1xuZnVuY3Rpb24gY3VycmVudCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnQodmFsdWUpKVxuICAgIGRpZSgxMCwgdmFsdWUpO1xuICByZXR1cm4gY3VycmVudEltcGwodmFsdWUpO1xufVxuZnVuY3Rpb24gY3VycmVudEltcGwodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0YWJsZSh2YWx1ZSkgfHwgaXNGcm96ZW4odmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgY29uc3Qgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07XG4gIGxldCBjb3B5O1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXylcbiAgICAgIHJldHVybiBzdGF0ZS5iYXNlXztcbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZTtcbiAgICBjb3B5ID0gc2hhbGxvd0NvcHkodmFsdWUsIHN0YXRlLnNjb3BlXy5pbW1lcl8udXNlU3RyaWN0U2hhbGxvd0NvcHlfKTtcbiAgfSBlbHNlIHtcbiAgICBjb3B5ID0gc2hhbGxvd0NvcHkodmFsdWUsIHRydWUpO1xuICB9XG4gIGVhY2goY29weSwgKGtleSwgY2hpbGRWYWx1ZSkgPT4ge1xuICAgIHNldChjb3B5LCBrZXksIGN1cnJlbnRJbXBsKGNoaWxkVmFsdWUpKTtcbiAgfSk7XG4gIGlmIChzdGF0ZSkge1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gY29weTtcbn1cblxuLy8gc3JjL3BsdWdpbnMvcGF0Y2hlcy50c1xuZnVuY3Rpb24gZW5hYmxlUGF0Y2hlcygpIHtcbiAgY29uc3QgZXJyb3JPZmZzZXQgPSAxNjtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgJ1NldHMgY2Fubm90IGhhdmUgXCJyZXBsYWNlXCIgcGF0Y2hlcy4nLFxuICAgICAgZnVuY3Rpb24ob3ApIHtcbiAgICAgICAgcmV0dXJuIFwiVW5zdXBwb3J0ZWQgcGF0Y2ggb3BlcmF0aW9uOiBcIiArIG9wO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IGFwcGx5IHBhdGNoLCBwYXRoIGRvZXNuJ3QgcmVzb2x2ZTogXCIgKyBwYXRoO1xuICAgICAgfSxcbiAgICAgIFwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBSRVBMQUNFID0gXCJyZXBsYWNlXCI7XG4gIGNvbnN0IEFERCA9IFwiYWRkXCI7XG4gIGNvbnN0IFJFTU9WRSA9IFwicmVtb3ZlXCI7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc18oc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcbiAgICAgIGNhc2UgMCAvKiBPYmplY3QgKi86XG4gICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICAgIHBhdGNoZXMsXG4gICAgICAgICAgaW52ZXJzZVBhdGNoZXNcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgMSAvKiBBcnJheSAqLzpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlU2V0UGF0Y2hlcyhcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBiYXNlUGF0aCxcbiAgICAgICAgICBwYXRjaGVzLFxuICAgICAgICAgIGludmVyc2VQYXRjaGVzXG4gICAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBsZXQgeyBiYXNlXywgYXNzaWduZWRfIH0gPSBzdGF0ZTtcbiAgICBsZXQgY29weV8gPSBzdGF0ZS5jb3B5XztcbiAgICBpZiAoY29weV8ubGVuZ3RoIDwgYmFzZV8ubGVuZ3RoKSB7XG4gICAgICA7XG4gICAgICBbYmFzZV8sIGNvcHlfXSA9IFtjb3B5XywgYmFzZV9dO1xuICAgICAgW3BhdGNoZXMsIGludmVyc2VQYXRjaGVzXSA9IFtpbnZlcnNlUGF0Y2hlcywgcGF0Y2hlc107XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhc3NpZ25lZF9baV0gJiYgY29weV9baV0gIT09IGJhc2VfW2ldKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICAgIC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tpXSlcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGJhc2VfW2ldKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGJhc2VfLmxlbmd0aDsgaSA8IGNvcHlfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogQURELFxuICAgICAgICBwYXRoLFxuICAgICAgICAvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tpXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gY29weV8ubGVuZ3RoIC0gMTsgYmFzZV8ubGVuZ3RoIDw9IGk7IC0taSkge1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgIHBhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIGNvbnN0IHsgYmFzZV8sIGNvcHlfIH0gPSBzdGF0ZTtcbiAgICBlYWNoKHN0YXRlLmFzc2lnbmVkXywgKGtleSwgYXNzaWduZWRWYWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gZ2V0KGJhc2VfLCBrZXkpO1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXQoY29weV8sIGtleSk7XG4gICAgICBjb25zdCBvcCA9ICFhc3NpZ25lZFZhbHVlID8gUkVNT1ZFIDogaGFzKGJhc2VfLCBrZXkpID8gUkVQTEFDRSA6IEFERDtcbiAgICAgIGlmIChvcmlnVmFsdWUgPT09IHZhbHVlICYmIG9wID09PSBSRVBMQUNFKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KGtleSk7XG4gICAgICBwYXRjaGVzLnB1c2gob3AgPT09IFJFTU9WRSA/IHsgb3AsIHBhdGggfSA6IHsgb3AsIHBhdGgsIHZhbHVlIH0pO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaChcbiAgICAgICAgb3AgPT09IEFERCA/IHsgb3A6IFJFTU9WRSwgcGF0aCB9IDogb3AgPT09IFJFTU9WRSA/IHsgb3A6IEFERCwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSkgfSA6IHsgb3A6IFJFUExBQ0UsIHBhdGgsIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVTZXRQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBsZXQgeyBiYXNlXywgY29weV8gfSA9IHN0YXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBiYXNlXy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFjb3B5Xy5oYXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBBREQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgICBpID0gMDtcbiAgICBjb3B5Xy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFiYXNlXy5oYXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogQURELFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZVZhbHVlLCByZXBsYWNlbWVudCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiByZXBsYWNlbWVudCA9PT0gTk9USElORyA/IHZvaWQgMCA6IHJlcGxhY2VtZW50XG4gICAgfSk7XG4gICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogUkVQTEFDRSxcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgdmFsdWU6IGJhc2VWYWx1ZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5UGF0Y2hlc18oZHJhZnQsIHBhdGNoZXMpIHtcbiAgICBwYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICBjb25zdCB7IHBhdGgsIG9wIH0gPSBwYXRjaDtcbiAgICAgIGxldCBiYXNlID0gZHJhZnQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSBnZXRBcmNodHlwZShiYXNlKTtcbiAgICAgICAgbGV0IHAgPSBwYXRoW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHAgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBwID0gXCJcIiArIHA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwYXJlbnRUeXBlID09PSAwIC8qIE9iamVjdCAqLyB8fCBwYXJlbnRUeXBlID09PSAxIC8qIEFycmF5ICovKSAmJiAocCA9PT0gXCJfX3Byb3RvX19cIiB8fCBwID09PSBcImNvbnN0cnVjdG9yXCIpKVxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDMpO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiBwID09PSBcInByb3RvdHlwZVwiKVxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDMpO1xuICAgICAgICBiYXNlID0gZ2V0KGJhc2UsIHApO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMiwgcGF0aC5qb2luKFwiL1wiKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUocGF0Y2gudmFsdWUpO1xuICAgICAgY29uc3Qga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIFJFUExBQ0U6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBBREQ6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogQXJyYXkgKi86XG4gICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IFwiLVwiID8gYmFzZS5wdXNoKHZhbHVlKSA6IGJhc2Uuc3BsaWNlKGtleSwgMCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVNT1ZFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIEFycmF5ICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNYXAgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKHBhdGNoLnZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBkZWxldGUgYmFzZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAxLCBvcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRyYWZ0O1xuICB9XG4gIGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShvYmopKVxuICAgICAgcmV0dXJuIG9iajtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKVxuICAgICAgcmV0dXJuIG9iai5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSk7XG4gICAgaWYgKGlzTWFwKG9iaikpXG4gICAgICByZXR1cm4gbmV3IE1hcChcbiAgICAgICAgQXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoKFtrLCB2XSkgPT4gW2ssIGRlZXBDbG9uZVBhdGNoVmFsdWUodildKVxuICAgICAgKTtcbiAgICBpZiAoaXNTZXQob2JqKSlcbiAgICAgIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20ob2JqKS5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSkpO1xuICAgIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKVxuICAgICAgY2xvbmVkW2tleV0gPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9ialtrZXldKTtcbiAgICBpZiAoaGFzKG9iaiwgRFJBRlRBQkxFKSlcbiAgICAgIGNsb25lZFtEUkFGVEFCTEVdID0gb2JqW0RSQUZUQUJMRV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBmdW5jdGlvbiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvYmopIHtcbiAgICBpZiAoaXNEcmFmdChvYmopKSB7XG4gICAgICByZXR1cm4gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIG9iajtcbiAgfVxuICBsb2FkUGx1Z2luKFwiUGF0Y2hlc1wiLCB7XG4gICAgYXBwbHlQYXRjaGVzXyxcbiAgICBnZW5lcmF0ZVBhdGNoZXNfLFxuICAgIGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzX1xuICB9KTtcbn1cblxuLy8gc3JjL3BsdWdpbnMvbWFwc2V0LnRzXG5mdW5jdGlvbiBlbmFibGVNYXBTZXQoKSB7XG4gIGNsYXNzIERyYWZ0TWFwIGV4dGVuZHMgTWFwIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuICAgICAgICB0eXBlXzogMiAvKiBNYXAgKi8sXG4gICAgICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAgICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgICAgICBjb3B5Xzogdm9pZCAwLFxuICAgICAgICBhc3NpZ25lZF86IHZvaWQgMCxcbiAgICAgICAgYmFzZV86IHRhcmdldCxcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxuICAgICAgICBpc01hbnVhbF86IGZhbHNlLFxuICAgICAgICByZXZva2VkXzogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuaGFzKGtleSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmICghbGF0ZXN0KHN0YXRlKS5oYXMoa2V5KSB8fCBsYXRlc3Qoc3RhdGUpLmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuYmFzZV8uaGFzKGtleSkpIHtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmNvcHlfLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBlYWNoKHN0YXRlLmJhc2VfLCAoa2V5KSA9PiB7XG4gICAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBsYXRlc3Qoc3RhdGUpLmZvckVhY2goKF92YWx1ZSwga2V5LCBfbWFwKSA9PiB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgdGhpcy5nZXQoa2V5KSwga2V5LCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gbGF0ZXN0KHN0YXRlKS5nZXQoa2V5KTtcbiAgICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSBzdGF0ZS5iYXNlXy5nZXQoa2V5KSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCBkcmFmdCk7XG4gICAgICByZXR1cm4gZHJhZnQ7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gdGhpcy52YWx1ZXMoKSxcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHIuZG9uZSlcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB0aGlzLmVudHJpZXMoKSxcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHIuZG9uZSlcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IFtyLnZhbHVlLCB2YWx1ZV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBbKERSQUZUX1NUQVRFLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJveHlNYXBfKHRhcmdldCwgcGFyZW50KSB7XG4gICAgcmV0dXJuIG5ldyBEcmFmdE1hcCh0YXJnZXQsIHBhcmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJlcGFyZU1hcENvcHkoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RhdGUuY29weV8gPSBuZXcgTWFwKHN0YXRlLmJhc2VfKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRHJhZnRTZXQgZXh0ZW5kcyBTZXQge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpc1tEUkFGVF9TVEFURV0gPSB7XG4gICAgICAgIHR5cGVfOiAzIC8qIFNldCAqLyxcbiAgICAgICAgcGFyZW50XzogcGFyZW50LFxuICAgICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgICAgIGNvcHlfOiB2b2lkIDAsXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXG4gICAgICAgIGRyYWZ0XzogdGhpcyxcbiAgICAgICAgZHJhZnRzXzogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgcmV2b2tlZF86IGZhbHNlLFxuICAgICAgICBpc01hbnVhbF86IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgfVxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5iYXNlXy5oYXModmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmNvcHlfLmhhcyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSAmJiBzdGF0ZS5jb3B5Xy5oYXMoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuY29weV8uYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmRlbGV0ZSh2YWx1ZSkgfHwgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSA/IHN0YXRlLmNvcHlfLmRlbGV0ZShzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpIDogKFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmYWxzZVxuICAgICAgKSk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG4gICAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy52YWx1ZXMoKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmVudHJpZXMoKTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICAgIH1cbiAgICBbKERSQUZUX1NUQVRFLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNiLCB0aGlzQXJnKSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMudmFsdWVzKCk7XG4gICAgICBsZXQgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgcmVzdWx0LnZhbHVlLCB0aGlzKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm94eVNldF8odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICByZXR1cm4gbmV3IERyYWZ0U2V0KHRhcmdldCwgcGFyZW50KTtcbiAgfVxuICBmdW5jdGlvbiBwcmVwYXJlU2V0Q29weShzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgIHN0YXRlLmNvcHlfID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHN0YXRlLmJhc2VfLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICBjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gICAgICAgICAgc3RhdGUuZHJhZnRzXy5zZXQodmFsdWUsIGRyYWZ0KTtcbiAgICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQoZHJhZnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmNvcHlfLmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUucmV2b2tlZF8pXG4gICAgICBkaWUoMywgSlNPTi5zdHJpbmdpZnkobGF0ZXN0KHN0YXRlKSkpO1xuICB9XG4gIGxvYWRQbHVnaW4oXCJNYXBTZXRcIiwgeyBwcm94eU1hcF8sIHByb3h5U2V0XyB9KTtcbn1cblxuLy8gc3JjL2ltbWVyLnRzXG52YXIgaW1tZXIgPSBuZXcgSW1tZXIyKCk7XG52YXIgcHJvZHVjZSA9IGltbWVyLnByb2R1Y2U7XG52YXIgcHJvZHVjZVdpdGhQYXRjaGVzID0gaW1tZXIucHJvZHVjZVdpdGhQYXRjaGVzLmJpbmQoXG4gIGltbWVyXG4pO1xudmFyIHNldEF1dG9GcmVlemUgPSBpbW1lci5zZXRBdXRvRnJlZXplLmJpbmQoaW1tZXIpO1xudmFyIHNldFVzZVN0cmljdFNoYWxsb3dDb3B5ID0gaW1tZXIuc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkuYmluZChpbW1lcik7XG52YXIgYXBwbHlQYXRjaGVzID0gaW1tZXIuYXBwbHlQYXRjaGVzLmJpbmQoaW1tZXIpO1xudmFyIGNyZWF0ZURyYWZ0ID0gaW1tZXIuY3JlYXRlRHJhZnQuYmluZChpbW1lcik7XG52YXIgZmluaXNoRHJhZnQgPSBpbW1lci5maW5pc2hEcmFmdC5iaW5kKGltbWVyKTtcbmZ1bmN0aW9uIGNhc3REcmFmdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjYXN0SW1tdXRhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCB7XG4gIEltbWVyMiBhcyBJbW1lcixcbiAgYXBwbHlQYXRjaGVzLFxuICBjYXN0RHJhZnQsXG4gIGNhc3RJbW11dGFibGUsXG4gIGNyZWF0ZURyYWZ0LFxuICBjdXJyZW50LFxuICBlbmFibGVNYXBTZXQsXG4gIGVuYWJsZVBhdGNoZXMsXG4gIGZpbmlzaERyYWZ0LFxuICBmcmVlemUsXG4gIERSQUZUQUJMRSBhcyBpbW1lcmFibGUsXG4gIGlzRHJhZnQsXG4gIGlzRHJhZnRhYmxlLFxuICBOT1RISU5HIGFzIG5vdGhpbmcsXG4gIG9yaWdpbmFsLFxuICBwcm9kdWNlLFxuICBwcm9kdWNlV2l0aFBhdGNoZXMsXG4gIHNldEF1dG9GcmVlemUsXG4gIHNldFVzZVN0cmljdFNoYWxsb3dDb3B5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1tZXIubWpzLm1hcCJdLCJuYW1lcyI6WyJOT1RISU5HIiwiU3ltYm9sIiwiZm9yIiwiRFJBRlRBQkxFIiwiRFJBRlRfU1RBVEUiLCJlcnJvcnMiLCJwcm9jZXNzIiwicGx1Z2luIiwidGhpbmciLCJkYXRhIiwiZGllIiwiZXJyb3IiLCJhcmdzIiwiZSIsIm1zZyIsImFwcGx5IiwiRXJyb3IiLCJnZXRQcm90b3R5cGVPZiIsIk9iamVjdCIsImlzRHJhZnQiLCJ2YWx1ZSIsImlzRHJhZnRhYmxlIiwiaXNQbGFpbk9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsImNvbnN0cnVjdG9yIiwiaXNNYXAiLCJpc1NldCIsIm9iamVjdEN0b3JTdHJpbmciLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsInByb3RvIiwiQ3RvciIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIkZ1bmN0aW9uIiwib3JpZ2luYWwiLCJiYXNlXyIsImVhY2giLCJvYmoiLCJpdGVyIiwiZ2V0QXJjaHR5cGUiLCJSZWZsZWN0Iiwib3duS2V5cyIsImZvckVhY2giLCJrZXkiLCJlbnRyeSIsImluZGV4Iiwic3RhdGUiLCJ0eXBlXyIsImhhcyIsInByb3AiLCJnZXQiLCJzZXQiLCJwcm9wT3JPbGRWYWx1ZSIsInQiLCJhZGQiLCJpcyIsIngiLCJ5IiwidGFyZ2V0IiwiTWFwIiwiU2V0IiwibGF0ZXN0IiwiY29weV8iLCJzaGFsbG93Q29weSIsImJhc2UiLCJzdHJpY3QiLCJzbGljZSIsImNyZWF0ZSIsImFzc2lnbiIsImRlc2NyaXB0b3JzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImtleXMiLCJpIiwibGVuZ3RoIiwiZGVzYyIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsImRlZXAiLCJpc0Zyb3plbiIsImNsZWFyIiwiZGVsZXRlIiwiZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zIiwiZW50cmllcyIsInBsdWdpbnMiLCJnZXRQbHVnaW4iLCJwbHVnaW5LZXkiLCJsb2FkUGx1Z2luIiwiaW1wbGVtZW50YXRpb24iLCJjdXJyZW50U2NvcGUiLCJnZXRDdXJyZW50U2NvcGUiLCJjcmVhdGVTY29wZSIsInBhcmVudF8iLCJpbW1lcl8iLCJkcmFmdHNfIiwiY2FuQXV0b0ZyZWV6ZV8iLCJ1bmZpbmFsaXplZERyYWZ0c18iLCJ1c2VQYXRjaGVzSW5TY29wZSIsInNjb3BlIiwicGF0Y2hMaXN0ZW5lciIsInBhdGNoZXNfIiwiaW52ZXJzZVBhdGNoZXNfIiwicGF0Y2hMaXN0ZW5lcl8iLCJyZXZva2VTY29wZSIsImxlYXZlU2NvcGUiLCJyZXZva2VEcmFmdCIsImVudGVyU2NvcGUiLCJpbW1lcjIiLCJkcmFmdCIsInJldm9rZV8iLCJyZXZva2VkXyIsInByb2Nlc3NSZXN1bHQiLCJyZXN1bHQiLCJiYXNlRHJhZnQiLCJpc1JlcGxhY2VkIiwibW9kaWZpZWRfIiwiZmluYWxpemUiLCJtYXliZUZyZWV6ZSIsImdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyIsInJvb3RTY29wZSIsInBhdGgiLCJjaGlsZFZhbHVlIiwiZmluYWxpemVQcm9wZXJ0eSIsInNjb3BlXyIsImZpbmFsaXplZF8iLCJyZXN1bHRFYWNoIiwiaXNTZXQyIiwiZ2VuZXJhdGVQYXRjaGVzXyIsInBhcmVudFN0YXRlIiwidGFyZ2V0T2JqZWN0Iiwicm9vdFBhdGgiLCJ0YXJnZXRJc1NldCIsImFzc2lnbmVkXyIsImNvbmNhdCIsInJlcyIsImF1dG9GcmVlemVfIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJjcmVhdGVQcm94eVByb3h5IiwicGFyZW50IiwiZHJhZnRfIiwiaXNNYW51YWxfIiwidHJhcHMiLCJvYmplY3RUcmFwcyIsImFycmF5VHJhcHMiLCJyZXZva2UiLCJwcm94eSIsIlByb3h5IiwicmV2b2NhYmxlIiwic291cmNlIiwicmVhZFByb3BGcm9tUHJvdG8iLCJwZWVrIiwicHJlcGFyZUNvcHkiLCJjcmVhdGVQcm94eSIsImdldERlc2NyaXB0b3JGcm9tUHJvdG8iLCJjdXJyZW50MiIsImN1cnJlbnRTdGF0ZSIsIm1hcmtDaGFuZ2VkIiwiTnVtYmVyIiwiaXNOYU4iLCJkZWxldGVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIm93bmVyIiwiZGVmaW5lUHJvcGVydHkiLCJzZXRQcm90b3R5cGVPZiIsImZuIiwiYXJndW1lbnRzIiwicGFyc2VJbnQiLCJ1c2VTdHJpY3RTaGFsbG93Q29weV8iLCJJbW1lcjIiLCJjcmVhdGVEcmFmdCIsImN1cnJlbnQiLCJmaW5pc2hEcmFmdCIsInNldEF1dG9GcmVlemUiLCJzZXRVc2VTdHJpY3RTaGFsbG93Q29weSIsImFwcGx5UGF0Y2hlcyIsInBhdGNoZXMiLCJwYXRjaCIsIm9wIiwiYXBwbHlQYXRjaGVzSW1wbCIsImFwcGx5UGF0Y2hlc18iLCJwcm9kdWNlIiwiY29uZmlnIiwicmVjaXBlIiwiZGVmYXVsdEJhc2UiLCJzZWxmIiwiY3VycmllZFByb2R1Y2UiLCJiYXNlMiIsImhhc0Vycm9yIiwicCIsImlwIiwicHJvZHVjZVdpdGhQYXRjaGVzIiwiaW52ZXJzZVBhdGNoZXMiLCJhdXRvRnJlZXplIiwidXNlU3RyaWN0U2hhbGxvd0NvcHkiLCJwcm94eU1hcF8iLCJwcm94eVNldF8iLCJwdXNoIiwiY3VycmVudEltcGwiLCJjb3B5IiwiZW5hYmxlUGF0Y2hlcyIsImVycm9yT2Zmc2V0IiwiUkVQTEFDRSIsIkFERCIsIlJFTU9WRSIsImJhc2VQYXRoIiwiZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkIiwiZ2VuZXJhdGVBcnJheVBhdGNoZXMiLCJnZW5lcmF0ZVNldFBhdGNoZXMiLCJjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZCIsImFzc2lnbmVkVmFsdWUiLCJvcmlnVmFsdWUiLCJ1bnNoaWZ0IiwiYmFzZVZhbHVlIiwicmVwbGFjZW1lbnQiLCJwYXJlbnRUeXBlIiwiam9pbiIsInR5cGUiLCJkZWVwQ2xvbmVQYXRjaFZhbHVlIiwic3BsaWNlIiwibWFwIiwiZnJvbSIsImsiLCJ2IiwiY2xvbmVkIiwiZW5hYmxlTWFwU2V0IiwiRHJhZnRNYXAiLCJzaXplIiwiYXNzZXJ0VW5yZXZva2VkIiwicHJlcGFyZU1hcENvcHkiLCJjYiIsInRoaXNBcmciLCJfdmFsdWUiLCJfbWFwIiwidmFsdWVzIiwiaXRlcmF0b3IiLCJuZXh0IiwiciIsImRvbmUiLCJEcmFmdFNldCIsInByZXBhcmVTZXRDb3B5IiwiSlNPTiIsInN0cmluZ2lmeSIsImltbWVyIiwiYmluZCIsImNhc3REcmFmdCIsImNhc3RJbW11dGFibGUiLCJJbW1lciIsImltbWVyYWJsZSIsIm5vdGhpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/immer/dist/immer.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-redux/dist/react-redux.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: function() { return /* binding */ Provider_default; },\n/* harmony export */   ReactReduxContext: function() { return /* binding */ ReactReduxContext; },\n/* harmony export */   batch: function() { return /* binding */ batch; },\n/* harmony export */   connect: function() { return /* binding */ connect_default; },\n/* harmony export */   createDispatchHook: function() { return /* binding */ createDispatchHook; },\n/* harmony export */   createSelectorHook: function() { return /* binding */ createSelectorHook; },\n/* harmony export */   createStoreHook: function() { return /* binding */ createStoreHook; },\n/* harmony export */   shallowEqual: function() { return /* binding */ shallowEqual; },\n/* harmony export */   useDispatch: function() { return /* binding */ useDispatch; },\n/* harmony export */   useSelector: function() { return /* binding */ useSelector; },\n/* harmony export */   useStore: function() { return /* binding */ useStore; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js\");\n// src/index.ts\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n// src/utils/react.ts\n\nvar React = // prettier-ignore\n// @ts-ignore\n true ? react__WEBPACK_IMPORTED_MODULE_0__ : /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)));\n// src/components/Context.ts\nvar ContextKey = Symbol.for(\"react-redux-context\");\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {};\nfunction getContext() {\n    if (!React.createContext) return {};\n    var _gT_ContextKey;\n    const contextMap = (_gT_ContextKey = gT[ContextKey]) !== null && _gT_ContextKey !== void 0 ? _gT_ContextKey : gT[ContextKey] = /* @__PURE__ */ new Map();\n    let realContext = contextMap.get(React.createContext);\n    if (!realContext) {\n        realContext = React.createContext(null);\n        if (true) {\n            realContext.displayName = \"ReactRedux\";\n        }\n        contextMap.set(React.createContext, realContext);\n    }\n    return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */ getContext();\n// src/utils/useSyncExternalStore.ts\nvar notInitialized = ()=>{\n    throw new Error(\"uSES not initialized!\");\n};\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;\n    var _s = $RefreshSig$();\n    return _s(function useReduxContext2() {\n        _s();\n        const contextValue = React.useContext(context);\n        if ( true && !contextValue) {\n            throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n        }\n        return contextValue;\n    }, \"LIxFXvZbUdXE/TWxKLLXMjM3Mig=\");\n}\nvar useReduxContext = /* @__PURE__ */ createReduxContextHook();\n// src/hooks/useSelector.ts\nvar useSyncExternalStoreWithSelector = notInitialized;\nvar initializeUseSelector = (fn)=>{\n    useSyncExternalStoreWithSelector = fn;\n};\nvar refEquality = (a, b)=>a === b;\nfunction createSelectorHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;\n    var _s = $RefreshSig$();\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n    const useSelector2 = function(selector) {\n        let equalityFnOrOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        _s();\n        const { equalityFn = refEquality, devModeChecks = {} } = typeof equalityFnOrOptions === \"function\" ? {\n            equalityFn: equalityFnOrOptions\n        } : equalityFnOrOptions;\n        if (true) {\n            if (!selector) {\n                throw new Error(\"You must pass a selector to useSelector\");\n            }\n            if (typeof selector !== \"function\") {\n                throw new Error(\"You must pass a function as a selector to useSelector\");\n            }\n            if (typeof equalityFn !== \"function\") {\n                throw new Error(\"You must pass a function as an equality function to useSelector\");\n            }\n        }\n        const { store, subscription, getServerState, stabilityCheck, identityFunctionCheck } = useReduxContext2();\n        const firstRun = React.useRef(true);\n        const wrappedSelector = React.useCallback({\n            [selector.name] (state) {\n                const selected = selector(state);\n                if (true) {\n                    const { identityFunctionCheck: finalIdentityFunctionCheck, stabilityCheck: finalStabilityCheck } = {\n                        stabilityCheck,\n                        identityFunctionCheck,\n                        ...devModeChecks\n                    };\n                    if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n                        const toCompare = selector(state);\n                        if (!equalityFn(selected, toCompare)) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n                                state,\n                                selected,\n                                selected2: toCompare,\n                                stack\n                            });\n                        }\n                    }\n                    if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n                        if (selected === state) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n                                stack\n                            });\n                        }\n                    }\n                    if (firstRun.current) firstRun.current = false;\n                }\n                return selected;\n            }\n        }[selector.name], [\n            selector,\n            stabilityCheck,\n            devModeChecks.stabilityCheck\n        ]);\n        const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n        React.useDebugValue(selectedState);\n        return selectedState;\n    };\n    _s(useSelector2, \"wod2BghVQQvvDTXQFH1TwA65y/c=\", false, function() {\n        return [\n            useReduxContext2,\n            useSyncExternalStoreWithSelector\n        ];\n    });\n    Object.assign(useSelector2, {\n        withTypes: ()=>useSelector2\n    });\n    return useSelector2;\n}\nvar useSelector = /* @__PURE__ */ createSelectorHook();\n// src/utils/react-is.ts\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\nvar REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\nvar REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\nvar REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\nvar REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\nvar REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n    if (typeof type === \"string\" || typeof type === \"function\") {\n        return true;\n    }\n    if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {\n        return true;\n    }\n    if (typeof type === \"object\" && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction typeOf(object) {\n    if (typeof object === \"object\" && object !== null) {\n        const $$typeof = object.$$typeof;\n        switch($$typeof){\n            case REACT_ELEMENT_TYPE:\n                {\n                    const type = object.type;\n                    switch(type){\n                        case REACT_FRAGMENT_TYPE:\n                        case REACT_PROFILER_TYPE:\n                        case REACT_STRICT_MODE_TYPE:\n                        case REACT_SUSPENSE_TYPE:\n                        case REACT_SUSPENSE_LIST_TYPE:\n                            return type;\n                        default:\n                            {\n                                const $$typeofType = type && type.$$typeof;\n                                switch($$typeofType){\n                                    case REACT_SERVER_CONTEXT_TYPE:\n                                    case REACT_CONTEXT_TYPE:\n                                    case REACT_FORWARD_REF_TYPE:\n                                    case REACT_LAZY_TYPE:\n                                    case REACT_MEMO_TYPE:\n                                    case REACT_PROVIDER_TYPE:\n                                        return $$typeofType;\n                                    default:\n                                        return $$typeof;\n                                }\n                            }\n                    }\n                }\n            case REACT_PORTAL_TYPE:\n                {\n                    return $$typeof;\n                }\n        }\n    }\n    return void 0;\n}\nfunction isContextConsumer(object) {\n    return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n    return typeOf(object) === REACT_MEMO_TYPE;\n}\n// src/utils/warning.ts\nfunction warning(message) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    try {\n        throw new Error(message);\n    } catch (e) {}\n}\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n    if (!selector) {\n        throw new Error(\"Unexpected value for \".concat(methodName, \" in connect.\"));\n    } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n        if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n            warning(\"The selector for \".concat(methodName, \" of connect did not specify a value for dependsOnOwnProps.\"));\n        }\n    }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n    verify(mapStateToProps, \"mapStateToProps\");\n    verify(mapDispatchToProps, \"mapDispatchToProps\");\n    verify(mergeProps, \"mergeProps\");\n}\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, param) {\n    let { areStatesEqual, areOwnPropsEqual, areStatePropsEqual } = param;\n    let hasRunAtLeastOnce = false;\n    let state;\n    let ownProps;\n    let stateProps;\n    let dispatchProps;\n    let mergedProps;\n    function handleFirstCall(firstState, firstOwnProps) {\n        state = firstState;\n        ownProps = firstOwnProps;\n        stateProps = mapStateToProps(state, ownProps);\n        dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        hasRunAtLeastOnce = true;\n        return mergedProps;\n    }\n    function handleNewPropsAndNewState() {\n        stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewProps() {\n        if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewState() {\n        const nextStateProps = mapStateToProps(state, ownProps);\n        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n        stateProps = nextStateProps;\n        if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleSubsequentCalls(nextState, nextOwnProps) {\n        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n        const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n        state = nextState;\n        ownProps = nextOwnProps;\n        if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n        if (propsChanged) return handleNewProps();\n        if (stateChanged) return handleNewState();\n        return mergedProps;\n    }\n    return function pureFinalPropsSelector(nextState, nextOwnProps) {\n        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n    };\n}\nfunction finalPropsSelectorFactory(dispatch, param) {\n    let { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options } = param;\n    const mapStateToProps = initMapStateToProps(dispatch, options);\n    const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n    const mergeProps = initMergeProps(dispatch, options);\n    if (true) {\n        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n    }\n    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n    const boundActionCreators = {};\n    for(const key in actionCreators){\n        const actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return dispatch(actionCreator(...args));\n            };\n        }\n    }\n    return boundActionCreators;\n}\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null) return true;\n    let baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n    if (!isPlainObject(value)) {\n        warning(\"\".concat(methodName, \"() in \").concat(displayName, \" must return a plain object. Instead received \").concat(value, \".\"));\n    }\n}\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n    return function initConstantSelector(dispatch) {\n        const constant = getConstant(dispatch);\n        function constantSelector() {\n            return constant;\n        }\n        constantSelector.dependsOnOwnProps = false;\n        return constantSelector;\n    };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n    return function initProxySelector(dispatch, param) {\n        let { displayName } = param;\n        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n            return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n        };\n        proxy.dependsOnOwnProps = true;\n        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n            proxy.mapToProps = mapToProps;\n            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n            let props = proxy(stateOrDispatch, ownProps);\n            if (typeof props === \"function\") {\n                proxy.mapToProps = props;\n                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n                props = proxy(stateOrDispatch, ownProps);\n            }\n            if (true) verifyPlainObject(props, displayName, methodName);\n            return props;\n        };\n        return proxy;\n    };\n}\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n    return (dispatch, options)=>{\n        throw new Error(\"Invalid value of type \".concat(typeof arg, \" for \").concat(name, \" argument when connecting component \").concat(options.wrappedComponentName, \".\"));\n    };\n}\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n    return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant((dispatch)=>// @ts-ignore\n        bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch)=>({\n            dispatch\n        })) : typeof mapDispatchToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n    return !mapStateToProps ? wrapMapToPropsConstant(()=>({})) : typeof mapStateToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n    return {\n        ...ownProps,\n        ...stateProps,\n        ...dispatchProps\n    };\n}\nfunction wrapMergePropsFunc(mergeProps) {\n    return function initMergePropsProxy(dispatch, param) {\n        let { displayName, areMergedPropsEqual } = param;\n        let hasRunOnce = false;\n        let mergedProps;\n        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n            const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n            if (hasRunOnce) {\n                if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n            } else {\n                hasRunOnce = true;\n                mergedProps = nextMergedProps;\n                if (true) verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n            }\n            return mergedProps;\n        };\n    };\n}\nfunction mergePropsFactory(mergeProps) {\n    return !mergeProps ? ()=>defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n    callback();\n}\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n    let first = null;\n    let last = null;\n    return {\n        clear () {\n            first = null;\n            last = null;\n        },\n        notify () {\n            defaultNoopBatch(()=>{\n                let listener = first;\n                while(listener){\n                    listener.callback();\n                    listener = listener.next;\n                }\n            });\n        },\n        get () {\n            const listeners = [];\n            let listener = first;\n            while(listener){\n                listeners.push(listener);\n                listener = listener.next;\n            }\n            return listeners;\n        },\n        subscribe (callback) {\n            let isSubscribed = true;\n            const listener = last = {\n                callback,\n                next: null,\n                prev: last\n            };\n            if (listener.prev) {\n                listener.prev.next = listener;\n            } else {\n                first = listener;\n            }\n            return function unsubscribe() {\n                if (!isSubscribed || first === null) return;\n                isSubscribed = false;\n                if (listener.next) {\n                    listener.next.prev = listener.prev;\n                } else {\n                    last = listener.prev;\n                }\n                if (listener.prev) {\n                    listener.prev.next = listener.next;\n                } else {\n                    first = listener.next;\n                }\n            };\n        }\n    };\n}\nvar nullListeners = {\n    notify () {},\n    get: ()=>[]\n};\nfunction createSubscription(store, parentSub) {\n    let unsubscribe;\n    let listeners = nullListeners;\n    let subscriptionsAmount = 0;\n    let selfSubscribed = false;\n    function addNestedSub(listener) {\n        trySubscribe();\n        const cleanupListener = listeners.subscribe(listener);\n        let removed = false;\n        return ()=>{\n            if (!removed) {\n                removed = true;\n                cleanupListener();\n                tryUnsubscribe();\n            }\n        };\n    }\n    function notifyNestedSubs() {\n        listeners.notify();\n    }\n    function handleChangeWrapper() {\n        if (subscription.onStateChange) {\n            subscription.onStateChange();\n        }\n    }\n    function isSubscribed() {\n        return selfSubscribed;\n    }\n    function trySubscribe() {\n        subscriptionsAmount++;\n        if (!unsubscribe) {\n            unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n            listeners = createListenerCollection();\n        }\n    }\n    function tryUnsubscribe() {\n        subscriptionsAmount--;\n        if (unsubscribe && subscriptionsAmount === 0) {\n            unsubscribe();\n            unsubscribe = void 0;\n            listeners.clear();\n            listeners = nullListeners;\n        }\n    }\n    function trySubscribeSelf() {\n        if (!selfSubscribed) {\n            selfSubscribed = true;\n            trySubscribe();\n        }\n    }\n    function tryUnsubscribeSelf() {\n        if (selfSubscribed) {\n            selfSubscribed = false;\n            tryUnsubscribe();\n        }\n    }\n    const subscription = {\n        addNestedSub,\n        notifyNestedSubs,\n        handleChangeWrapper,\n        isSubscribed,\n        trySubscribe: trySubscribeSelf,\n        tryUnsubscribe: tryUnsubscribeSelf,\n        getListeners: ()=>listeners\n    };\n    return subscription;\n}\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = !!( true && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar useIsomorphicLayoutEffect = canUseDOM ? React.useLayoutEffect : React.useEffect;\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nfunction shallowEqual(objA, objB) {\n    if (is(objA, objB)) return true;\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) return false;\n    for(let i = 0; i < keysA.length; i++){\n        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextType: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromError: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\nvar FORWARD_REF_STATICS = {\n    $$typeof: true,\n    render: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true\n};\nvar MEMO_STATICS = {\n    $$typeof: true,\n    compare: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n    type: true\n};\nvar TYPE_STATICS = {\n    [ForwardRef]: FORWARD_REF_STATICS,\n    [Memo]: MEMO_STATICS\n};\nfunction getStatics(component) {\n    if (isMemo(component)) {\n        return MEMO_STATICS;\n    }\n    return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n    if (typeof sourceComponent !== \"string\") {\n        if (objectPrototype) {\n            const inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent);\n            }\n        }\n        let keys = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        const targetStatics = getStatics(targetComponent);\n        const sourceStatics = getStatics(sourceComponent);\n        for(let i = 0; i < keys.length; ++i){\n            const key = keys[i];\n            if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n                const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try {\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n    }\n    return targetComponent;\n}\n// src/components/connect.tsx\nvar useSyncExternalStore = notInitialized;\nvar initializeConnect = (fn)=>{\n    useSyncExternalStore = fn;\n};\nvar NO_SUBSCRIPTION_ARRAY = [\n    null,\n    null\n];\nvar stringifyComponent = (Comp)=>{\n    try {\n        return JSON.stringify(Comp);\n    } catch (err) {\n        return String(Comp);\n    }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n    _s();\n    useIsomorphicLayoutEffect(()=>effectFunc(...effectArgs), dependencies);\n}\n_s(useIsomorphicLayoutEffectWithArgs, \"Vd+jpwighRca2oU8HoLqd+zm4Bo=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect\n    ];\n});\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n    lastWrapperProps.current = wrapperProps;\n    renderIsScheduled.current = false;\n    if (childPropsFromStoreUpdate.current) {\n        childPropsFromStoreUpdate.current = null;\n        notifyNestedSubs();\n    }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n    if (!shouldHandleStateChanges) return ()=>{};\n    let didUnsubscribe = false;\n    let lastThrownError = null;\n    const checkForUpdates = ()=>{\n        if (didUnsubscribe || !isMounted.current) {\n            return;\n        }\n        const latestStoreState = store.getState();\n        let newChildProps, error;\n        try {\n            newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n        } catch (e) {\n            error = e;\n            lastThrownError = e;\n        }\n        if (!error) {\n            lastThrownError = null;\n        }\n        if (newChildProps === lastChildProps.current) {\n            if (!renderIsScheduled.current) {\n                notifyNestedSubs();\n            }\n        } else {\n            lastChildProps.current = newChildProps;\n            childPropsFromStoreUpdate.current = newChildProps;\n            renderIsScheduled.current = true;\n            additionalSubscribeListener();\n        }\n    };\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    const unsubscribeWrapper = ()=>{\n        didUnsubscribe = true;\n        subscription.tryUnsubscribe();\n        subscription.onStateChange = null;\n        if (lastThrownError) {\n            throw lastThrownError;\n        }\n    };\n    return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n    return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps) {\n    let { // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n    // @ts-ignore\n    pure, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, // use React's forwardRef to expose a ref of the wrapped component\n    forwardRef = false, // the context consumer to use\n    context = ReactReduxContext } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    if (true) {\n        if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n            hasWarnedAboutDeprecatedPureOption = true;\n            warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n        }\n    }\n    const Context = context;\n    const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n    const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n    const initMergeProps = mergePropsFactory(mergeProps);\n    const shouldHandleStateChanges = Boolean(mapStateToProps);\n    const wrapWithConnect = (WrappedComponent)=>{\n        var _s = $RefreshSig$();\n        if (true) {\n            const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);\n            if (!isValid) throw new Error(\"You must pass a component to the function returned by connect. Instead received \".concat(stringifyComponent(WrappedComponent)));\n        }\n        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n        const displayName = \"Connect(\".concat(wrappedComponentName, \")\");\n        const selectorFactoryOptions = {\n            shouldHandleStateChanges,\n            displayName,\n            wrappedComponentName,\n            WrappedComponent,\n            // @ts-ignore\n            initMapStateToProps,\n            // @ts-ignore\n            initMapDispatchToProps,\n            initMergeProps,\n            areStatesEqual,\n            areStatePropsEqual,\n            areOwnPropsEqual,\n            areMergedPropsEqual\n        };\n        function ConnectFunction(props) {\n            _s();\n            const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(()=>{\n                const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;\n                return [\n                    props.context,\n                    reactReduxForwardedRef2,\n                    wrapperProps2\n                ];\n            }, [\n                props\n            ]);\n            const ContextToUse = React.useMemo(()=>{\n                let ResultContext = Context;\n                if (propsContext === null || propsContext === void 0 ? void 0 : propsContext.Consumer) {\n                    if (true) {\n                        const isValid = /* @__PURE__ */ isContextConsumer(// @ts-ignore\n                        /* @__PURE__ */ React.createElement(propsContext.Consumer, null));\n                        if (!isValid) {\n                            throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n                        }\n                        ResultContext = propsContext;\n                    }\n                }\n                return ResultContext;\n            }, [\n                propsContext,\n                Context\n            ]);\n            const contextValue = React.useContext(ContextToUse);\n            const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n            const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n            if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n                throw new Error('Could not find \"store\" in the context of \"'.concat(displayName, '\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ').concat(displayName, \" in connect options.\"));\n            }\n            const store = didStoreComeFromProps ? props.store : contextValue.store;\n            const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n            const childPropsSelector = React.useMemo(()=>{\n                return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n            }, [\n                store\n            ]);\n            const [subscription, notifyNestedSubs] = React.useMemo(()=>{\n                if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n                const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n                const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n                return [\n                    subscription2,\n                    notifyNestedSubs2\n                ];\n            }, [\n                store,\n                didStoreComeFromProps,\n                contextValue\n            ]);\n            const overriddenContextValue = React.useMemo(()=>{\n                if (didStoreComeFromProps) {\n                    return contextValue;\n                }\n                return {\n                    ...contextValue,\n                    subscription\n                };\n            }, [\n                didStoreComeFromProps,\n                contextValue,\n                subscription\n            ]);\n            const lastChildProps = React.useRef();\n            const lastWrapperProps = React.useRef(wrapperProps);\n            const childPropsFromStoreUpdate = React.useRef();\n            const renderIsScheduled = React.useRef(false);\n            const isProcessingDispatch = React.useRef(false);\n            const isMounted = React.useRef(false);\n            const latestSubscriptionCallbackError = React.useRef();\n            useIsomorphicLayoutEffect(()=>{\n                isMounted.current = true;\n                return ()=>{\n                    isMounted.current = false;\n                };\n            }, []);\n            const actualChildPropsSelector = React.useMemo(()=>{\n                const selector = ()=>{\n                    if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n                        return childPropsFromStoreUpdate.current;\n                    }\n                    return childPropsSelector(store.getState(), wrapperProps);\n                };\n                return selector;\n            }, [\n                store,\n                wrapperProps\n            ]);\n            const subscribeForReact = React.useMemo(()=>{\n                const subscribe = (reactListener)=>{\n                    if (!subscription) {\n                        return ()=>{};\n                    }\n                    return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore\n                    childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n                };\n                return subscribe;\n            }, [\n                subscription\n            ]);\n            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n                lastWrapperProps,\n                lastChildProps,\n                renderIsScheduled,\n                wrapperProps,\n                childPropsFromStoreUpdate,\n                notifyNestedSubs\n            ]);\n            let actualChildProps;\n            try {\n                actualChildProps = useSyncExternalStore(// TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n                subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n                // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n                actualChildPropsSelector, getServerState ? ()=>childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n            } catch (err) {\n                if (latestSubscriptionCallbackError.current) {\n                    ;\n                    err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n                }\n                throw err;\n            }\n            useIsomorphicLayoutEffect(()=>{\n                latestSubscriptionCallbackError.current = void 0;\n                childPropsFromStoreUpdate.current = void 0;\n                lastChildProps.current = actualChildProps;\n            });\n            const renderedWrappedComponent = React.useMemo(()=>{\n                return(// @ts-ignore\n                /* @__PURE__ */ React.createElement(WrappedComponent, {\n                    ...actualChildProps,\n                    ref: reactReduxForwardedRef\n                }));\n            }, [\n                reactReduxForwardedRef,\n                WrappedComponent,\n                actualChildProps\n            ]);\n            const renderedChild = React.useMemo(()=>{\n                if (shouldHandleStateChanges) {\n                    return /* @__PURE__ */ React.createElement(ContextToUse.Provider, {\n                        value: overriddenContextValue\n                    }, renderedWrappedComponent);\n                }\n                return renderedWrappedComponent;\n            }, [\n                ContextToUse,\n                renderedWrappedComponent,\n                overriddenContextValue\n            ]);\n            return renderedChild;\n        }\n        _s(ConnectFunction, \"YlsbgChiRX6N9qJQvI85/COlsOk=\", false, function() {\n            return [\n                useIsomorphicLayoutEffect,\n                useIsomorphicLayoutEffectWithArgs,\n                useIsomorphicLayoutEffect\n            ];\n        });\n        const _Connect = React.memo(ConnectFunction);\n        const Connect = _Connect;\n        Connect.WrappedComponent = WrappedComponent;\n        Connect.displayName = ConnectFunction.displayName = displayName;\n        if (forwardRef) {\n            const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n                return /* @__PURE__ */ React.createElement(Connect, {\n                    ...props,\n                    reactReduxForwardedRef: ref\n                });\n            });\n            const forwarded = _forwarded;\n            forwarded.displayName = displayName;\n            forwarded.WrappedComponent = WrappedComponent;\n            return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);\n        }\n        return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);\n    };\n    return wrapWithConnect;\n}\nvar connect_default = connect;\n// src/components/Provider.tsx\nfunction Provider(param) {\n    let { store, context, children, serverState, stabilityCheck = \"once\", identityFunctionCheck = \"once\" } = param;\n    _s1();\n    const contextValue = React.useMemo(()=>{\n        const subscription = createSubscription(store);\n        return {\n            store,\n            subscription,\n            getServerState: serverState ? ()=>serverState : void 0,\n            stabilityCheck,\n            identityFunctionCheck\n        };\n    }, [\n        store,\n        serverState,\n        stabilityCheck,\n        identityFunctionCheck\n    ]);\n    const previousState = React.useMemo(()=>store.getState(), [\n        store\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        const { subscription } = contextValue;\n        subscription.onStateChange = subscription.notifyNestedSubs;\n        subscription.trySubscribe();\n        if (previousState !== store.getState()) {\n            subscription.notifyNestedSubs();\n        }\n        return ()=>{\n            subscription.tryUnsubscribe();\n            subscription.onStateChange = void 0;\n        };\n    }, [\n        contextValue,\n        previousState\n    ]);\n    const Context = context || ReactReduxContext;\n    return /* @__PURE__ */ React.createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\n_s1(Provider, \"UYZUOdaFWZnoeXRb2Yd5sJGEKkk=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect\n    ];\n});\n_c = Provider;\nvar Provider_default = Provider;\n// src/hooks/useStore.ts\nfunction createStoreHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;\n    var _s = $RefreshSig$();\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : // @ts-ignore\n    createReduxContextHook(context);\n    const useStore2 = ()=>{\n        _s();\n        const { store } = useReduxContext2();\n        return store;\n    };\n    _s(useStore2, \"2zRszP8U73u9PkAgpGu7+pashzU=\", false, function() {\n        return [\n            useReduxContext2\n        ];\n    });\n    Object.assign(useStore2, {\n        withTypes: ()=>useStore2\n    });\n    return useStore2;\n}\nvar useStore = /* @__PURE__ */ createStoreHook();\n// src/hooks/useDispatch.ts\nfunction createDispatchHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;\n    var _s = $RefreshSig$();\n    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n    const useDispatch2 = ()=>{\n        _s();\n        const store = useStore2();\n        return store.dispatch;\n    };\n    _s(useDispatch2, \"R3RnulSyf8rj5wf0vNt7XNoJlHg=\", false, function() {\n        return [\n            useStore2\n        ];\n    });\n    Object.assign(useDispatch2, {\n        withTypes: ()=>useDispatch2\n    });\n    return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */ createDispatchHook();\n// src/exports.ts\nvar batch = defaultNoopBatch;\n// src/index.ts\ninitializeUseSelector(use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector);\ninitializeConnect(react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore);\n //# sourceMappingURL=react-redux.mjs.map\nvar _c;\n$RefreshReg$(_c, \"Provider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9kaXN0L3JlYWN0LXJlZHV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGVBQWU7O0FBQ2lCO0FBQ2lHO0FBRWpJLHFCQUFxQjtBQUNrQjtBQUN2QyxJQUFJSSxRQUNGLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2IsS0FBMEJELEdBQUdBLGtDQUF3QixHQUFHQSx5TEFBYUE7QUFHdkUsNEJBQTRCO0FBQzVCLElBQUlFLGFBQWFDLE9BQU9DLEdBQUcsQ0FBRTtBQUM3QixJQUFJQyxLQUFLLE9BQU9DLGVBQWUsY0FBY0EsYUFDM0Msd0ZBQXdGLEdBQ3hGLENBQUM7QUFFSCxTQUFTQztJQUNQLElBQUksQ0FBQ04sTUFBTU8sYUFBYSxFQUN0QixPQUFPLENBQUM7UUFDU0g7SUFBbkIsTUFBTUksYUFBYUosQ0FBQUEsaUJBQUFBLEVBQUUsQ0FBQ0gsV0FBVyxjQUFkRyw0QkFBQUEsaUJBQW1CQSxFQUFFLENBQUNILFdBQVcsR0FBRyxhQUFhLEdBQUcsSUFBSVE7SUFDM0UsSUFBSUMsY0FBY0YsV0FBV0csR0FBRyxDQUFDWCxNQUFNTyxhQUFhO0lBQ3BELElBQUksQ0FBQ0csYUFBYTtRQUNoQkEsY0FBY1YsTUFBTU8sYUFBYSxDQUMvQjtRQUVGLElBQUlLLElBQXFDLEVBQUU7WUFDekNGLFlBQVlHLFdBQVcsR0FBRztRQUM1QjtRQUNBTCxXQUFXTSxHQUFHLENBQUNkLE1BQU1PLGFBQWEsRUFBRUc7SUFDdEM7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsSUFBSUssb0JBQW9CLGFBQWEsR0FBR1Q7QUFFeEMsb0NBQW9DO0FBQ3BDLElBQUlVLGlCQUFpQjtJQUNuQixNQUFNLElBQUlDLE1BQU07QUFDbEI7QUFFQSwrQkFBK0I7QUFDL0IsU0FBU0M7UUFBdUJDLFVBQUFBLGlFQUFVSjs7SUFDeEMsVUFBTyxTQUFTSzs7UUFDZCxNQUFNQyxlQUFlckIsTUFBTXNCLFVBQVUsQ0FB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QUNBLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJQyxjQUFjLGFBQWEsR0FBR0Y7QUFFbEMsaUJBQWlCO0FBQ2pCLElBQUlHLFFBQVFwSztBQUVaLGVBQWU7QUFDZnRKLHNCQUFzQjFCLHNHQUFpQ0E7QUFDdkRtUSxrQkFBa0JyUSx1REFBMkI7QUFhM0MsQ0FDRix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2Rpc3QvcmVhY3QtcmVkdXgubWpzPzA0MjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgKiBhcyBSZWFjdDIgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvd2l0aC1zZWxlY3Rvci5qc1wiO1xuXG4vLyBzcmMvdXRpbHMvcmVhY3QudHNcbmltcG9ydCAqIGFzIFJlYWN0T3JpZ2luYWwgZnJvbSBcInJlYWN0XCI7XG52YXIgUmVhY3QgPSAoXG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICAvLyBAdHMtaWdub3JlXG4gIFwiZGVmYXVsdFwiIGluIFJlYWN0T3JpZ2luYWwgPyBSZWFjdE9yaWdpbmFsW1wiZGVmYXVsdFwiXSA6IFJlYWN0T3JpZ2luYWxcbik7XG5cbi8vIHNyYy9jb21wb25lbnRzL0NvbnRleHQudHNcbnZhciBDb250ZXh0S2V5ID0gU3ltYm9sLmZvcihgcmVhY3QtcmVkdXgtY29udGV4dGApO1xudmFyIGdUID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogKFxuICAvKiBmYWxsIGJhY2sgdG8gYSBwZXItbW9kdWxlIHNjb3BlIChwcmUtOC4xIGJlaGF2aW91cikgaWYgYGdsb2JhbFRoaXNgIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAge31cbik7XG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBpZiAoIVJlYWN0LmNyZWF0ZUNvbnRleHQpXG4gICAgcmV0dXJuIHt9O1xuICBjb25zdCBjb250ZXh0TWFwID0gZ1RbQ29udGV4dEtleV0gPz8gKGdUW0NvbnRleHRLZXldID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGxldCByZWFsQ29udGV4dCA9IGNvbnRleHRNYXAuZ2V0KFJlYWN0LmNyZWF0ZUNvbnRleHQpO1xuICBpZiAoIXJlYWxDb250ZXh0KSB7XG4gICAgcmVhbENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVhbENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJlYWN0UmVkdXhcIjtcbiAgICB9XG4gICAgY29udGV4dE1hcC5zZXQoUmVhY3QuY3JlYXRlQ29udGV4dCwgcmVhbENvbnRleHQpO1xuICB9XG4gIHJldHVybiByZWFsQ29udGV4dDtcbn1cbnZhciBSZWFjdFJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBnZXRDb250ZXh0KCk7XG5cbi8vIHNyYy91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZS50c1xudmFyIG5vdEluaXRpYWxpemVkID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1U0VTIG5vdCBpbml0aWFsaXplZCFcIik7XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlUmVkdXhDb250ZXh0LnRzXG5mdW5jdGlvbiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gdXNlUmVkdXhDb250ZXh0MigpIHtcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWNvbnRleHRWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImNvdWxkIG5vdCBmaW5kIHJlYWN0LXJlZHV4IGNvbnRleHQgdmFsdWU7IHBsZWFzZSBlbnN1cmUgdGhlIGNvbXBvbmVudCBpcyB3cmFwcGVkIGluIGEgPFByb3ZpZGVyPlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICB9O1xufVxudmFyIHVzZVJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVSZWR1eENvbnRleHRIb29rKCk7XG5cbi8vIHNyYy9ob29rcy91c2VTZWxlY3Rvci50c1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gbm90SW5pdGlhbGl6ZWQ7XG52YXIgaW5pdGlhbGl6ZVVzZVNlbGVjdG9yID0gKGZuKSA9PiB7XG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gZm47XG59O1xudmFyIHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rvckhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dDIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVJlZHV4Q29udGV4dCA6IGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCk7XG4gIGNvbnN0IHVzZVNlbGVjdG9yMiA9IChzZWxlY3RvciwgZXF1YWxpdHlGbk9yT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBlcXVhbGl0eUZuID0gcmVmRXF1YWxpdHksIGRldk1vZGVDaGVja3MgPSB7fSB9ID0gdHlwZW9mIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHsgZXF1YWxpdHlGbjogZXF1YWxpdHlGbk9yT3B0aW9ucyB9IDogZXF1YWxpdHlGbk9yT3B0aW9ucztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvcmApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlcXVhbGl0eUZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYW4gZXF1YWxpdHkgZnVuY3Rpb24gdG8gdXNlU2VsZWN0b3JgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0b3JlLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgZ2V0U2VydmVyU3RhdGUsXG4gICAgICBzdGFiaWxpdHlDaGVjayxcbiAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVja1xuICAgIH0gPSB1c2VSZWR1eENvbnRleHQyKCk7XG4gICAgY29uc3QgZmlyc3RSdW4gPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICB7XG4gICAgICAgIFtzZWxlY3Rvci5uYW1lXShzdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2s6IGZpbmFsU3RhYmlsaXR5Q2hlY2tcbiAgICAgICAgICAgIH0gPSB7XG4gICAgICAgICAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssXG4gICAgICAgICAgICAgIC4uLmRldk1vZGVDaGVja3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gXCJhbHdheXNcIiB8fCBmaW5hbFN0YWJpbGl0eUNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvQ29tcGFyZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgICAgICAgICAgaWYgKCFlcXVhbGl0eUZuKHNlbGVjdGVkLCB0b0NvbXBhcmUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAoeyBzdGFjayB9ID0gZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIFwiU2VsZWN0b3IgXCIgKyAoc2VsZWN0b3IubmFtZSB8fCBcInVua25vd25cIikgKyBcIiByZXR1cm5lZCBhIGRpZmZlcmVudCByZXN1bHQgd2hlbiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy5cXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gYSBuZXcgcmVmZXJlbmNlIChzdWNoIGFzIGFuIG9iamVjdCBvciBhbiBhcnJheSkgc2hvdWxkIGJlIG1lbW9pemVkOiBodHRwczovL3JlZHV4LmpzLm9yZy91c2FnZS9kZXJpdmluZy1kYXRhLXNlbGVjdG9ycyNvcHRpbWl6aW5nLXNlbGVjdG9ycy13aXRoLW1lbW9pemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQyOiB0b0NvbXBhcmUsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcImFsd2F5c1wiIHx8IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIHRoZSByb290IHN0YXRlIHdoZW4gY2FsbGVkLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy5cXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gdGhlIGVudGlyZSBzdGF0ZSBhcmUgYWxtb3N0IGNlcnRhaW5seSBhIG1pc3Rha2UsIGFzIHRoZXkgd2lsbCBjYXVzZSBhIHJlcmVuZGVyIHdoZW5ldmVyICphbnl0aGluZyogaW4gc3RhdGUgY2hhbmdlcy5cIixcbiAgICAgICAgICAgICAgICAgIHsgc3RhY2sgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFJ1bi5jdXJyZW50KVxuICAgICAgICAgICAgICBmaXJzdFJ1bi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfVtzZWxlY3Rvci5uYW1lXSxcbiAgICAgIFtzZWxlY3Rvciwgc3RhYmlsaXR5Q2hlY2ssIGRldk1vZGVDaGVja3Muc3RhYmlsaXR5Q2hlY2tdXG4gICAgKTtcbiAgICBjb25zdCBzZWxlY3RlZFN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdWJzY3JpcHRpb24uYWRkTmVzdGVkU3ViLFxuICAgICAgc3RvcmUuZ2V0U3RhdGUsXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZSB8fCBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICAgIGVxdWFsaXR5Rm5cbiAgICApO1xuICAgIFJlYWN0LnVzZURlYnVnVmFsdWUoc2VsZWN0ZWRTdGF0ZSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU2VsZWN0b3IyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTZWxlY3RvcjJcbiAgfSk7XG4gIHJldHVybiB1c2VTZWxlY3RvcjI7XG59XG52YXIgdXNlU2VsZWN0b3IgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2VsZWN0b3JIb29rKCk7XG5cbi8vIHNyYy91dGlscy9yZWFjdC1pcy50c1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpO1xudmFyIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc2VydmVyX2NvbnRleHRcIik7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIik7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6IHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRToge1xuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuXG4vLyBzcmMvdXRpbHMvd2FybmluZy50c1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICB0cnkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbi8vIHNyYy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy50c1xuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lKSB7XG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFsdWUgZm9yICR7bWV0aG9kTmFtZX0gaW4gY29ubmVjdC5gKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSBcIm1hcFN0YXRlVG9Qcm9wc1wiIHx8IG1ldGhvZE5hbWUgPT09IFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWxlY3RvciwgXCJkZXBlbmRzT25Pd25Qcm9wc1wiKSkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgYFRoZSBzZWxlY3RvciBmb3IgJHttZXRob2ROYW1lfSBvZiBjb25uZWN0IGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpO1xuICB2ZXJpZnkobWFwRGlzcGF0Y2hUb1Byb3BzLCBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKTtcbiAgdmVyaWZ5KG1lcmdlUHJvcHMsIFwibWVyZ2VQcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LnRzXG5mdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIHtcbiAgYXJlU3RhdGVzRXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbFxufSkge1xuICBsZXQgaGFzUnVuQXRMZWFzdE9uY2UgPSBmYWxzZTtcbiAgbGV0IHN0YXRlO1xuICBsZXQgb3duUHJvcHM7XG4gIGxldCBzdGF0ZVByb3BzO1xuICBsZXQgZGlzcGF0Y2hQcm9wcztcbiAgbGV0IG1lcmdlZFByb3BzO1xuICBmdW5jdGlvbiBoYW5kbGVGaXJzdENhbGwoZmlyc3RTdGF0ZSwgZmlyc3RPd25Qcm9wcykge1xuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHM7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIGhhc1J1bkF0TGVhc3RPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpIHtcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wcygpIHtcbiAgICBpZiAobWFwU3RhdGVUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3U3RhdGUoKSB7XG4gICAgY29uc3QgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZVByb3BzQ2hhbmdlZCA9ICFhcmVTdGF0ZVByb3BzRXF1YWwobmV4dFN0YXRlUHJvcHMsIHN0YXRlUHJvcHMpO1xuICAgIHN0YXRlUHJvcHMgPSBuZXh0U3RhdGVQcm9wcztcbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpXG4gICAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICBjb25zdCBwcm9wc0NoYW5nZWQgPSAhYXJlT3duUHJvcHNFcXVhbChuZXh0T3duUHJvcHMsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwoXG4gICAgICBuZXh0U3RhdGUsXG4gICAgICBzdGF0ZSxcbiAgICAgIG5leHRPd25Qcm9wcyxcbiAgICAgIG93blByb3BzXG4gICAgKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcbiAgICBpZiAocHJvcHNDaGFuZ2VkICYmIHN0YXRlQ2hhbmdlZClcbiAgICAgIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZClcbiAgICAgIHJldHVybiBoYW5kbGVOZXdQcm9wcygpO1xuICAgIGlmIChzdGF0ZUNoYW5nZWQpXG4gICAgICByZXR1cm4gaGFuZGxlTmV3U3RhdGUoKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIHtcbiAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgaW5pdE1lcmdlUHJvcHMsXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gaW5pdE1hcFN0YXRlVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBjb25zdCBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKTtcbiAgfVxuICByZXR1cm4gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL3V0aWxzL2JpbmRBY3Rpb25DcmVhdG9ycy50c1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBjb25zdCBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9ICguLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cbi8vIHNyYy91dGlscy9pc1BsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIGxldCBiYXNlUHJvdG8gPSBwcm90bztcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pICE9PSBudWxsKSB7XG4gICAgYmFzZVByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90byk7XG4gIH1cbiAgcmV0dXJuIHByb3RvID09PSBiYXNlUHJvdG87XG59XG5cbi8vIHNyYy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gdmVyaWZ5UGxhaW5PYmplY3QodmFsdWUsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgYCR7bWV0aG9kTmFtZX0oKSBpbiAke2Rpc3BsYXlOYW1lfSBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3ZhbHVlfS5gXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvY29ubmVjdC93cmFwTWFwVG9Qcm9wcy50c1xuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNDb25zdGFudChnZXRDb25zdGFudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdENvbnN0YW50U2VsZWN0b3IoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoKTtcbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cbiAgICBjb25zdGFudFNlbGVjdG9yLmRlcGVuZHNPbk93blByb3BzID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xufVxuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFRvUHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lIH0pIHtcbiAgICBjb25zdCBwcm94eSA9IGZ1bmN0aW9uIG1hcFRvUHJvcHNQcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICByZXR1cm4gcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPyBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIDogcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIHZvaWQgMCk7XG4gICAgfTtcbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgbGV0IHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG59XG5cbi8vIHNyYy9jb25uZWN0L2ludmFsaWRBcmdGYWN0b3J5LnRzXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShhcmcsIG5hbWUpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCwgb3B0aW9ucykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYXJnfSBmb3IgJHtuYW1lfSBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50ICR7b3B0aW9ucy53cmFwcGVkQ29tcG9uZW50TmFtZX0uYFxuICAgICk7XG4gIH07XG59XG5cbi8vIHNyYy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy50c1xuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcERpc3BhdGNoVG9Qcm9wcyAmJiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSBcIm9iamVjdFwiID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChcbiAgICAoZGlzcGF0Y2gpID0+IChcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGJpbmRBY3Rpb25DcmVhdG9ycyhtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKVxuICAgIClcbiAgKSA6ICFtYXBEaXNwYXRjaFRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KChkaXNwYXRjaCkgPT4gKHtcbiAgICBkaXNwYXRjaFxuICB9KSkgOiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpXG4gICkgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMudHNcbmZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwU3RhdGVUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoKSA9PiAoe30pKSA6IHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIilcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L21lcmdlUHJvcHMudHNcbmZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gIHJldHVybiB7IC4uLm93blByb3BzLCAuLi5zdGF0ZVByb3BzLCAuLi5kaXNwYXRjaFByb3BzIH07XG59XG5mdW5jdGlvbiB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdE1lcmdlUHJvcHNQcm94eShkaXNwYXRjaCwgeyBkaXNwbGF5TmFtZSwgYXJlTWVyZ2VkUHJvcHNFcXVhbCB9KSB7XG4gICAgbGV0IGhhc1J1bk9uY2UgPSBmYWxzZTtcbiAgICBsZXQgbWVyZ2VkUHJvcHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlUHJvcHNQcm94eShzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICAgICAgY29uc3QgbmV4dE1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgICBpZiAoaGFzUnVuT25jZSkge1xuICAgICAgICBpZiAoIWFyZU1lcmdlZFByb3BzRXF1YWwobmV4dE1lcmdlZFByb3BzLCBtZXJnZWRQcm9wcykpXG4gICAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNSdW5PbmNlID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QobWVyZ2VkUHJvcHMsIGRpc3BsYXlOYW1lLCBcIm1lcmdlUHJvcHNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gKCkgPT4gZGVmYXVsdE1lcmdlUHJvcHMgOiB0eXBlb2YgbWVyZ2VQcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xufVxuXG4vLyBzcmMvdXRpbHMvYmF0Y2gudHNcbmZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cblxuLy8gc3JjL3V0aWxzL1N1YnNjcmlwdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICBsZXQgZmlyc3QgPSBudWxsO1xuICBsZXQgbGFzdCA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgY2xlYXIoKSB7XG4gICAgICBmaXJzdCA9IG51bGw7XG4gICAgICBsYXN0ID0gbnVsbDtcbiAgICB9LFxuICAgIG5vdGlmeSgpIHtcbiAgICAgIGRlZmF1bHROb29wQmF0Y2goKCkgPT4ge1xuICAgICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soKTtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcbiAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIGxldCBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBsYXN0ID0ge1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgcHJldjogbGFzdFxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3QgPSBsaXN0ZW5lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgZmlyc3QgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxpc3RlbmVyLm5leHQpIHtcbiAgICAgICAgICBsaXN0ZW5lci5uZXh0LnByZXYgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdCA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxudmFyIG51bGxMaXN0ZW5lcnMgPSB7XG4gIG5vdGlmeSgpIHtcbiAgfSxcbiAgZ2V0OiAoKSA9PiBbXVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSwgcGFyZW50U3ViKSB7XG4gIGxldCB1bnN1YnNjcmliZTtcbiAgbGV0IGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gIGxldCBzdWJzY3JpcHRpb25zQW1vdW50ID0gMDtcbiAgbGV0IHNlbGZTdWJzY3JpYmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGFkZE5lc3RlZFN1YihsaXN0ZW5lcikge1xuICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIGNvbnN0IGNsZWFudXBMaXN0ZW5lciA9IGxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghcmVtb3ZlZCkge1xuICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyKCk7XG4gICAgICAgIHRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnlOZXN0ZWRTdWJzKCkge1xuICAgIGxpc3RlbmVycy5ub3RpZnkoKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VXcmFwcGVyKCkge1xuICAgIGlmIChzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBzZWxmU3Vic2NyaWJlZDtcbiAgfVxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgc3Vic2NyaXB0aW9uc0Ftb3VudCsrO1xuICAgIGlmICghdW5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3Vic2NyaWJlID0gcGFyZW50U3ViID8gcGFyZW50U3ViLmFkZE5lc3RlZFN1YihoYW5kbGVDaGFuZ2VXcmFwcGVyKSA6IHN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2VXcmFwcGVyKTtcbiAgICAgIGxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50LS07XG4gICAgaWYgKHVuc3Vic2NyaWJlICYmIHN1YnNjcmlwdGlvbnNBbW91bnQgPT09IDApIHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB1bnN1YnNjcmliZSA9IHZvaWQgMDtcbiAgICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlU2VsZigpIHtcbiAgICBpZiAoIXNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICB0cnlTdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmIChzZWxmU3Vic2NyaWJlZCkge1xuICAgICAgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIHRyeVVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICBhZGROZXN0ZWRTdWIsXG4gICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICBoYW5kbGVDaGFuZ2VXcmFwcGVyLFxuICAgIGlzU3Vic2NyaWJlZCxcbiAgICB0cnlTdWJzY3JpYmU6IHRyeVN1YnNjcmliZVNlbGYsXG4gICAgdHJ5VW5zdWJzY3JpYmU6IHRyeVVuc3Vic2NyaWJlU2VsZixcbiAgICBnZXRMaXN0ZW5lcnM6ICgpID0+IGxpc3RlbmVyc1xuICB9O1xuICByZXR1cm4gc3Vic2NyaXB0aW9uO1xufVxuXG4vLyBzcmMvdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdC50c1xudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIpO1xudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBjYW5Vc2VET00gPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5cbi8vIHNyYy91dGlscy9zaGFsbG93RXF1YWwudHNcbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2hvaXN0U3RhdGljcy50c1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7XG4gIFtGb3J3YXJkUmVmXTogRk9SV0FSRF9SRUZfU1RBVElDUyxcbiAgW01lbW9dOiBNRU1PX1NUQVRJQ1Ncbn07XG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICBpZiAoaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9XG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50W1wiJCR0eXBlb2ZcIl1dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICBjb25zdCBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgY29uc3Qgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9jb25uZWN0LnRzeFxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gbm90SW5pdGlhbGl6ZWQ7XG52YXIgaW5pdGlhbGl6ZUNvbm5lY3QgPSAoZm4pID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBmbjtcbn07XG52YXIgTk9fU1VCU0NSSVBUSU9OX0FSUkFZID0gW251bGwsIG51bGxdO1xudmFyIHN0cmluZ2lmeUNvbXBvbmVudCA9IChDb21wKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KENvbXApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGVmZmVjdEZ1bmMsIGVmZmVjdEFyZ3MsIGRlcGVuZGVuY2llcykge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGVmZmVjdEZ1bmMoLi4uZWZmZWN0QXJncyksIGRlcGVuZGVuY2llcyk7XG59XG5mdW5jdGlvbiBjYXB0dXJlV3JhcHBlclByb3BzKGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzKSB7XG4gIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCA9IHdyYXBwZXJQcm9wcztcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlO1xuICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50KSB7XG4gICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbnVsbDtcbiAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgaXNNb3VudGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIpIHtcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICBsZXQgZGlkVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgbGV0IGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gIGNvbnN0IGNoZWNrRm9yVXBkYXRlcyA9ICgpID0+IHtcbiAgICBpZiAoZGlkVW5zdWJzY3JpYmUgfHwgIWlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhdGVzdFN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGxldCBuZXdDaGlsZFByb3BzLCBlcnJvcjtcbiAgICB0cnkge1xuICAgICAgbmV3Q2hpbGRQcm9wcyA9IGNoaWxkUHJvcHNTZWxlY3RvcihcbiAgICAgICAgbGF0ZXN0U3RvcmVTdGF0ZSxcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IGU7XG4gICAgfVxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuZXdDaGlsZFByb3BzID09PSBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50KSB7XG4gICAgICBpZiAoIXJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQpIHtcbiAgICAgICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcigpO1xuICAgIH1cbiAgfTtcbiAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBjaGVja0ZvclVwZGF0ZXM7XG4gIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgY2hlY2tGb3JVcGRhdGVzKCk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlV3JhcHBlciA9ICgpID0+IHtcbiAgICBkaWRVbnN1YnNjcmliZSA9IHRydWU7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBudWxsO1xuICAgIGlmIChsYXN0VGhyb3duRXJyb3IpIHtcbiAgICAgIHRocm93IGxhc3RUaHJvd25FcnJvcjtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1bnN1YnNjcmliZVdyYXBwZXI7XG59XG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIHtcbiAgLy8gVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZCwgc28gVFMgZG9lc24ndCBsaWtlIHVzIGRlc3RydWN0dXJpbmcgdGhpcyB0byBjaGVjayBpdHMgZXhpc3RlbmNlLlxuICAvLyBAdHMtaWdub3JlXG4gIHB1cmUsXG4gIGFyZVN0YXRlc0VxdWFsID0gc3RyaWN0RXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgLy8gdXNlIFJlYWN0J3MgZm9yd2FyZFJlZiB0byBleHBvc2UgYSByZWYgb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50XG4gIGZvcndhcmRSZWYgPSBmYWxzZSxcbiAgLy8gdGhlIGNvbnRleHQgY29uc3VtZXIgdG8gdXNlXG4gIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dFxufSA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAocHVyZSAhPT0gdm9pZCAwICYmICFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICdUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBgY29ubmVjdGAgaXMgbm93IGFsd2F5cyBhIFwicHVyZS9tZW1vaXplZFwiIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0O1xuICBjb25zdCBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpO1xuICBjb25zdCBpbml0TWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpO1xuICBjb25zdCBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBCb29sZWFuKG1hcFN0YXRlVG9Qcm9wcyk7XG4gIGNvbnN0IHdyYXBXaXRoQ29ubmVjdCA9IChXcmFwcGVkQ29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc3QgaXNWYWxpZCA9IC8qIEBfX1BVUkVfXyAqLyBpc1ZhbGlkRWxlbWVudFR5cGUoV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IG11c3QgcGFzcyBhIGNvbXBvbmVudCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgY29ubmVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3N0cmluZ2lmeUNvbXBvbmVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCBcIkNvbXBvbmVudFwiO1xuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gYENvbm5lY3QoJHt3cmFwcGVkQ29tcG9uZW50TmFtZX0pYDtcbiAgICBjb25zdCBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0ge1xuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZSxcbiAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzLFxuICAgICAgYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbFxuICAgIH07XG4gICAgZnVuY3Rpb24gQ29ubmVjdEZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICBjb25zdCBbcHJvcHNDb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCB3cmFwcGVyUHJvcHNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZjIsIC4uLndyYXBwZXJQcm9wczIgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gW3Byb3BzLmNvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyLCB3cmFwcGVyUHJvcHMyXTtcbiAgICAgIH0sIFtwcm9wc10pO1xuICAgICAgY29uc3QgQ29udGV4dFRvVXNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCBSZXN1bHRDb250ZXh0ID0gQ29udGV4dDtcbiAgICAgICAgaWYgKHByb3BzQ29udGV4dD8uQ29uc3VtZXIpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gLyogQF9fUFVSRV9fICovIGlzQ29udGV4dENvbnN1bWVyKFxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzQ29udGV4dC5Db25zdW1lciwgbnVsbClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgYXMgYHByb3BzLmNvbnRleHRgXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlc3VsdENvbnRleHQgPSBwcm9wc0NvbnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZXN1bHRDb250ZXh0O1xuICAgICAgfSwgW3Byb3BzQ29udGV4dCwgQ29udGV4dF0pO1xuICAgICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0VG9Vc2UpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbVByb3BzID0gQm9vbGVhbihwcm9wcy5zdG9yZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5nZXRTdGF0ZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5kaXNwYXRjaCk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9IEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZS5zdG9yZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFkaWRTdG9yZUNvbWVGcm9tUHJvcHMgJiYgIWRpZFN0b3JlQ29tZUZyb21Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIHRoZSBjb250ZXh0IG9mIFwiJHtkaXNwbGF5TmFtZX1cIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgb3IgcGFzcyBhIGN1c3RvbSBSZWFjdCBjb250ZXh0IHByb3ZpZGVyIHRvIDxQcm92aWRlcj4gYW5kIHRoZSBjb3JyZXNwb25kaW5nIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gJHtkaXNwbGF5TmFtZX0gaW4gY29ubmVjdCBvcHRpb25zLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JlID0gZGlkU3RvcmVDb21lRnJvbVByb3BzID8gcHJvcHMuc3RvcmUgOiBjb250ZXh0VmFsdWUuc3RvcmU7XG4gICAgICBjb25zdCBnZXRTZXJ2ZXJTdGF0ZSA9IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID8gY29udGV4dFZhbHVlLmdldFNlcnZlclN0YXRlIDogc3RvcmUuZ2V0U3RhdGU7XG4gICAgICBjb25zdCBjaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnkoc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgfSwgW3N0b3JlXSk7XG4gICAgICBjb25zdCBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcylcbiAgICAgICAgICByZXR1cm4gTk9fU1VCU0NSSVBUSU9OX0FSUkFZO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24yID0gY3JlYXRlU3Vic2NyaXB0aW9uKFxuICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHZvaWQgMCA6IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgbm90aWZ5TmVzdGVkU3ViczIgPSBzdWJzY3JpcHRpb24yLm5vdGlmeU5lc3RlZFN1YnMuYmluZChzdWJzY3JpcHRpb24yKTtcbiAgICAgICAgcmV0dXJuIFtzdWJzY3JpcHRpb24yLCBub3RpZnlOZXN0ZWRTdWJzMl07XG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSk7XG4gICAgICBjb25zdCBvdmVycmlkZGVuQ29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChkaWRTdG9yZUNvbWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29udGV4dFZhbHVlLFxuICAgICAgICAgIHN1YnNjcmlwdGlvblxuICAgICAgICB9O1xuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZFByb3BzID0gUmVhY3QudXNlUmVmKCk7XG4gICAgICBjb25zdCBsYXN0V3JhcHBlclByb3BzID0gUmVhY3QudXNlUmVmKHdyYXBwZXJQcm9wcyk7XG4gICAgICBjb25zdCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlID0gUmVhY3QudXNlUmVmKCk7XG4gICAgICBjb25zdCByZW5kZXJJc1NjaGVkdWxlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBpc1Byb2Nlc3NpbmdEaXNwYXRjaCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IFJlYWN0LnVzZVJlZigpO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuICAgICAgY29uc3QgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgJiYgd3JhcHBlclByb3BzID09PSBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgd3JhcHBlclByb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfSwgW3N0b3JlLCB3cmFwcGVyUHJvcHNdKTtcbiAgICAgIGNvbnN0IHN1YnNjcmliZUZvclJlYWN0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZSA9IChyZWFjdExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlVXBkYXRlcyhcbiAgICAgICAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgICAgICBpc01vdW50ZWQsXG4gICAgICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICAgICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICAgICAgICAgIHJlYWN0TGlzdGVuZXJcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgICAgfSwgW3N1YnNjcmlwdGlvbl0pO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGNhcHR1cmVXcmFwcGVyUHJvcHMsIFtcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgbGFzdENoaWxkUHJvcHMsXG4gICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxuICAgICAgICB3cmFwcGVyUHJvcHMsXG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnNcbiAgICAgIF0pO1xuICAgICAgbGV0IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB0cnkge1xuICAgICAgICBhY3R1YWxDaGlsZFByb3BzID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgLy8gVE9ETyBXZSdyZSBwYXNzaW5nIHRocm91Z2ggYSBiaWcgd3JhcHBlciB0aGF0IGRvZXMgYSBidW5jaCBvZiBleHRyYSBzaWRlIGVmZmVjdHMgYmVzaWRlcyBzdWJzY3JpYmluZ1xuICAgICAgICAgIHN1YnNjcmliZUZvclJlYWN0LFxuICAgICAgICAgIC8vIFRPRE8gVGhpcyBpcyBpbmNyZWRpYmx5IGhhY2t5LiBXZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgc3RvcmUgdXBkYXRlIGFuZCBjYWxjdWxhdGVkIG5ldyBjaGlsZCBwcm9wcyxcbiAgICAgICAgICAvLyBUT0RPIGFuZCB3ZSdyZSBqdXN0IHBhc3NpbmcgdGhhdCB0aHJvdWdoIHNvIGl0IHRyaWdnZXJzIGEgcmUtcmVuZGVyIGZvciB1cyByYXRoZXIgdGhhbiByZWx5aW5nIG9uIGB1U0VTYC5cbiAgICAgICAgICBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgZ2V0U2VydmVyU3RhdGUgPyAoKSA9PiBjaGlsZFByb3BzU2VsZWN0b3IoZ2V0U2VydmVyU3RhdGUoKSwgd3JhcHBlclByb3BzKSA6IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvclxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgICAgICA7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gYFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcbiR7bGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrfVxuXG5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmFjdHVhbENoaWxkUHJvcHMsXG4gICAgICAgICAgICAgIHJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZlxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sIFtyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCBXcmFwcGVkQ29tcG9uZW50LCBhY3R1YWxDaGlsZFByb3BzXSk7XG4gICAgICBjb25zdCByZW5kZXJlZENoaWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFRvVXNlLlByb3ZpZGVyLCB7IHZhbHVlOiBvdmVycmlkZGVuQ29udGV4dFZhbHVlIH0sIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIH0sIFtDb250ZXh0VG9Vc2UsIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCwgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZV0pO1xuICAgICAgcmV0dXJuIHJlbmRlcmVkQ2hpbGQ7XG4gICAgfVxuICAgIGNvbnN0IF9Db25uZWN0ID0gUmVhY3QubWVtbyhDb25uZWN0RnVuY3Rpb24pO1xuICAgIGNvbnN0IENvbm5lY3QgPSBfQ29ubmVjdDtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBDb25uZWN0RnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICBpZiAoZm9yd2FyZFJlZikge1xuICAgICAgY29uc3QgX2ZvcndhcmRlZCA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gZm9yd2FyZENvbm5lY3RSZWYocHJvcHMsIHJlZikge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdCwgeyAuLi5wcm9wcywgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVmIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBmb3J3YXJkZWQgPSBfZm9yd2FyZGVkO1xuICAgICAgZm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICBmb3J3YXJkZWQuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKGZvcndhcmRlZCwgV3JhcHBlZENvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaG9pc3ROb25SZWFjdFN0YXRpY3MoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudCk7XG4gIH07XG4gIHJldHVybiB3cmFwV2l0aENvbm5lY3Q7XG59XG52YXIgY29ubmVjdF9kZWZhdWx0ID0gY29ubmVjdDtcblxuLy8gc3JjL2NvbXBvbmVudHMvUHJvdmlkZXIudHN4XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgc2VydmVyU3RhdGUsXG4gIHN0YWJpbGl0eUNoZWNrID0gXCJvbmNlXCIsXG4gIGlkZW50aXR5RnVuY3Rpb25DaGVjayA9IFwib25jZVwiXG59KSB7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3JlLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgZ2V0U2VydmVyU3RhdGU6IHNlcnZlclN0YXRlID8gKCkgPT4gc2VydmVyU3RhdGUgOiB2b2lkIDAsXG4gICAgICBzdGFiaWxpdHlDaGVjayxcbiAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVja1xuICAgIH07XG4gIH0sIFtzdG9yZSwgc2VydmVyU3RhdGUsIHN0YWJpbGl0eUNoZWNrLCBpZGVudGl0eUZ1bmN0aW9uQ2hlY2tdKTtcbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKSwgW3N0b3JlXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3Vic2NyaXB0aW9uIH0gPSBjb250ZXh0VmFsdWU7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicztcbiAgICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHN0b3JlLmdldFN0YXRlKCkpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gdm9pZCAwO1xuICAgIH07XG4gIH0sIFtjb250ZXh0VmFsdWUsIHByZXZpb3VzU3RhdGVdKTtcbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQgfHwgUmVhY3RSZWR1eENvbnRleHQ7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUgfSwgY2hpbGRyZW4pO1xufVxudmFyIFByb3ZpZGVyX2RlZmF1bHQgPSBQcm92aWRlcjtcblxuLy8gc3JjL2hvb2tzL3VzZVN0b3JlLnRzXG5mdW5jdGlvbiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dDIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVJlZHV4Q29udGV4dCA6IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KVxuICApO1xuICBjb25zdCB1c2VTdG9yZTIgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSB9ID0gdXNlUmVkdXhDb250ZXh0MigpO1xuICAgIHJldHVybiBzdG9yZTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTdG9yZTIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZVN0b3JlMlxuICB9KTtcbiAgcmV0dXJuIHVzZVN0b3JlMjtcbn1cbnZhciB1c2VTdG9yZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTdG9yZUhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZURpc3BhdGNoLnRzXG5mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVN0b3JlMiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlU3RvcmUgOiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCk7XG4gIGNvbnN0IHVzZURpc3BhdGNoMiA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlMigpO1xuICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaDtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VEaXNwYXRjaDIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZURpc3BhdGNoMlxuICB9KTtcbiAgcmV0dXJuIHVzZURpc3BhdGNoMjtcbn1cbnZhciB1c2VEaXNwYXRjaCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEaXNwYXRjaEhvb2soKTtcblxuLy8gc3JjL2V4cG9ydHMudHNcbnZhciBiYXRjaCA9IGRlZmF1bHROb29wQmF0Y2g7XG5cbi8vIHNyYy9pbmRleC50c1xuaW5pdGlhbGl6ZVVzZVNlbGVjdG9yKHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMik7XG5pbml0aWFsaXplQ29ubmVjdChSZWFjdDIudXNlU3luY0V4dGVybmFsU3RvcmUpO1xuZXhwb3J0IHtcbiAgUHJvdmlkZXJfZGVmYXVsdCBhcyBQcm92aWRlcixcbiAgUmVhY3RSZWR1eENvbnRleHQsXG4gIGJhdGNoLFxuICBjb25uZWN0X2RlZmF1bHQgYXMgY29ubmVjdCxcbiAgY3JlYXRlRGlzcGF0Y2hIb29rLFxuICBjcmVhdGVTZWxlY3Rvckhvb2ssXG4gIGNyZWF0ZVN0b3JlSG9vayxcbiAgc2hhbGxvd0VxdWFsLFxuICB1c2VEaXNwYXRjaCxcbiAgdXNlU2VsZWN0b3IsXG4gIHVzZVN0b3JlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtcmVkdXgubWpzLm1hcCJdLCJuYW1lcyI6WyJSZWFjdDIiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMiIsIlJlYWN0T3JpZ2luYWwiLCJSZWFjdCIsIkNvbnRleHRLZXkiLCJTeW1ib2wiLCJmb3IiLCJnVCIsImdsb2JhbFRoaXMiLCJnZXRDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImNvbnRleHRNYXAiLCJNYXAiLCJyZWFsQ29udGV4dCIsImdldCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSIsInNldCIsIlJlYWN0UmVkdXhDb250ZXh0Iiwibm90SW5pdGlhbGl6ZWQiLCJFcnJvciIsImNyZWF0ZVJlZHV4Q29udGV4dEhvb2siLCJjb250ZXh0IiwidXNlUmVkdXhDb250ZXh0MiIsImNvbnRleHRWYWx1ZSIsInVzZUNvbnRleHQiLCJ1c2VSZWR1eENvbnRleHQiLCJpbml0aWFsaXplVXNlU2VsZWN0b3IiLCJmbiIsInJlZkVxdWFsaXR5IiwiYSIsImIiLCJjcmVhdGVTZWxlY3Rvckhvb2siLCJ1c2VTZWxlY3RvcjIiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm5Pck9wdGlvbnMiLCJlcXVhbGl0eUZuIiwiZGV2TW9kZUNoZWNrcyIsInN0b3JlIiwic3Vic2NyaXB0aW9uIiwiZ2V0U2VydmVyU3RhdGUiLCJzdGFiaWxpdHlDaGVjayIsImlkZW50aXR5RnVuY3Rpb25DaGVjayIsImZpcnN0UnVuIiwidXNlUmVmIiwid3JhcHBlZFNlbGVjdG9yIiwidXNlQ2FsbGJhY2siLCJuYW1lIiwic3RhdGUiLCJzZWxlY3RlZCIsImZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwiZmluYWxTdGFiaWxpdHlDaGVjayIsImN1cnJlbnQiLCJ0b0NvbXBhcmUiLCJzdGFjayIsImUiLCJjb25zb2xlIiwid2FybiIsInNlbGVjdGVkMiIsInNlbGVjdGVkU3RhdGUiLCJhZGROZXN0ZWRTdWIiLCJnZXRTdGF0ZSIsInVzZURlYnVnVmFsdWUiLCJPYmplY3QiLCJhc3NpZ24iLCJ3aXRoVHlwZXMiLCJ1c2VTZWxlY3RvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSIsIkZvcndhcmRSZWYiLCJNZW1vIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwidHlwZSIsIiQkdHlwZW9mIiwiZ2V0TW9kdWxlSWQiLCJ0eXBlT2YiLCJvYmplY3QiLCIkJHR5cGVvZlR5cGUiLCJpc0NvbnRleHRDb25zdW1lciIsImlzTWVtbyIsIndhcm5pbmciLCJtZXNzYWdlIiwiZXJyb3IiLCJ2ZXJpZnkiLCJtZXRob2ROYW1lIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmVyaWZ5U3Vic2VsZWN0b3JzIiwibWFwU3RhdGVUb1Byb3BzIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwibWVyZ2VQcm9wcyIsInB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5IiwiZGlzcGF0Y2giLCJhcmVTdGF0ZXNFcXVhbCIsImFyZU93blByb3BzRXF1YWwiLCJhcmVTdGF0ZVByb3BzRXF1YWwiLCJoYXNSdW5BdExlYXN0T25jZSIsIm93blByb3BzIiwic3RhdGVQcm9wcyIsImRpc3BhdGNoUHJvcHMiLCJtZXJnZWRQcm9wcyIsImhhbmRsZUZpcnN0Q2FsbCIsImZpcnN0U3RhdGUiLCJmaXJzdE93blByb3BzIiwiaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSIsImRlcGVuZHNPbk93blByb3BzIiwiaGFuZGxlTmV3UHJvcHMiLCJoYW5kbGVOZXdTdGF0ZSIsIm5leHRTdGF0ZVByb3BzIiwic3RhdGVQcm9wc0NoYW5nZWQiLCJoYW5kbGVTdWJzZXF1ZW50Q2FsbHMiLCJuZXh0U3RhdGUiLCJuZXh0T3duUHJvcHMiLCJwcm9wc0NoYW5nZWQiLCJzdGF0ZUNoYW5nZWQiLCJwdXJlRmluYWxQcm9wc1NlbGVjdG9yIiwiZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsImluaXRNYXBTdGF0ZVRvUHJvcHMiLCJpbml0TWFwRGlzcGF0Y2hUb1Byb3BzIiwiaW5pdE1lcmdlUHJvcHMiLCJvcHRpb25zIiwiYmluZEFjdGlvbkNyZWF0b3JzIiwiYWN0aW9uQ3JlYXRvcnMiLCJib3VuZEFjdGlvbkNyZWF0b3JzIiwia2V5IiwiYWN0aW9uQ3JlYXRvciIsImFyZ3MiLCJpc1BsYWluT2JqZWN0Iiwib2JqIiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsImJhc2VQcm90byIsInZlcmlmeVBsYWluT2JqZWN0IiwidmFsdWUiLCJ3cmFwTWFwVG9Qcm9wc0NvbnN0YW50IiwiZ2V0Q29uc3RhbnQiLCJpbml0Q29uc3RhbnRTZWxlY3RvciIsImNvbnN0YW50IiwiY29uc3RhbnRTZWxlY3RvciIsImdldERlcGVuZHNPbk93blByb3BzIiwibWFwVG9Qcm9wcyIsIkJvb2xlYW4iLCJsZW5ndGgiLCJ3cmFwTWFwVG9Qcm9wc0Z1bmMiLCJpbml0UHJveHlTZWxlY3RvciIsInByb3h5IiwibWFwVG9Qcm9wc1Byb3h5Iiwic3RhdGVPckRpc3BhdGNoIiwiZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSIsInByb3BzIiwiY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkiLCJhcmciLCJ3cmFwcGVkQ29tcG9uZW50TmFtZSIsIm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkiLCJtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5IiwiZGVmYXVsdE1lcmdlUHJvcHMiLCJ3cmFwTWVyZ2VQcm9wc0Z1bmMiLCJpbml0TWVyZ2VQcm9wc1Byb3h5IiwiYXJlTWVyZ2VkUHJvcHNFcXVhbCIsImhhc1J1bk9uY2UiLCJtZXJnZVByb3BzUHJveHkiLCJuZXh0TWVyZ2VkUHJvcHMiLCJtZXJnZVByb3BzRmFjdG9yeSIsImRlZmF1bHROb29wQmF0Y2giLCJjYWxsYmFjayIsImNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbiIsImZpcnN0IiwibGFzdCIsImNsZWFyIiwibm90aWZ5IiwibGlzdGVuZXIiLCJuZXh0IiwibGlzdGVuZXJzIiwicHVzaCIsInN1YnNjcmliZSIsImlzU3Vic2NyaWJlZCIsInByZXYiLCJ1bnN1YnNjcmliZSIsIm51bGxMaXN0ZW5lcnMiLCJjcmVhdGVTdWJzY3JpcHRpb24iLCJwYXJlbnRTdWIiLCJzdWJzY3JpcHRpb25zQW1vdW50Iiwic2VsZlN1YnNjcmliZWQiLCJ0cnlTdWJzY3JpYmUiLCJjbGVhbnVwTGlzdGVuZXIiLCJyZW1vdmVkIiwidHJ5VW5zdWJzY3JpYmUiLCJub3RpZnlOZXN0ZWRTdWJzIiwiaGFuZGxlQ2hhbmdlV3JhcHBlciIsIm9uU3RhdGVDaGFuZ2UiLCJ0cnlTdWJzY3JpYmVTZWxmIiwidHJ5VW5zdWJzY3JpYmVTZWxmIiwiZ2V0TGlzdGVuZXJzIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsImlzIiwieCIsInkiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5cyIsImtleXNCIiwiaSIsIlJFQUNUX1NUQVRJQ1MiLCJjaGlsZENvbnRleHRUeXBlcyIsImNvbnRleHRUeXBlIiwiY29udGV4dFR5cGVzIiwiZGVmYXVsdFByb3BzIiwiZ2V0RGVmYXVsdFByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibWl4aW5zIiwicHJvcFR5cGVzIiwiS05PV05fU1RBVElDUyIsImNhbGxlciIsImNhbGxlZSIsImFyZ3VtZW50cyIsImFyaXR5IiwiRk9SV0FSRF9SRUZfU1RBVElDUyIsInJlbmRlciIsIk1FTU9fU1RBVElDUyIsImNvbXBhcmUiLCJUWVBFX1NUQVRJQ1MiLCJnZXRTdGF0aWNzIiwiY29tcG9uZW50IiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwib2JqZWN0UHJvdG90eXBlIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJpbmhlcml0ZWRDb21wb25lbnQiLCJjb25jYXQiLCJ0YXJnZXRTdGF0aWNzIiwic291cmNlU3RhdGljcyIsImRlc2NyaXB0b3IiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsImluaXRpYWxpemVDb25uZWN0IiwiTk9fU1VCU0NSSVBUSU9OX0FSUkFZIiwic3RyaW5naWZ5Q29tcG9uZW50IiwiQ29tcCIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnIiLCJTdHJpbmciLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MiLCJlZmZlY3RGdW5jIiwiZWZmZWN0QXJncyIsImRlcGVuZGVuY2llcyIsImNhcHR1cmVXcmFwcGVyUHJvcHMiLCJsYXN0V3JhcHBlclByb3BzIiwibGFzdENoaWxkUHJvcHMiLCJyZW5kZXJJc1NjaGVkdWxlZCIsIndyYXBwZXJQcm9wcyIsImNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUiLCJzdWJzY3JpYmVVcGRhdGVzIiwic2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzIiwiY2hpbGRQcm9wc1NlbGVjdG9yIiwiaXNNb3VudGVkIiwiYWRkaXRpb25hbFN1YnNjcmliZUxpc3RlbmVyIiwiZGlkVW5zdWJzY3JpYmUiLCJsYXN0VGhyb3duRXJyb3IiLCJjaGVja0ZvclVwZGF0ZXMiLCJsYXRlc3RTdG9yZVN0YXRlIiwibmV3Q2hpbGRQcm9wcyIsInVuc3Vic2NyaWJlV3JhcHBlciIsInN0cmljdEVxdWFsIiwiaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiIsImNvbm5lY3QiLCJwdXJlIiwiZm9yd2FyZFJlZiIsIkNvbnRleHQiLCJ3cmFwV2l0aENvbm5lY3QiLCJXcmFwcGVkQ29tcG9uZW50IiwiaXNWYWxpZCIsInNlbGVjdG9yRmFjdG9yeU9wdGlvbnMiLCJDb25uZWN0RnVuY3Rpb24iLCJwcm9wc0NvbnRleHQiLCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmIiwidXNlTWVtbyIsInJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyIiwid3JhcHBlclByb3BzMiIsIkNvbnRleHRUb1VzZSIsIlJlc3VsdENvbnRleHQiLCJDb25zdW1lciIsImRpZFN0b3JlQ29tZUZyb21Qcm9wcyIsImRpZFN0b3JlQ29tZUZyb21Db250ZXh0Iiwic3Vic2NyaXB0aW9uMiIsIm5vdGlmeU5lc3RlZFN1YnMyIiwiYmluZCIsIm92ZXJyaWRkZW5Db250ZXh0VmFsdWUiLCJpc1Byb2Nlc3NpbmdEaXNwYXRjaCIsImxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IiLCJhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IiLCJzdWJzY3JpYmVGb3JSZWFjdCIsInJlYWN0TGlzdGVuZXIiLCJhY3R1YWxDaGlsZFByb3BzIiwicmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50IiwicmVmIiwicmVuZGVyZWRDaGlsZCIsIlByb3ZpZGVyIiwiX0Nvbm5lY3QiLCJtZW1vIiwiQ29ubmVjdCIsIl9mb3J3YXJkZWQiLCJmb3J3YXJkQ29ubmVjdFJlZiIsImZvcndhcmRlZCIsImNvbm5lY3RfZGVmYXVsdCIsImNoaWxkcmVuIiwic2VydmVyU3RhdGUiLCJwcmV2aW91c1N0YXRlIiwiUHJvdmlkZXJfZGVmYXVsdCIsImNyZWF0ZVN0b3JlSG9vayIsInVzZVN0b3JlMiIsInVzZVN0b3JlIiwiY3JlYXRlRGlzcGF0Y2hIb29rIiwidXNlRGlzcGF0Y2gyIiwidXNlRGlzcGF0Y2giLCJiYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/redux-thunk/dist/redux-thunk.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/redux-thunk/dist/redux-thunk.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   thunk: function() { return /* binding */ thunk; },\n/* harmony export */   withExtraArgument: function() { return /* binding */ withExtraArgument; }\n/* harmony export */ });\n// src/index.ts\nfunction createThunkMiddleware(extraArgument) {\n    const middleware = (param)=>{\n        let { dispatch, getState } = param;\n        return (next)=>(action)=>{\n                if (typeof action === \"function\") {\n                    return action(dispatch, getState, extraArgument);\n                }\n                return next(action);\n            };\n    };\n    return middleware;\n}\nvar thunk = createThunkMiddleware();\nvar withExtraArgument = createThunkMiddleware;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWR1eC10aHVuay9kaXN0L3JlZHV4LXRodW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGVBQWU7QUFDZixTQUFTQSxzQkFBc0JDLGFBQWE7SUFDMUMsTUFBTUMsYUFBYTtZQUFDLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFO2VBQUssQ0FBQ0MsT0FBUyxDQUFDQztnQkFDeEQsSUFBSSxPQUFPQSxXQUFXLFlBQVk7b0JBQ2hDLE9BQU9BLE9BQU9ILFVBQVVDLFVBQVVIO2dCQUNwQztnQkFDQSxPQUFPSSxLQUFLQztZQUNkOztJQUNBLE9BQU9KO0FBQ1Q7QUFDQSxJQUFJSyxRQUFRUDtBQUNaLElBQUlRLG9CQUFvQlI7QUFJdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlZHV4LXRodW5rL2Rpc3QvcmVkdXgtdGh1bmsubWpzPzhhZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBjcmVhdGVUaHVua01pZGRsZXdhcmUoZXh0cmFBcmd1bWVudCkge1xuICBjb25zdCBtaWRkbGV3YXJlID0gKHsgZGlzcGF0Y2gsIGdldFN0YXRlIH0pID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFjdGlvbihkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhQXJndW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICB9O1xuICByZXR1cm4gbWlkZGxld2FyZTtcbn1cbnZhciB0aHVuayA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZSgpO1xudmFyIHdpdGhFeHRyYUFyZ3VtZW50ID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlO1xuZXhwb3J0IHtcbiAgdGh1bmssXG4gIHdpdGhFeHRyYUFyZ3VtZW50XG59O1xuIl0sIm5hbWVzIjpbImNyZWF0ZVRodW5rTWlkZGxld2FyZSIsImV4dHJhQXJndW1lbnQiLCJtaWRkbGV3YXJlIiwiZGlzcGF0Y2giLCJnZXRTdGF0ZSIsIm5leHQiLCJhY3Rpb24iLCJ0aHVuayIsIndpdGhFeHRyYUFyZ3VtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/redux-thunk/dist/redux-thunk.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/redux/dist/redux.mjs":
/*!*******************************************!*\
  !*** ./node_modules/redux/dist/redux.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __DO_NOT_USE__ActionTypes: function() { return /* binding */ actionTypes_default; },\n/* harmony export */   applyMiddleware: function() { return /* binding */ applyMiddleware; },\n/* harmony export */   bindActionCreators: function() { return /* binding */ bindActionCreators; },\n/* harmony export */   combineReducers: function() { return /* binding */ combineReducers; },\n/* harmony export */   compose: function() { return /* binding */ compose; },\n/* harmony export */   createStore: function() { return /* binding */ createStore; },\n/* harmony export */   isAction: function() { return /* binding */ isAction; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   legacy_createStore: function() { return /* binding */ legacy_createStore; }\n/* harmony export */ });\n// src/utils/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n    return \"Minified Redux error #\".concat(code, \"; visit https://redux.js.org/Errors?code=\").concat(code, \" for the full message or use the non-minified dev environment for full errors. \");\n}\n// src/utils/symbol-observable.ts\nvar $$observable = /* @__PURE__ */ (()=>typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\nvar symbol_observable_default = $$observable;\n// src/utils/actionTypes.ts\nvar randomString = ()=>Math.random().toString(36).substring(7).split(\"\").join(\".\");\nvar ActionTypes = {\n    INIT: \"@@redux/INIT\".concat(randomString()),\n    REPLACE: \"@@redux/REPLACE\".concat(randomString()),\n    PROBE_UNKNOWN_ACTION: ()=>\"@@redux/PROBE_UNKNOWN_ACTION\".concat(randomString())\n};\nvar actionTypes_default = ActionTypes;\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    let proto = obj;\n    while(Object.getPrototypeOf(proto) !== null){\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;\n}\n// src/utils/kindOf.ts\nfunction miniKindOf(val) {\n    if (val === void 0) return \"undefined\";\n    if (val === null) return \"null\";\n    const type = typeof val;\n    switch(type){\n        case \"boolean\":\n        case \"string\":\n        case \"number\":\n        case \"symbol\":\n        case \"function\":\n            {\n                return type;\n            }\n    }\n    if (Array.isArray(val)) return \"array\";\n    if (isDate(val)) return \"date\";\n    if (isError(val)) return \"error\";\n    const constructorName = ctorName(val);\n    switch(constructorName){\n        case \"Symbol\":\n        case \"Promise\":\n        case \"WeakMap\":\n        case \"WeakSet\":\n        case \"Map\":\n        case \"Set\":\n            return constructorName;\n    }\n    return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n}\nfunction ctorName(val) {\n    return typeof val.constructor === \"function\" ? val.constructor.name : null;\n}\nfunction isError(val) {\n    return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n}\nfunction isDate(val) {\n    if (val instanceof Date) return true;\n    return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n}\nfunction kindOf(val) {\n    let typeOfVal = typeof val;\n    if (true) {\n        typeOfVal = miniKindOf(val);\n    }\n    return typeOfVal;\n}\n// src/createStore.ts\nfunction createStore(reducer, preloadedState, enhancer) {\n    if (typeof reducer !== \"function\") {\n        throw new Error( false ? 0 : \"Expected the root reducer to be a function. Instead, received: '\".concat(kindOf(reducer), \"'\"));\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n        throw new Error( false ? 0 : \"It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n        enhancer = preloadedState;\n        preloadedState = void 0;\n    }\n    if (typeof enhancer !== \"undefined\") {\n        if (typeof enhancer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the enhancer to be a function. Instead, received: '\".concat(kindOf(enhancer), \"'\"));\n        }\n        return enhancer(createStore)(reducer, preloadedState);\n    }\n    let currentReducer = reducer;\n    let currentState = preloadedState;\n    let currentListeners = /* @__PURE__ */ new Map();\n    let nextListeners = currentListeners;\n    let listenerIdCounter = 0;\n    let isDispatching = false;\n    function ensureCanMutateNextListeners() {\n        if (nextListeners === currentListeners) {\n            nextListeners = /* @__PURE__ */ new Map();\n            currentListeners.forEach((listener, key)=>{\n                nextListeners.set(key, listener);\n            });\n        }\n    }\n    function getState() {\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.\");\n        }\n        return currentState;\n    }\n    function subscribe(listener) {\n        if (typeof listener !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the listener to be a function. Instead, received: '\".concat(kindOf(listener), \"'\"));\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.\");\n        }\n        let isSubscribed = true;\n        ensureCanMutateNextListeners();\n        const listenerId = listenerIdCounter++;\n        nextListeners.set(listenerId, listener);\n        return function unsubscribe() {\n            if (!isSubscribed) {\n                return;\n            }\n            if (isDispatching) {\n                throw new Error( false ? 0 : \"You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.\");\n            }\n            isSubscribed = false;\n            ensureCanMutateNextListeners();\n            nextListeners.delete(listenerId);\n            currentListeners = null;\n        };\n    }\n    function dispatch(action) {\n        if (!isPlainObject(action)) {\n            throw new Error( false ? 0 : \"Actions must be plain objects. Instead, the actual type was: '\".concat(kindOf(action), \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\"));\n        }\n        if (typeof action.type === \"undefined\") {\n            throw new Error( false ? 0 : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n        }\n        if (typeof action.type !== \"string\") {\n            throw new Error( false ? 0 : 'Action \"type\" property must be a string. Instead, the actual type was: \\''.concat(kindOf(action.type), \"'. Value was: '\").concat(action.type, \"' (stringified)\"));\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"Reducers may not dispatch actions.\");\n        }\n        try {\n            isDispatching = true;\n            currentState = currentReducer(currentState, action);\n        } finally{\n            isDispatching = false;\n        }\n        const listeners = currentListeners = nextListeners;\n        listeners.forEach((listener)=>{\n            listener();\n        });\n        return action;\n    }\n    function replaceReducer(nextReducer) {\n        if (typeof nextReducer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the nextReducer to be a function. Instead, received: '\".concat(kindOf(nextReducer)));\n        }\n        currentReducer = nextReducer;\n        dispatch({\n            type: actionTypes_default.REPLACE\n        });\n    }\n    function observable() {\n        const outerSubscribe = subscribe;\n        return {\n            /**\n       * The minimal observable subscription method.\n       * @param observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */ subscribe (observer) {\n                if (typeof observer !== \"object\" || observer === null) {\n                    throw new Error( false ? 0 : \"Expected the observer to be an object. Instead, received: '\".concat(kindOf(observer), \"'\"));\n                }\n                function observeState() {\n                    const observerAsObserver = observer;\n                    if (observerAsObserver.next) {\n                        observerAsObserver.next(getState());\n                    }\n                }\n                observeState();\n                const unsubscribe = outerSubscribe(observeState);\n                return {\n                    unsubscribe\n                };\n            },\n            [symbol_observable_default] () {\n                return this;\n            }\n        };\n    }\n    dispatch({\n        type: actionTypes_default.INIT\n    });\n    const store = {\n        dispatch,\n        subscribe,\n        getState,\n        replaceReducer,\n        [symbol_observable_default]: observable\n    };\n    return store;\n}\nfunction legacy_createStore(reducer, preloadedState, enhancer) {\n    return createStore(reducer, preloadedState, enhancer);\n}\n// src/utils/warning.ts\nfunction warning(message) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    try {\n        throw new Error(message);\n    } catch (e) {}\n}\n// src/combineReducers.ts\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n    const reducerKeys = Object.keys(reducers);\n    const argumentName = action && action.type === actionTypes_default.INIT ? \"preloadedState argument passed to createStore\" : \"previous state received by the reducer\";\n    if (reducerKeys.length === 0) {\n        return \"Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.\";\n    }\n    if (!isPlainObject(inputState)) {\n        return \"The \".concat(argumentName, ' has unexpected type of \"').concat(kindOf(inputState), '\". Expected argument to be an object with the following keys: \"').concat(reducerKeys.join('\", \"'), '\"');\n    }\n    const unexpectedKeys = Object.keys(inputState).filter((key)=>!reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);\n    unexpectedKeys.forEach((key)=>{\n        unexpectedKeyCache[key] = true;\n    });\n    if (action && action.type === actionTypes_default.REPLACE) return;\n    if (unexpectedKeys.length > 0) {\n        return \"Unexpected \".concat(unexpectedKeys.length > 1 ? \"keys\" : \"key\", ' \"').concat(unexpectedKeys.join('\", \"'), '\" found in ').concat(argumentName, '. Expected to find one of the known reducer keys instead: \"').concat(reducerKeys.join('\", \"'), '\". Unexpected keys will be ignored.');\n    }\n}\nfunction assertReducerShape(reducers) {\n    Object.keys(reducers).forEach((key)=>{\n        const reducer = reducers[key];\n        const initialState = reducer(void 0, {\n            type: actionTypes_default.INIT\n        });\n        if (typeof initialState === \"undefined\") {\n            throw new Error( false ? 0 : 'The slice reducer for key \"'.concat(key, \"\\\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.\"));\n        }\n        if (typeof reducer(void 0, {\n            type: actionTypes_default.PROBE_UNKNOWN_ACTION()\n        }) === \"undefined\") {\n            throw new Error( false ? 0 : 'The slice reducer for key \"'.concat(key, \"\\\" returned undefined when probed with a random type. Don't try to handle '\").concat(actionTypes_default.INIT, '\\' or other actions in \"redux/*\" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.'));\n        }\n    });\n}\nfunction combineReducers(reducers) {\n    const reducerKeys = Object.keys(reducers);\n    const finalReducers = {};\n    for(let i = 0; i < reducerKeys.length; i++){\n        const key = reducerKeys[i];\n        if (true) {\n            if (typeof reducers[key] === \"undefined\") {\n                warning('No reducer provided for key \"'.concat(key, '\"'));\n            }\n        }\n        if (typeof reducers[key] === \"function\") {\n            finalReducers[key] = reducers[key];\n        }\n    }\n    const finalReducerKeys = Object.keys(finalReducers);\n    let unexpectedKeyCache;\n    if (true) {\n        unexpectedKeyCache = {};\n    }\n    let shapeAssertionError;\n    try {\n        assertReducerShape(finalReducers);\n    } catch (e) {\n        shapeAssertionError = e;\n    }\n    return function combination() {\n        let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, action = arguments.length > 1 ? arguments[1] : void 0;\n        if (shapeAssertionError) {\n            throw shapeAssertionError;\n        }\n        if (true) {\n            const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n            if (warningMessage) {\n                warning(warningMessage);\n            }\n        }\n        let hasChanged = false;\n        const nextState = {};\n        for(let i = 0; i < finalReducerKeys.length; i++){\n            const key = finalReducerKeys[i];\n            const reducer = finalReducers[key];\n            const previousStateForKey = state[key];\n            const nextStateForKey = reducer(previousStateForKey, action);\n            if (typeof nextStateForKey === \"undefined\") {\n                const actionType = action && action.type;\n                throw new Error( false ? 0 : \"When called with an action of type \".concat(actionType ? '\"'.concat(String(actionType), '\"') : \"(unknown type)\", ', the slice reducer for key \"').concat(key, '\" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.'));\n            }\n            nextState[key] = nextStateForKey;\n            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n        }\n        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n        return hasChanged ? nextState : state;\n    };\n}\n// src/bindActionCreators.ts\nfunction bindActionCreator(actionCreator, dispatch) {\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return dispatch(actionCreator.apply(this, args));\n    };\n}\nfunction bindActionCreators(actionCreators, dispatch) {\n    if (typeof actionCreators === \"function\") {\n        return bindActionCreator(actionCreators, dispatch);\n    }\n    if (typeof actionCreators !== \"object\" || actionCreators === null) {\n        throw new Error( false ? 0 : \"bindActionCreators expected an object or a function, but instead received: '\".concat(kindOf(actionCreators), '\\'. Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?'));\n    }\n    const boundActionCreators = {};\n    for(const key in actionCreators){\n        const actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n        }\n    }\n    return boundActionCreators;\n}\n// src/compose.ts\nfunction compose() {\n    for(var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++){\n        funcs[_key] = arguments[_key];\n    }\n    if (funcs.length === 0) {\n        return (arg)=>arg;\n    }\n    if (funcs.length === 1) {\n        return funcs[0];\n    }\n    return funcs.reduce((a, b)=>function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            return a(b(...args));\n        });\n}\n// src/applyMiddleware.ts\nfunction applyMiddleware() {\n    for(var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++){\n        middlewares[_key] = arguments[_key];\n    }\n    return (createStore2)=>(reducer, preloadedState)=>{\n            const store = createStore2(reducer, preloadedState);\n            let dispatch = ()=>{\n                throw new Error( false ? 0 : \"Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.\");\n            };\n            const middlewareAPI = {\n                getState: store.getState,\n                dispatch: function(action) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    return dispatch(action, ...args);\n                }\n            };\n            const chain = middlewares.map((middleware)=>middleware(middlewareAPI));\n            dispatch = compose(...chain)(store.dispatch);\n            return {\n                ...store,\n                dispatch\n            };\n        };\n}\n// src/utils/isAction.ts\nfunction isAction(action) {\n    return isPlainObject(action) && \"type\" in action && typeof action.type === \"string\";\n}\n //# sourceMappingURL=redux.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWR1eC9kaXN0L3JlZHV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxzQ0FBc0M7QUFDdEMsU0FBU0EsdUJBQXVCQyxJQUFJO0lBQ2xDLE9BQU8seUJBQXlFQSxPQUFoREEsTUFBSyw2Q0FBZ0QsT0FBTEEsTUFBSztBQUN2RjtBQUVBLGlDQUFpQztBQUNqQyxJQUFJQyxlQUErQixhQUFILEdBQUksS0FBTSxPQUFPQyxXQUFXLGNBQWNBLE9BQU9DLFVBQVUsSUFBSSxjQUFhO0FBQzVHLElBQUlDLDRCQUE0Qkg7QUFFaEMsMkJBQTJCO0FBQzNCLElBQUlJLGVBQWUsSUFBTUMsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUdDLEtBQUssQ0FBQyxJQUFJQyxJQUFJLENBQUM7QUFDaEYsSUFBSUMsY0FBYztJQUNoQkMsTUFBTSxlQUE4QyxPQUFmUjtJQUNyQ1MsU0FBUyxrQkFBaUQsT0FBZlQ7SUFDM0NVLHNCQUFzQixJQUFNLCtCQUE4QyxPQUFmVjtBQUM3RDtBQUNBLElBQUlXLHNCQUFzQko7QUFFMUIsNkJBQTZCO0FBQzdCLFNBQVNLLGNBQWNDLEdBQUc7SUFDeEIsSUFBSSxPQUFPQSxRQUFRLFlBQVlBLFFBQVEsTUFDckMsT0FBTztJQUNULElBQUlDLFFBQVFEO0lBQ1osTUFBT0UsT0FBT0MsY0FBYyxDQUFDRixXQUFXLEtBQU07UUFDNUNBLFFBQVFDLE9BQU9DLGNBQWMsQ0FBQ0Y7SUFDaEM7SUFDQSxPQUFPQyxPQUFPQyxjQUFjLENBQUNILFNBQVNDLFNBQVNDLE9BQU9DLGNBQWMsQ0FBQ0gsU0FBUztBQUNoRjtBQUVBLHNCQUFzQjtBQUN0QixTQUFTSSxXQUFXQyxHQUFHO0lBQ3JCLElBQUlBLFFBQVEsS0FBSyxHQUNmLE9BQU87SUFDVCxJQUFJQSxRQUFRLE1BQ1YsT0FBTztJQUNULE1BQU1DLE9BQU8sT0FBT0Q7SUFDcEIsT0FBUUM7UUFD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QUFNNUIsTUFBTSxLQUFLLEdBQUc7UUFDdEIsT0FBTyxDQUFDNkIsTUFBUUE7SUFDbEI7SUFDQSxJQUFJRCxNQUFNNUIsTUFBTSxLQUFLLEdBQUc7UUFDdEIsT0FBTzRCLEtBQUssQ0FBQyxFQUFFO0lBQ2pCO0lBQ0EsT0FBT0EsTUFBTUUsTUFBTSxDQUFDLENBQUNDLEdBQUdDLElBQU07NkNBQUlWO2dCQUFBQTs7bUJBQVNTLEVBQUVDLEtBQUtWOztBQUNwRDtBQUVBLHlCQUF5QjtBQUN6QixTQUFTVztJQUFnQjtRQUFHQyxZQUFILHVCQUFjOztJQUNyQyxPQUFPLENBQUNDLGVBQWlCLENBQUNoRixTQUFTQztZQUNqQyxNQUFNK0IsUUFBUWdELGFBQWFoRixTQUFTQztZQUNwQyxJQUFJcUIsV0FBVztnQkFDYixNQUFNLElBQUlqQyxNQUFNUyxNQUFxQyxHQUFHaEQsQ0FBMEIsR0FBRztZQUN2RjtZQUNBLE1BQU1tSSxnQkFBZ0I7Z0JBQ3BCakUsVUFBVWdCLE1BQU1oQixRQUFRO2dCQUN4Qk0sVUFBVSxTQUFDQztxREFBVzRDO3dCQUFBQTs7MkJBQVM3QyxTQUFTQyxXQUFXNEM7O1lBQ3JEO1lBQ0EsTUFBTWUsUUFBUUgsWUFBWUksR0FBRyxDQUFDLENBQUNDLGFBQWVBLFdBQVdIO1lBQ3pEM0QsV0FBV2tELFdBQVdVLE9BQU9sRCxNQUFNVixRQUFRO1lBQzNDLE9BQU87Z0JBQ0wsR0FBR1UsS0FBSztnQkFDUlY7WUFDRjtRQUNGO0FBQ0Y7QUFFQSx3QkFBd0I7QUFDeEIsU0FBUytELFNBQVM5RCxNQUFNO0lBQ3RCLE9BQU92RCxjQUFjdUQsV0FBVyxVQUFVQSxVQUFVLE9BQU9BLE9BQU9oRCxJQUFJLEtBQUs7QUFDN0U7QUFXRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVkdXgvZGlzdC9yZWR1eC5tanM/YTQzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS50c1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHJldHVybiBgTWluaWZpZWQgUmVkdXggZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXguanMub3JnL0Vycm9ycz9jb2RlPSR7Y29kZX0gZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gYDtcbn1cblxuLy8gc3JjL3V0aWxzL3N5bWJvbC1vYnNlcnZhYmxlLnRzXG52YXIgJCRvYnNlcnZhYmxlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgXCJAQG9ic2VydmFibGVcIikoKTtcbnZhciBzeW1ib2xfb2JzZXJ2YWJsZV9kZWZhdWx0ID0gJCRvYnNlcnZhYmxlO1xuXG4vLyBzcmMvdXRpbHMvYWN0aW9uVHlwZXMudHNcbnZhciByYW5kb21TdHJpbmcgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoXCJcIikuam9pbihcIi5cIik7XG52YXIgQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6IGBAQHJlZHV4L0lOSVQkey8qIEBfX1BVUkVfXyAqLyByYW5kb21TdHJpbmcoKX1gLFxuICBSRVBMQUNFOiBgQEByZWR1eC9SRVBMQUNFJHsvKiBAX19QVVJFX18gKi8gcmFuZG9tU3RyaW5nKCl9YCxcbiAgUFJPQkVfVU5LTk9XTl9BQ1RJT046ICgpID0+IGBAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OJHtyYW5kb21TdHJpbmcoKX1gXG59O1xudmFyIGFjdGlvblR5cGVzX2RlZmF1bHQgPSBBY3Rpb25UeXBlcztcblxuLy8gc3JjL3V0aWxzL2lzUGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGxldCBwcm90byA9IG9iajtcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBwcm90byB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gbnVsbDtcbn1cblxuLy8gc3JjL3V0aWxzL2tpbmRPZi50c1xuZnVuY3Rpb24gbWluaUtpbmRPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICBpZiAodmFsID09PSBudWxsKVxuICAgIHJldHVybiBcIm51bGxcIjtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6IHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKVxuICAgIHJldHVybiBcImFycmF5XCI7XG4gIGlmIChpc0RhdGUodmFsKSlcbiAgICByZXR1cm4gXCJkYXRlXCI7XG4gIGlmIChpc0Vycm9yKHZhbCkpXG4gICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgY29uc3QgY29uc3RydWN0b3JOYW1lID0gY3Rvck5hbWUodmFsKTtcbiAgc3dpdGNoIChjb25zdHJ1Y3Rvck5hbWUpIHtcbiAgICBjYXNlIFwiU3ltYm9sXCI6XG4gICAgY2FzZSBcIlByb21pc2VcIjpcbiAgICBjYXNlIFwiV2Vha01hcFwiOlxuICAgIGNhc2UgXCJXZWFrU2V0XCI6XG4gICAgY2FzZSBcIk1hcFwiOlxuICAgIGNhc2UgXCJTZXRcIjpcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvck5hbWU7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGN0b3JOYW1lKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbC5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiID8gdmFsLmNvbnN0cnVjdG9yLm5hbWUgOiBudWxsO1xufVxuZnVuY3Rpb24gaXNFcnJvcih2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiB2YWwubWVzc2FnZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC50b0RhdGVTdHJpbmcgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdmFsLmdldERhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdmFsLnNldERhdGUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgbGV0IHR5cGVPZlZhbCA9IHR5cGVvZiB2YWw7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0eXBlT2ZWYWwgPSBtaW5pS2luZE9mKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVPZlZhbDtcbn1cblxuLy8gc3JjL2NyZWF0ZVN0b3JlLnRzXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyKSA6IGBFeHBlY3RlZCB0aGUgcm9vdCByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2YocmVkdWNlcil9J2ApO1xuICB9XG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZW5oYW5jZXIgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgZW5oYW5jZXIgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYXJndW1lbnRzWzNdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgwKSA6IFwiSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gY3JlYXRlU3RvcmUoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJbnN0ZWFkLCBjb21wb3NlIHRoZW0gdG9nZXRoZXIgdG8gYSBzaW5nbGUgZnVuY3Rpb24uIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNjcmVhdGluZy1hLXN0b3JlLXdpdGgtZW5oYW5jZXJzIGZvciBhbiBleGFtcGxlLlwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGVuaGFuY2VyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHZvaWQgMDtcbiAgfVxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxKSA6IGBFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihlbmhhbmNlcil9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuICBsZXQgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICBsZXQgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIGxldCBjdXJyZW50TGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICBsZXQgbGlzdGVuZXJJZENvdW50ZXIgPSAwO1xuICBsZXQgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGN1cnJlbnRMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIsIGtleSkgPT4ge1xuICAgICAgICBuZXh0TGlzdGVuZXJzLnNldChrZXksIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMykgOiBcIllvdSBtYXkgbm90IGNhbGwgc3RvcmUuZ2V0U3RhdGUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuIFRoZSByZWR1Y2VyIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHRoZSBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gUGFzcyBpdCBkb3duIGZyb20gdGhlIHRvcCByZWR1Y2VyIGluc3RlYWQgb2YgcmVhZGluZyBpdCBmcm9tIHRoZSBzdG9yZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0KSA6IGBFeHBlY3RlZCB0aGUgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihsaXN0ZW5lcil9J2ApO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNSkgOiBcIllvdSBtYXkgbm90IGNhbGwgc3RvcmUuc3Vic2NyaWJlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiBJZiB5b3Ugd291bGQgbGlrZSB0byBiZSBub3RpZmllZCBhZnRlciB0aGUgc3RvcmUgaGFzIGJlZW4gdXBkYXRlZCwgc3Vic2NyaWJlIGZyb20gYSBjb21wb25lbnQgYW5kIGludm9rZSBzdG9yZS5nZXRTdGF0ZSgpIGluIHRoZSBjYWxsYmFjayB0byBhY2Nlc3MgdGhlIGxhdGVzdCBzdGF0ZS4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLlwiKTtcbiAgICB9XG4gICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIGNvbnN0IGxpc3RlbmVySWQgPSBsaXN0ZW5lcklkQ291bnRlcisrO1xuICAgIG5leHRMaXN0ZW5lcnMuc2V0KGxpc3RlbmVySWQsIGxpc3RlbmVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2KSA6IFwiWW91IG1heSBub3QgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGxpc3RlbmVyIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLlwiKTtcbiAgICAgIH1cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgbmV4dExpc3RlbmVycy5kZWxldGUobGlzdGVuZXJJZCk7XG4gICAgICBjdXJyZW50TGlzdGVuZXJzID0gbnVsbDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IGBBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gSW5zdGVhZCwgdGhlIGFjdHVhbCB0eXBlIHdhczogJyR7a2luZE9mKGFjdGlvbil9Jy4gWW91IG1heSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRvIHlvdXIgc3RvcmUgc2V0dXAgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIG90aGVyIHZhbHVlcywgc3VjaCBhcyAncmVkdXgtdGh1bmsnIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBmdW5jdGlvbnMuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNtaWRkbGV3YXJlIGFuZCBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNi1hc3luYy1sb2dpYyN1c2luZy10aGUtcmVkdXgtdGh1bmstbWlkZGxld2FyZSBmb3IgZXhhbXBsZXMuYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYW4gYWN0aW9uIHR5cGUgc3RyaW5nIGNvbnN0YW50LicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNykgOiBgQWN0aW9uIFwidHlwZVwiIHByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcuIEluc3RlYWQsIHRoZSBhY3R1YWwgdHlwZSB3YXM6ICcke2tpbmRPZihhY3Rpb24udHlwZSl9Jy4gVmFsdWUgd2FzOiAnJHthY3Rpb24udHlwZX0nIChzdHJpbmdpZmllZClgKTtcbiAgICB9XG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkpIDogXCJSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3Rpb247XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEwKSA6IGBFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihuZXh0UmVkdWNlcil9YCk7XG4gICAgfVxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5SRVBMQUNFXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICBjb25zdCBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSBcIm9iamVjdFwiIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogYEV4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2Yob2JzZXJ2ZXIpfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgY29uc3Qgb2JzZXJ2ZXJBc09ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgICAgaWYgKG9ic2VydmVyQXNPYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlckFzT2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFtzeW1ib2xfb2JzZXJ2YWJsZV9kZWZhdWx0XSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkaXNwYXRjaCh7XG4gICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5JTklUXG4gIH0pO1xuICBjb25zdCBzdG9yZSA9IHtcbiAgICBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXIsXG4gICAgW3N5bWJvbF9vYnNlcnZhYmxlX2RlZmF1bHRdOiBvYnNlcnZhYmxlXG4gIH07XG4gIHJldHVybiBzdG9yZTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9jcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcik7XG59XG5cbi8vIHNyYy91dGlscy93YXJuaW5nLnRzXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuLy8gc3JjL2NvbWJpbmVSZWR1Y2Vycy50c1xuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgY29uc3QgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIGNvbnN0IGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gYWN0aW9uVHlwZXNfZGVmYXVsdC5JTklUID8gXCJwcmVsb2FkZWRTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmVcIiA6IFwicHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXJcIjtcbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlN0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnMgaXMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgcmVkdWNlcnMuXCI7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuIGBUaGUgJHthcmd1bWVudE5hbWV9IGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCIke2tpbmRPZihpbnB1dFN0YXRlKX1cIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBrZXlzOiBcIiR7cmVkdWNlcktleXMuam9pbignXCIsIFwiJyl9XCJgO1xuICB9XG4gIGNvbnN0IHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKChrZXkpID0+ICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSk7XG4gIHVuZXhwZWN0ZWRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IGFjdGlvblR5cGVzX2RlZmF1bHQuUkVQTEFDRSlcbiAgICByZXR1cm47XG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGBVbmV4cGVjdGVkICR7dW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/IFwia2V5c1wiIDogXCJrZXlcIn0gXCIke3VuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpfVwiIGZvdW5kIGluICR7YXJndW1lbnROYW1lfS4gRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiBcIiR7cmVkdWNlcktleXMuam9pbignXCIsIFwiJyl9XCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuYDtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHZvaWQgMCwge1xuICAgICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5JTklUXG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IGBUaGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHZvaWQgMCwge1xuICAgICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5QUk9CRV9VTktOT1dOX0FDVElPTigpXG4gICAgfSkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEzKSA6IGBUaGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gRG9uJ3QgdHJ5IHRvIGhhbmRsZSAnJHthY3Rpb25UeXBlc19kZWZhdWx0LklOSVR9JyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiIG5hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSBhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQsIGJ1dCBjYW4gYmUgbnVsbC5gKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJzKSB7XG4gIGNvbnN0IHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICBjb25zdCBmaW5hbFJlZHVjZXJzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgd2FybmluZyhgTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJHtrZXl9XCJgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcbiAgbGV0IHVuZXhwZWN0ZWRLZXlDYWNoZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG4gIGxldCBzaGFwZUFzc2VydGlvbkVycm9yO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTaGFwZShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbihzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgICBpZiAoc2hhcGVBc3NlcnRpb25FcnJvcikge1xuICAgICAgdGhyb3cgc2hhcGVBc3NlcnRpb25FcnJvcjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSk7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgd2FybmluZyh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgbmV4dFN0YXRlID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBmaW5hbFJlZHVjZXJLZXlzW2ldO1xuICAgICAgY29uc3QgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNba2V5XTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtrZXldO1xuICAgICAgY29uc3QgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTQpIDogYFdoZW4gY2FsbGVkIHdpdGggYW4gYWN0aW9uIG9mIHR5cGUgJHthY3Rpb25UeXBlID8gYFwiJHtTdHJpbmcoYWN0aW9uVHlwZSl9XCJgIDogXCIodW5rbm93biB0eXBlKVwifSwgdGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7a2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZC4gVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLiBJZiB5b3Ugd2FudCB0aGlzIHJlZHVjZXIgdG8gaG9sZCBubyB2YWx1ZSwgeW91IGNhbiByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZVtrZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cbiAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoc3RhdGUpLmxlbmd0aDtcbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG4vLyBzcmMvYmluZEFjdGlvbkNyZWF0b3JzLnRzXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gXCJvYmplY3RcIiB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IGBiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGJ1dCBpbnN0ZWFkIHJlY2VpdmVkOiAnJHtraW5kT2YoYWN0aW9uQ3JlYXRvcnMpfScuIERpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/YCk7XG4gIH1cbiAgY29uc3QgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIGNvbnN0IGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG4vLyBzcmMvY29tcG9zZS50c1xuZnVuY3Rpb24gY29tcG9zZSguLi5mdW5jcykge1xuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhcmcpID0+IGFyZztcbiAgfVxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG4gIHJldHVybiBmdW5jcy5yZWR1Y2UoKGEsIGIpID0+ICguLi5hcmdzKSA9PiBhKGIoLi4uYXJncykpKTtcbn1cblxuLy8gc3JjL2FwcGx5TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKSB7XG4gIHJldHVybiAoY3JlYXRlU3RvcmUyKSA9PiAocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlMihyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gICAgbGV0IGRpc3BhdGNoID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUpIDogXCJEaXNwYXRjaGluZyB3aGlsZSBjb25zdHJ1Y3RpbmcgeW91ciBtaWRkbGV3YXJlIGlzIG5vdCBhbGxvd2VkLiBPdGhlciBtaWRkbGV3YXJlIHdvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIHRoaXMgZGlzcGF0Y2guXCIpO1xuICAgIH07XG4gICAgY29uc3QgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIGRpc3BhdGNoOiAoYWN0aW9uLCAuLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb24sIC4uLmFyZ3MpXG4gICAgfTtcbiAgICBjb25zdCBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcCgobWlkZGxld2FyZSkgPT4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKSk7XG4gICAgZGlzcGF0Y2ggPSBjb21wb3NlKC4uLmNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0b3JlLFxuICAgICAgZGlzcGF0Y2hcbiAgICB9O1xuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvaXNBY3Rpb24udHNcbmZ1bmN0aW9uIGlzQWN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChhY3Rpb24pICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCI7XG59XG5leHBvcnQge1xuICBhY3Rpb25UeXBlc19kZWZhdWx0IGFzIF9fRE9fTk9UX1VTRV9fQWN0aW9uVHlwZXMsXG4gIGFwcGx5TWlkZGxld2FyZSxcbiAgYmluZEFjdGlvbkNyZWF0b3JzLFxuICBjb21iaW5lUmVkdWNlcnMsXG4gIGNvbXBvc2UsXG4gIGNyZWF0ZVN0b3JlLFxuICBpc0FjdGlvbixcbiAgaXNQbGFpbk9iamVjdCxcbiAgbGVnYWN5X2NyZWF0ZVN0b3JlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgubWpzLm1hcCJdLCJuYW1lcyI6WyJmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwiY29kZSIsIiQkb2JzZXJ2YWJsZSIsIlN5bWJvbCIsIm9ic2VydmFibGUiLCJzeW1ib2xfb2JzZXJ2YWJsZV9kZWZhdWx0IiwicmFuZG9tU3RyaW5nIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwic3BsaXQiLCJqb2luIiwiQWN0aW9uVHlwZXMiLCJJTklUIiwiUkVQTEFDRSIsIlBST0JFX1VOS05PV05fQUNUSU9OIiwiYWN0aW9uVHlwZXNfZGVmYXVsdCIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwibWluaUtpbmRPZiIsInZhbCIsInR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJpc0RhdGUiLCJpc0Vycm9yIiwiY29uc3RydWN0b3JOYW1lIiwiY3Rvck5hbWUiLCJwcm90b3R5cGUiLCJjYWxsIiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJFcnJvciIsIm1lc3NhZ2UiLCJzdGFja1RyYWNlTGltaXQiLCJEYXRlIiwidG9EYXRlU3RyaW5nIiwiZ2V0RGF0ZSIsInNldERhdGUiLCJraW5kT2YiLCJ0eXBlT2ZWYWwiLCJwcm9jZXNzIiwiY3JlYXRlU3RvcmUiLCJyZWR1Y2VyIiwicHJlbG9hZGVkU3RhdGUiLCJlbmhhbmNlciIsImFyZ3VtZW50cyIsImN1cnJlbnRSZWR1Y2VyIiwiY3VycmVudFN0YXRlIiwiY3VycmVudExpc3RlbmVycyIsIk1hcCIsIm5leHRMaXN0ZW5lcnMiLCJsaXN0ZW5lcklkQ291bnRlciIsImlzRGlzcGF0Y2hpbmciLCJlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzIiwiZm9yRWFjaCIsImxpc3RlbmVyIiwia2V5Iiwic2V0IiwiZ2V0U3RhdGUiLCJzdWJzY3JpYmUiLCJpc1N1YnNjcmliZWQiLCJsaXN0ZW5lcklkIiwidW5zdWJzY3JpYmUiLCJkZWxldGUiLCJkaXNwYXRjaCIsImFjdGlvbiIsImxpc3RlbmVycyIsInJlcGxhY2VSZWR1Y2VyIiwibmV4dFJlZHVjZXIiLCJvdXRlclN1YnNjcmliZSIsIm9ic2VydmVyIiwib2JzZXJ2ZVN0YXRlIiwib2JzZXJ2ZXJBc09ic2VydmVyIiwibmV4dCIsInN0b3JlIiwibGVnYWN5X2NyZWF0ZVN0b3JlIiwid2FybmluZyIsImNvbnNvbGUiLCJlcnJvciIsImUiLCJnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlIiwiaW5wdXRTdGF0ZSIsInJlZHVjZXJzIiwidW5leHBlY3RlZEtleUNhY2hlIiwicmVkdWNlcktleXMiLCJrZXlzIiwiYXJndW1lbnROYW1lIiwibGVuZ3RoIiwidW5leHBlY3RlZEtleXMiLCJmaWx0ZXIiLCJoYXNPd25Qcm9wZXJ0eSIsImFzc2VydFJlZHVjZXJTaGFwZSIsImluaXRpYWxTdGF0ZSIsImNvbWJpbmVSZWR1Y2VycyIsImZpbmFsUmVkdWNlcnMiLCJpIiwiZmluYWxSZWR1Y2VyS2V5cyIsInNoYXBlQXNzZXJ0aW9uRXJyb3IiLCJjb21iaW5hdGlvbiIsInN0YXRlIiwid2FybmluZ01lc3NhZ2UiLCJoYXNDaGFuZ2VkIiwibmV4dFN0YXRlIiwicHJldmlvdXNTdGF0ZUZvcktleSIsIm5leHRTdGF0ZUZvcktleSIsImFjdGlvblR5cGUiLCJTdHJpbmciLCJiaW5kQWN0aW9uQ3JlYXRvciIsImFjdGlvbkNyZWF0b3IiLCJhcmdzIiwiYXBwbHkiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJhY3Rpb25DcmVhdG9ycyIsImJvdW5kQWN0aW9uQ3JlYXRvcnMiLCJjb21wb3NlIiwiZnVuY3MiLCJhcmciLCJyZWR1Y2UiLCJhIiwiYiIsImFwcGx5TWlkZGxld2FyZSIsIm1pZGRsZXdhcmVzIiwiY3JlYXRlU3RvcmUyIiwibWlkZGxld2FyZUFQSSIsImNoYWluIiwibWFwIiwibWlkZGxld2FyZSIsImlzQWN0aW9uIiwiX19ET19OT1RfVVNFX19BY3Rpb25UeXBlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/redux/dist/redux.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/reselect/dist/reselect.mjs":
/*!*************************************************!*\
  !*** ./node_modules/reselect/dist/reselect.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSelector: function() { return /* binding */ createSelector; },\n/* harmony export */   createSelectorCreator: function() { return /* binding */ createSelectorCreator; },\n/* harmony export */   createStructuredSelector: function() { return /* binding */ createStructuredSelector; },\n/* harmony export */   lruMemoize: function() { return /* binding */ lruMemoize; },\n/* harmony export */   referenceEqualityCheck: function() { return /* binding */ referenceEqualityCheck; },\n/* harmony export */   setGlobalDevModeChecks: function() { return /* binding */ setGlobalDevModeChecks; },\n/* harmony export */   unstable_autotrackMemoize: function() { return /* binding */ autotrackMemoize; },\n/* harmony export */   weakMapMemoize: function() { return /* binding */ weakMapMemoize; }\n/* harmony export */ });\n// src/devModeChecks/identityFunctionCheck.ts\nvar runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult)=>{\n    if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {\n        let isInputSameAsOutput = false;\n        try {\n            const emptyObject = {};\n            if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true;\n        } catch (e) {}\n        if (isInputSameAsOutput) {\n            let stack = void 0;\n            try {\n                throw new Error();\n            } catch (e) {\n                ;\n                ({ stack } = e);\n            }\n            console.warn(\"The result function returned its own inputs without modification. e.g\\n`createSelector([state => state.todos], todos => todos)`\\nThis could lead to inefficient memoization and unnecessary re-renders.\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.\", {\n                stack\n            });\n        }\n    }\n};\n// src/devModeChecks/inputStabilityCheck.ts\nvar runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs)=>{\n    const { memoize, memoizeOptions } = options;\n    const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;\n    const createAnEmptyObject = memoize(()=>({}), ...memoizeOptions);\n    const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);\n    if (!areInputSelectorResultsEqual) {\n        let stack = void 0;\n        try {\n            throw new Error();\n        } catch (e) {\n            ;\n            ({ stack } = e);\n        }\n        console.warn(\"An input selector returned a different result when passed same arguments.\\nThis means your output selector will likely run more frequently than intended.\\nAvoid returning a new reference inside your input selector, e.g.\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`\", {\n            arguments: inputSelectorArgs,\n            firstInputs: inputSelectorResults,\n            secondInputs: inputSelectorResultsCopy,\n            stack\n        });\n    }\n};\n// src/devModeChecks/setGlobalDevModeChecks.ts\nvar globalDevModeChecks = {\n    inputStabilityCheck: \"once\",\n    identityFunctionCheck: \"once\"\n};\nvar setGlobalDevModeChecks = (devModeChecks)=>{\n    Object.assign(globalDevModeChecks, devModeChecks);\n};\n// src/utils.ts\nvar NOT_FOUND = \"NOT_FOUND\";\nfunction assertIsFunction(func) {\n    let errorMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"expected a function, instead received \".concat(typeof func);\n    if (typeof func !== \"function\") {\n        throw new TypeError(errorMessage);\n    }\n}\nfunction assertIsObject(object) {\n    let errorMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"expected an object, instead received \".concat(typeof object);\n    if (typeof object !== \"object\") {\n        throw new TypeError(errorMessage);\n    }\n}\nfunction assertIsArrayOfFunctions(array) {\n    let errorMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"expected all items to be functions, instead received the following types: \";\n    if (!array.every((item)=>typeof item === \"function\")) {\n        const itemTypes = array.map((item)=>typeof item === \"function\" ? \"function \".concat(item.name || \"unnamed\", \"()\") : typeof item).join(\", \");\n        throw new TypeError(\"\".concat(errorMessage, \"[\").concat(itemTypes, \"]\"));\n    }\n}\nvar ensureIsArray = (item)=>{\n    return Array.isArray(item) ? item : [\n        item\n    ];\n};\nfunction getDependencies(createSelectorArgs) {\n    const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;\n    assertIsArrayOfFunctions(dependencies, \"createSelector expects all input-selectors to be functions, but received the following types: \");\n    return dependencies;\n}\nfunction collectInputSelectorResults(dependencies, inputSelectorArgs) {\n    const inputSelectorResults = [];\n    const { length } = dependencies;\n    for(let i = 0; i < length; i++){\n        inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));\n    }\n    return inputSelectorResults;\n}\nvar getDevModeChecksExecutionInfo = (firstRun, devModeChecks)=>{\n    const { identityFunctionCheck, inputStabilityCheck } = {\n        ...globalDevModeChecks,\n        ...devModeChecks\n    };\n    return {\n        identityFunctionCheck: {\n            shouldRun: identityFunctionCheck === \"always\" || identityFunctionCheck === \"once\" && firstRun,\n            run: runIdentityFunctionCheck\n        },\n        inputStabilityCheck: {\n            shouldRun: inputStabilityCheck === \"always\" || inputStabilityCheck === \"once\" && firstRun,\n            run: runInputStabilityCheck\n        }\n    };\n};\n// src/autotrackMemoize/autotracking.ts\nvar $REVISION = 0;\nvar CURRENT_TRACKER = null;\nvar Cell = class {\n    // Whenever a storage value is read, it'll add itself to the current tracker if\n    // one exists, entangling its state with that cache.\n    get value() {\n        CURRENT_TRACKER === null || CURRENT_TRACKER === void 0 ? void 0 : CURRENT_TRACKER.add(this);\n        return this._value;\n    }\n    // Whenever a storage value is updated, we bump the global revision clock,\n    // assign the revision for this storage to the new value, _and_ we schedule a\n    // rerender. This is important, and it's what makes autotracking  _pull_\n    // based. We don't actively tell the caches which depend on the storage that\n    // anything has happened. Instead, we recompute the caches when needed.\n    set value(newValue) {\n        if (this.value === newValue) return;\n        this._value = newValue;\n        this.revision = ++$REVISION;\n    }\n    constructor(initialValue, isEqual = tripleEq){\n        this.revision = $REVISION;\n        this._isEqual = tripleEq;\n        this._value = this._lastValue = initialValue;\n        this._isEqual = isEqual;\n    }\n};\nfunction tripleEq(a, b) {\n    return a === b;\n}\nvar TrackingCache = class {\n    clear() {\n        this._cachedValue = void 0;\n        this._cachedRevision = -1;\n        this._deps = [];\n        this.hits = 0;\n    }\n    get value() {\n        if (this.revision > this._cachedRevision) {\n            const { fn } = this;\n            const currentTracker = /* @__PURE__ */ new Set();\n            const prevTracker = CURRENT_TRACKER;\n            CURRENT_TRACKER = currentTracker;\n            this._cachedValue = fn();\n            CURRENT_TRACKER = prevTracker;\n            this.hits++;\n            this._deps = Array.from(currentTracker);\n            this._cachedRevision = this.revision;\n        }\n        CURRENT_TRACKER === null || CURRENT_TRACKER === void 0 ? void 0 : CURRENT_TRACKER.add(this);\n        return this._cachedValue;\n    }\n    get revision() {\n        return Math.max(...this._deps.map((d)=>d.revision), 0);\n    }\n    constructor(fn){\n        this._cachedRevision = -1;\n        this._deps = [];\n        this.hits = 0;\n        this.fn = fn;\n    }\n};\nfunction getValue(cell) {\n    if (!(cell instanceof Cell)) {\n        console.warn(\"Not a valid cell! \", cell);\n    }\n    return cell.value;\n}\nfunction setValue(storage, value) {\n    if (!(storage instanceof Cell)) {\n        throw new TypeError(\"setValue must be passed a tracked store created with `createStorage`.\");\n    }\n    storage.value = storage._lastValue = value;\n}\nfunction createCell(initialValue) {\n    let isEqual = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : tripleEq;\n    return new Cell(initialValue, isEqual);\n}\nfunction createCache(fn) {\n    assertIsFunction(fn, \"the first parameter to `createCache` must be a function\");\n    return new TrackingCache(fn);\n}\n// src/autotrackMemoize/tracking.ts\nvar neverEq = (a, b)=>false;\nfunction createTag() {\n    return createCell(null, neverEq);\n}\nfunction dirtyTag(tag, value) {\n    setValue(tag, value);\n}\nvar consumeCollection = (node)=>{\n    let tag = node.collectionTag;\n    if (tag === null) {\n        tag = node.collectionTag = createTag();\n    }\n    getValue(tag);\n};\nvar dirtyCollection = (node)=>{\n    const tag = node.collectionTag;\n    if (tag !== null) {\n        dirtyTag(tag, null);\n    }\n};\n// src/autotrackMemoize/proxy.ts\nvar REDUX_PROXY_LABEL = Symbol();\nvar nextId = 0;\nvar proto = Object.getPrototypeOf({});\nvar ObjectTreeNode = class {\n    constructor(value){\n        this.proxy = new Proxy(this, objectProxyHandler);\n        this.tag = createTag();\n        this.tags = {};\n        this.children = {};\n        this.collectionTag = null;\n        this.id = nextId++;\n        this.value = value;\n        this.value = value;\n        this.tag.value = value;\n    }\n};\nvar objectProxyHandler = {\n    get (node, key) {\n        function calculateResult() {\n            const { value } = node;\n            const childValue = Reflect.get(value, key);\n            if (typeof key === \"symbol\") {\n                return childValue;\n            }\n            if (key in proto) {\n                return childValue;\n            }\n            if (typeof childValue === \"object\" && childValue !== null) {\n                let childNode = node.children[key];\n                if (childNode === void 0) {\n                    childNode = node.children[key] = createNode(childValue);\n                }\n                if (childNode.tag) {\n                    getValue(childNode.tag);\n                }\n                return childNode.proxy;\n            } else {\n                let tag = node.tags[key];\n                if (tag === void 0) {\n                    tag = node.tags[key] = createTag();\n                    tag.value = childValue;\n                }\n                getValue(tag);\n                return childValue;\n            }\n        }\n        const res = calculateResult();\n        return res;\n    },\n    ownKeys (node) {\n        consumeCollection(node);\n        return Reflect.ownKeys(node.value);\n    },\n    getOwnPropertyDescriptor (node, prop) {\n        return Reflect.getOwnPropertyDescriptor(node.value, prop);\n    },\n    has (node, prop) {\n        return Reflect.has(node.value, prop);\n    }\n};\nvar ArrayTreeNode = class {\n    constructor(value){\n        this.proxy = new Proxy([\n            this\n        ], arrayProxyHandler);\n        this.tag = createTag();\n        this.tags = {};\n        this.children = {};\n        this.collectionTag = null;\n        this.id = nextId++;\n        this.value = value;\n        this.value = value;\n        this.tag.value = value;\n    }\n};\nvar arrayProxyHandler = {\n    get (param, key) {\n        let [node] = param;\n        if (key === \"length\") {\n            consumeCollection(node);\n        }\n        return objectProxyHandler.get(node, key);\n    },\n    ownKeys (param) {\n        let [node] = param;\n        return objectProxyHandler.ownKeys(node);\n    },\n    getOwnPropertyDescriptor (param, prop) {\n        let [node] = param;\n        return objectProxyHandler.getOwnPropertyDescriptor(node, prop);\n    },\n    has (param, prop) {\n        let [node] = param;\n        return objectProxyHandler.has(node, prop);\n    }\n};\nfunction createNode(value) {\n    if (Array.isArray(value)) {\n        return new ArrayTreeNode(value);\n    }\n    return new ObjectTreeNode(value);\n}\nfunction updateNode(node, newValue) {\n    const { value, tags, children } = node;\n    node.value = newValue;\n    if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {\n        dirtyCollection(node);\n    } else {\n        if (value !== newValue) {\n            let oldKeysSize = 0;\n            let newKeysSize = 0;\n            let anyKeysAdded = false;\n            for(const _key in value){\n                oldKeysSize++;\n            }\n            for(const key in newValue){\n                newKeysSize++;\n                if (!(key in value)) {\n                    anyKeysAdded = true;\n                    break;\n                }\n            }\n            const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;\n            if (isDifferent) {\n                dirtyCollection(node);\n            }\n        }\n    }\n    for(const key in tags){\n        const childValue = value[key];\n        const newChildValue = newValue[key];\n        if (childValue !== newChildValue) {\n            dirtyCollection(node);\n            dirtyTag(tags[key], newChildValue);\n        }\n        if (typeof newChildValue === \"object\" && newChildValue !== null) {\n            delete tags[key];\n        }\n    }\n    for(const key in children){\n        const childNode = children[key];\n        const newChildValue = newValue[key];\n        const childValue = childNode.value;\n        if (childValue === newChildValue) {\n            continue;\n        } else if (typeof newChildValue === \"object\" && newChildValue !== null) {\n            updateNode(childNode, newChildValue);\n        } else {\n            deleteNode(childNode);\n            delete children[key];\n        }\n    }\n}\nfunction deleteNode(node) {\n    if (node.tag) {\n        dirtyTag(node.tag, null);\n    }\n    dirtyCollection(node);\n    for(const key in node.tags){\n        dirtyTag(node.tags[key], null);\n    }\n    for(const key in node.children){\n        deleteNode(node.children[key]);\n    }\n}\n// src/lruMemoize.ts\nfunction createSingletonCache(equals) {\n    let entry;\n    return {\n        get (key) {\n            if (entry && equals(entry.key, key)) {\n                return entry.value;\n            }\n            return NOT_FOUND;\n        },\n        put (key, value) {\n            entry = {\n                key,\n                value\n            };\n        },\n        getEntries () {\n            return entry ? [\n                entry\n            ] : [];\n        },\n        clear () {\n            entry = void 0;\n        }\n    };\n}\nfunction createLruCache(maxSize, equals) {\n    let entries = [];\n    function get(key) {\n        const cacheIndex = entries.findIndex((entry)=>equals(key, entry.key));\n        if (cacheIndex > -1) {\n            const entry = entries[cacheIndex];\n            if (cacheIndex > 0) {\n                entries.splice(cacheIndex, 1);\n                entries.unshift(entry);\n            }\n            return entry.value;\n        }\n        return NOT_FOUND;\n    }\n    function put(key, value) {\n        if (get(key) === NOT_FOUND) {\n            entries.unshift({\n                key,\n                value\n            });\n            if (entries.length > maxSize) {\n                entries.pop();\n            }\n        }\n    }\n    function getEntries() {\n        return entries;\n    }\n    function clear() {\n        entries = [];\n    }\n    return {\n        get,\n        put,\n        getEntries,\n        clear\n    };\n}\nvar referenceEqualityCheck = (a, b)=>a === b;\nfunction createCacheKeyComparator(equalityCheck) {\n    return function areArgumentsShallowlyEqual(prev, next) {\n        if (prev === null || next === null || prev.length !== next.length) {\n            return false;\n        }\n        const { length } = prev;\n        for(let i = 0; i < length; i++){\n            if (!equalityCheck(prev[i], next[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nfunction lruMemoize(func, equalityCheckOrOptions) {\n    const providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : {\n        equalityCheck: equalityCheckOrOptions\n    };\n    const { equalityCheck = referenceEqualityCheck, maxSize = 1, resultEqualityCheck } = providedOptions;\n    const comparator = createCacheKeyComparator(equalityCheck);\n    let resultsCount = 0;\n    const cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);\n    function memoized() {\n        let value = cache.get(arguments);\n        if (value === NOT_FOUND) {\n            value = func.apply(null, arguments);\n            resultsCount++;\n            if (resultEqualityCheck) {\n                const entries = cache.getEntries();\n                const matchingEntry = entries.find((entry)=>resultEqualityCheck(entry.value, value));\n                if (matchingEntry) {\n                    value = matchingEntry.value;\n                    resultsCount !== 0 && resultsCount--;\n                }\n            }\n            cache.put(arguments, value);\n        }\n        return value;\n    }\n    memoized.clearCache = ()=>{\n        cache.clear();\n        memoized.resetResultsCount();\n    };\n    memoized.resultsCount = ()=>resultsCount;\n    memoized.resetResultsCount = ()=>{\n        resultsCount = 0;\n    };\n    return memoized;\n}\n// src/autotrackMemoize/autotrackMemoize.ts\nfunction autotrackMemoize(func) {\n    const node = createNode([]);\n    let lastArgs = null;\n    const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);\n    const cache = createCache(()=>{\n        const res = func.apply(null, node.proxy);\n        return res;\n    });\n    function memoized() {\n        if (!shallowEqual(lastArgs, arguments)) {\n            updateNode(node, arguments);\n            lastArgs = arguments;\n        }\n        return cache.value;\n    }\n    memoized.clearCache = ()=>{\n        return cache.clear();\n    };\n    return memoized;\n}\n// src/weakMapMemoize.ts\nvar StrongRef = class {\n    deref() {\n        return this.value;\n    }\n    constructor(value){\n        this.value = value;\n    }\n};\nvar Ref = typeof WeakRef !== \"undefined\" ? WeakRef : StrongRef;\nvar UNTERMINATED = 0;\nvar TERMINATED = 1;\nfunction createCacheNode() {\n    return {\n        s: UNTERMINATED,\n        v: void 0,\n        o: null,\n        p: null\n    };\n}\nfunction weakMapMemoize(func) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    let fnNode = createCacheNode();\n    const { resultEqualityCheck } = options;\n    let lastResult;\n    let resultsCount = 0;\n    function memoized() {\n        let cacheNode = fnNode;\n        const { length } = arguments;\n        for(let i = 0, l = length; i < l; i++){\n            const arg = arguments[i];\n            if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\n                let objectCache = cacheNode.o;\n                if (objectCache === null) {\n                    cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();\n                }\n                const objectNode = objectCache.get(arg);\n                if (objectNode === void 0) {\n                    cacheNode = createCacheNode();\n                    objectCache.set(arg, cacheNode);\n                } else {\n                    cacheNode = objectNode;\n                }\n            } else {\n                let primitiveCache = cacheNode.p;\n                if (primitiveCache === null) {\n                    cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();\n                }\n                const primitiveNode = primitiveCache.get(arg);\n                if (primitiveNode === void 0) {\n                    cacheNode = createCacheNode();\n                    primitiveCache.set(arg, cacheNode);\n                } else {\n                    cacheNode = primitiveNode;\n                }\n            }\n        }\n        const terminatedNode = cacheNode;\n        let result;\n        if (cacheNode.s === TERMINATED) {\n            result = cacheNode.v;\n        } else {\n            result = func.apply(null, arguments);\n            resultsCount++;\n        }\n        terminatedNode.s = TERMINATED;\n        if (resultEqualityCheck) {\n            var _lastResult_deref;\n            var _lastResult_deref1;\n            const lastResultValue = (_lastResult_deref1 = lastResult === null || lastResult === void 0 ? void 0 : (_lastResult_deref = lastResult.deref) === null || _lastResult_deref === void 0 ? void 0 : _lastResult_deref.call(lastResult)) !== null && _lastResult_deref1 !== void 0 ? _lastResult_deref1 : lastResult;\n            if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {\n                result = lastResultValue;\n                resultsCount !== 0 && resultsCount--;\n            }\n            const needsWeakRef = typeof result === \"object\" && result !== null || typeof result === \"function\";\n            lastResult = needsWeakRef ? new Ref(result) : result;\n        }\n        terminatedNode.v = result;\n        return result;\n    }\n    memoized.clearCache = ()=>{\n        fnNode = createCacheNode();\n        memoized.resetResultsCount();\n    };\n    memoized.resultsCount = ()=>resultsCount;\n    memoized.resetResultsCount = ()=>{\n        resultsCount = 0;\n    };\n    return memoized;\n}\n// src/createSelectorCreator.ts\nfunction createSelectorCreator(memoizeOrOptions) {\n    for(var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        memoizeOptionsFromArgs[_key - 1] = arguments[_key];\n    }\n    const createSelectorCreatorOptions = typeof memoizeOrOptions === \"function\" ? {\n        memoize: memoizeOrOptions,\n        memoizeOptions: memoizeOptionsFromArgs\n    } : memoizeOrOptions;\n    const createSelector2 = function() {\n        for(var _len = arguments.length, createSelectorArgs = new Array(_len), _key = 0; _key < _len; _key++){\n            createSelectorArgs[_key] = arguments[_key];\n        }\n        let recomputations = 0;\n        let dependencyRecomputations = 0;\n        let lastResult;\n        let directlyPassedOptions = {};\n        let resultFunc = createSelectorArgs.pop();\n        if (typeof resultFunc === \"object\") {\n            directlyPassedOptions = resultFunc;\n            resultFunc = createSelectorArgs.pop();\n        }\n        assertIsFunction(resultFunc, \"createSelector expects an output function after the inputs, but received: [\".concat(typeof resultFunc, \"]\"));\n        const combinedOptions = {\n            ...createSelectorCreatorOptions,\n            ...directlyPassedOptions\n        };\n        const { memoize, memoizeOptions = [], argsMemoize = weakMapMemoize, argsMemoizeOptions = [], devModeChecks = {} } = combinedOptions;\n        const finalMemoizeOptions = ensureIsArray(memoizeOptions);\n        const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);\n        const dependencies = getDependencies(createSelectorArgs);\n        const memoizedResultFunc = memoize(function recomputationWrapper() {\n            recomputations++;\n            return resultFunc.apply(null, arguments);\n        }, ...finalMemoizeOptions);\n        let firstRun = true;\n        const selector = argsMemoize(function dependenciesChecker() {\n            dependencyRecomputations++;\n            const inputSelectorResults = collectInputSelectorResults(dependencies, arguments);\n            lastResult = memoizedResultFunc.apply(null, inputSelectorResults);\n            if (true) {\n                const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);\n                if (identityFunctionCheck.shouldRun) {\n                    identityFunctionCheck.run(resultFunc, inputSelectorResults, lastResult);\n                }\n                if (inputStabilityCheck.shouldRun) {\n                    const inputSelectorResultsCopy = collectInputSelectorResults(dependencies, arguments);\n                    inputStabilityCheck.run({\n                        inputSelectorResults,\n                        inputSelectorResultsCopy\n                    }, {\n                        memoize,\n                        memoizeOptions: finalMemoizeOptions\n                    }, arguments);\n                }\n                if (firstRun) firstRun = false;\n            }\n            return lastResult;\n        }, ...finalArgsMemoizeOptions);\n        return Object.assign(selector, {\n            resultFunc,\n            memoizedResultFunc,\n            dependencies,\n            dependencyRecomputations: ()=>dependencyRecomputations,\n            resetDependencyRecomputations: ()=>{\n                dependencyRecomputations = 0;\n            },\n            lastResult: ()=>lastResult,\n            recomputations: ()=>recomputations,\n            resetRecomputations: ()=>{\n                recomputations = 0;\n            },\n            memoize,\n            argsMemoize\n        });\n    };\n    Object.assign(createSelector2, {\n        withTypes: ()=>createSelector2\n    });\n    return createSelector2;\n}\nvar createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);\n// src/createStructuredSelector.ts\nvar createStructuredSelector = Object.assign(function(inputSelectorsObject) {\n    let selectorCreator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createSelector;\n    assertIsObject(inputSelectorsObject, \"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a \".concat(typeof inputSelectorsObject));\n    const inputSelectorKeys = Object.keys(inputSelectorsObject);\n    const dependencies = inputSelectorKeys.map((key)=>inputSelectorsObject[key]);\n    const structuredSelector = selectorCreator(dependencies, function() {\n        for(var _len = arguments.length, inputSelectorResults = new Array(_len), _key = 0; _key < _len; _key++){\n            inputSelectorResults[_key] = arguments[_key];\n        }\n        return inputSelectorResults.reduce((composition, value, index)=>{\n            composition[inputSelectorKeys[index]] = value;\n            return composition;\n        }, {});\n    });\n    return structuredSelector;\n}, {\n    withTypes: ()=>createStructuredSelector\n});\n //# sourceMappingURL=reselect.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXNlbGVjdC9kaXN0L3Jlc2VsZWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLDZDQUE2QztBQUM3QyxJQUFJQSwyQkFBMkIsQ0FBQ0MsWUFBWUMsdUJBQXVCQztJQUNqRSxJQUFJRCxzQkFBc0JFLE1BQU0sS0FBSyxLQUFLRixxQkFBcUIsQ0FBQyxFQUFFLEtBQUtDLHNCQUFzQjtRQUMzRixJQUFJRSxzQkFBc0I7UUFDMUIsSUFBSTtZQUNGLE1BQU1DLGNBQWMsQ0FBQztZQUNyQixJQUFJTCxXQUFXSyxpQkFBaUJBLGFBQzlCRCxzQkFBc0I7UUFDMUIsRUFBRSxVQUFNLENBQ1I7UUFDQSxJQUFJQSxxQkFBcUI7WUFDdkIsSUFBSUUsUUFBUSxLQUFLO1lBQ2pCLElBQUk7Z0JBQ0YsTUFBTSxJQUFJQztZQUNaLEVBQUUsT0FBT0MsR0FBRzs7Z0JBRVQsR0FBRUYsS0FBSyxFQUFFLEdBQUdFLENBQUFBO1lBQ2Y7WUFDQUMsUUFBUUMsSUFBSSxDQUNWLG1UQUNBO2dCQUFFSjtZQUFNO1FBRVo7SUFDRjtBQUNGO0FBRUEsMkNBQTJDO0FBQzNDLElBQUlLLHlCQUF5QixDQUFDQyw0QkFBNEJDLFNBQVNDO0lBQ2pFLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxjQUFjLEVBQUUsR0FBR0g7SUFDcEMsTUFBTSxFQUFFSSxvQkFBb0IsRUFBRUMsd0JBQXdCLEVBQUUsR0FBR047SUFDM0QsTUFBTU8sc0JBQXNCSixRQUFRLElBQU8sRUFBQyxPQUFPQztJQUNuRCxNQUFNSSwrQkFBK0JELG9CQUFvQkUsS0FBSyxDQUFDLE1BQU1KLDBCQUEwQkUsb0JBQW9CRSxLQUFLLENBQUMsTUFBTUg7SUFDL0gsSUFBSSxDQUFDRSw4QkFBOEI7UUFDakMsSUFBSWQsUUFBUSxLQUFLO1FBQ2pCLElBQUk7WUFDRixNQUFNLElBQUlDO1FBQ1osRUFBRSxPQUFPQyxHQUFHOztZQUVULEdBQUVGLEtBQUssRUFBRSxHQUFH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SUFFcEMsTUFBTThHLHFCQUFxQkgsZ0JBQ3pCNUssY0FDQTt5Q0FBSW5DO1lBQUFBOztRQUNGLE9BQU9BLHFCQUFxQm1OLE1BQU0sQ0FBQyxDQUFDQyxhQUFhdEssT0FBT3VLO1lBQ3RERCxXQUFXLENBQUNKLGlCQUFpQixDQUFDSyxNQUFNLENBQUMsR0FBR3ZLO1lBQ3hDLE9BQU9zSztRQUNULEdBQUcsQ0FBQztJQUNOO0lBRUYsT0FBT0Y7QUFDVCxHQUNBO0lBQUVQLFdBQVcsSUFBTUU7QUFBeUI7QUFXNUMsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L2Rpc3QvcmVzZWxlY3QubWpzPzQwOGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Rldk1vZGVDaGVja3MvaWRlbnRpdHlGdW5jdGlvbkNoZWNrLnRzXG52YXIgcnVuSWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gKHJlc3VsdEZ1bmMsIGlucHV0U2VsZWN0b3JzUmVzdWx0cywgb3V0cHV0U2VsZWN0b3JSZXN1bHQpID0+IHtcbiAgaWYgKGlucHV0U2VsZWN0b3JzUmVzdWx0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRTZWxlY3RvcnNSZXN1bHRzWzBdID09PSBvdXRwdXRTZWxlY3RvclJlc3VsdCkge1xuICAgIGxldCBpc0lucHV0U2FtZUFzT3V0cHV0ID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVtcHR5T2JqZWN0ID0ge307XG4gICAgICBpZiAocmVzdWx0RnVuYyhlbXB0eU9iamVjdCkgPT09IGVtcHR5T2JqZWN0KVxuICAgICAgICBpc0lucHV0U2FtZUFzT3V0cHV0ID0gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgaWYgKGlzSW5wdXRTYW1lQXNPdXRwdXQpIHtcbiAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICA7XG4gICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJUaGUgcmVzdWx0IGZ1bmN0aW9uIHJldHVybmVkIGl0cyBvd24gaW5wdXRzIHdpdGhvdXQgbW9kaWZpY2F0aW9uLiBlLmdcXG5gY3JlYXRlU2VsZWN0b3IoW3N0YXRlID0+IHN0YXRlLnRvZG9zXSwgdG9kb3MgPT4gdG9kb3MpYFxcblRoaXMgY291bGQgbGVhZCB0byBpbmVmZmljaWVudCBtZW1vaXphdGlvbiBhbmQgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy5cXG5FbnN1cmUgdHJhbnNmb3JtYXRpb24gbG9naWMgaXMgaW4gdGhlIHJlc3VsdCBmdW5jdGlvbiwgYW5kIGV4dHJhY3Rpb24gbG9naWMgaXMgaW4gdGhlIGlucHV0IHNlbGVjdG9ycy5cIixcbiAgICAgICAgeyBzdGFjayB9XG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2Rldk1vZGVDaGVja3MvaW5wdXRTdGFiaWxpdHlDaGVjay50c1xudmFyIHJ1bklucHV0U3RhYmlsaXR5Q2hlY2sgPSAoaW5wdXRTZWxlY3RvclJlc3VsdHNPYmplY3QsIG9wdGlvbnMsIGlucHV0U2VsZWN0b3JBcmdzKSA9PiB7XG4gIGNvbnN0IHsgbWVtb2l6ZSwgbWVtb2l6ZU9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHsgaW5wdXRTZWxlY3RvclJlc3VsdHMsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSB9ID0gaW5wdXRTZWxlY3RvclJlc3VsdHNPYmplY3Q7XG4gIGNvbnN0IGNyZWF0ZUFuRW1wdHlPYmplY3QgPSBtZW1vaXplKCgpID0+ICh7fSksIC4uLm1lbW9pemVPcHRpb25zKTtcbiAgY29uc3QgYXJlSW5wdXRTZWxlY3RvclJlc3VsdHNFcXVhbCA9IGNyZWF0ZUFuRW1wdHlPYmplY3QuYXBwbHkobnVsbCwgaW5wdXRTZWxlY3RvclJlc3VsdHMpID09PSBjcmVhdGVBbkVtcHR5T2JqZWN0LmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSk7XG4gIGlmICghYXJlSW5wdXRTZWxlY3RvclJlc3VsdHNFcXVhbCkge1xuICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgO1xuICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIkFuIGlucHV0IHNlbGVjdG9yIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIHBhc3NlZCBzYW1lIGFyZ3VtZW50cy5cXG5UaGlzIG1lYW5zIHlvdXIgb3V0cHV0IHNlbGVjdG9yIHdpbGwgbGlrZWx5IHJ1biBtb3JlIGZyZXF1ZW50bHkgdGhhbiBpbnRlbmRlZC5cXG5Bdm9pZCByZXR1cm5pbmcgYSBuZXcgcmVmZXJlbmNlIGluc2lkZSB5b3VyIGlucHV0IHNlbGVjdG9yLCBlLmcuXFxuYGNyZWF0ZVNlbGVjdG9yKFtzdGF0ZSA9PiBzdGF0ZS50b2Rvcy5tYXAodG9kbyA9PiB0b2RvLmlkKV0sIHRvZG9JZHMgPT4gdG9kb0lkcy5sZW5ndGgpYFwiLFxuICAgICAge1xuICAgICAgICBhcmd1bWVudHM6IGlucHV0U2VsZWN0b3JBcmdzLFxuICAgICAgICBmaXJzdElucHV0czogaW5wdXRTZWxlY3RvclJlc3VsdHMsXG4gICAgICAgIHNlY29uZElucHV0czogaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5LFxuICAgICAgICBzdGFja1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9kZXZNb2RlQ2hlY2tzL3NldEdsb2JhbERldk1vZGVDaGVja3MudHNcbnZhciBnbG9iYWxEZXZNb2RlQ2hlY2tzID0ge1xuICBpbnB1dFN0YWJpbGl0eUNoZWNrOiBcIm9uY2VcIixcbiAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBcIm9uY2VcIlxufTtcbnZhciBzZXRHbG9iYWxEZXZNb2RlQ2hlY2tzID0gKGRldk1vZGVDaGVja3MpID0+IHtcbiAgT2JqZWN0LmFzc2lnbihnbG9iYWxEZXZNb2RlQ2hlY2tzLCBkZXZNb2RlQ2hlY2tzKTtcbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIE5PVF9GT1VORCA9IFwiTk9UX0ZPVU5EXCI7XG5mdW5jdGlvbiBhc3NlcnRJc0Z1bmN0aW9uKGZ1bmMsIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICR7dHlwZW9mIGZ1bmN9YCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0SXNPYmplY3Qob2JqZWN0LCBlcnJvck1lc3NhZ2UgPSBgZXhwZWN0ZWQgYW4gb2JqZWN0LCBpbnN0ZWFkIHJlY2VpdmVkICR7dHlwZW9mIG9iamVjdH1gKSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRJc0FycmF5T2ZGdW5jdGlvbnMoYXJyYXksIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhbGwgaXRlbXMgdG8gYmUgZnVuY3Rpb25zLCBpbnN0ZWFkIHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IGApIHtcbiAgaWYgKCFhcnJheS5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICBjb25zdCBpdGVtVHlwZXMgPSBhcnJheS5tYXAoXG4gICAgICAoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIiA/IGBmdW5jdGlvbiAke2l0ZW0ubmFtZSB8fCBcInVubmFtZWRcIn0oKWAgOiB0eXBlb2YgaXRlbVxuICAgICkuam9pbihcIiwgXCIpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZXJyb3JNZXNzYWdlfVske2l0ZW1UeXBlc31dYCk7XG4gIH1cbn1cbnZhciBlbnN1cmVJc0FycmF5ID0gKGl0ZW0pID0+IHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dO1xufTtcbmZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyhjcmVhdGVTZWxlY3RvckFyZ3MpIHtcbiAgY29uc3QgZGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShjcmVhdGVTZWxlY3RvckFyZ3NbMF0pID8gY3JlYXRlU2VsZWN0b3JBcmdzWzBdIDogY3JlYXRlU2VsZWN0b3JBcmdzO1xuICBhc3NlcnRJc0FycmF5T2ZGdW5jdGlvbnMoXG4gICAgZGVwZW5kZW5jaWVzLFxuICAgIGBjcmVhdGVTZWxlY3RvciBleHBlY3RzIGFsbCBpbnB1dC1zZWxlY3RvcnMgdG8gYmUgZnVuY3Rpb25zLCBidXQgcmVjZWl2ZWQgdGhlIGZvbGxvd2luZyB0eXBlczogYFxuICApO1xuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuZnVuY3Rpb24gY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzKGRlcGVuZGVuY2llcywgaW5wdXRTZWxlY3RvckFyZ3MpIHtcbiAgY29uc3QgaW5wdXRTZWxlY3RvclJlc3VsdHMgPSBbXTtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGRlcGVuZGVuY2llcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlucHV0U2VsZWN0b3JSZXN1bHRzLnB1c2goZGVwZW5kZW5jaWVzW2ldLmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JBcmdzKSk7XG4gIH1cbiAgcmV0dXJuIGlucHV0U2VsZWN0b3JSZXN1bHRzO1xufVxudmFyIGdldERldk1vZGVDaGVja3NFeGVjdXRpb25JbmZvID0gKGZpcnN0UnVuLCBkZXZNb2RlQ2hlY2tzKSA9PiB7XG4gIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLCBpbnB1dFN0YWJpbGl0eUNoZWNrIH0gPSB7XG4gICAgLi4uZ2xvYmFsRGV2TW9kZUNoZWNrcyxcbiAgICAuLi5kZXZNb2RlQ2hlY2tzXG4gIH07XG4gIHJldHVybiB7XG4gICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiB7XG4gICAgICBzaG91bGRSdW46IGlkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJhbHdheXNcIiB8fCBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLFxuICAgICAgcnVuOiBydW5JZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICB9LFxuICAgIGlucHV0U3RhYmlsaXR5Q2hlY2s6IHtcbiAgICAgIHNob3VsZFJ1bjogaW5wdXRTdGFiaWxpdHlDaGVjayA9PT0gXCJhbHdheXNcIiB8fCBpbnB1dFN0YWJpbGl0eUNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bixcbiAgICAgIHJ1bjogcnVuSW5wdXRTdGFiaWxpdHlDaGVja1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9hdXRvdHJhY2tNZW1vaXplL2F1dG90cmFja2luZy50c1xudmFyICRSRVZJU0lPTiA9IDA7XG52YXIgQ1VSUkVOVF9UUkFDS0VSID0gbnVsbDtcbnZhciBDZWxsID0gY2xhc3Mge1xuICByZXZpc2lvbiA9ICRSRVZJU0lPTjtcbiAgX3ZhbHVlO1xuICBfbGFzdFZhbHVlO1xuICBfaXNFcXVhbCA9IHRyaXBsZUVxO1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWUsIGlzRXF1YWwgPSB0cmlwbGVFcSkge1xuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fbGFzdFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIHRoaXMuX2lzRXF1YWwgPSBpc0VxdWFsO1xuICB9XG4gIC8vIFdoZW5ldmVyIGEgc3RvcmFnZSB2YWx1ZSBpcyByZWFkLCBpdCdsbCBhZGQgaXRzZWxmIHRvIHRoZSBjdXJyZW50IHRyYWNrZXIgaWZcbiAgLy8gb25lIGV4aXN0cywgZW50YW5nbGluZyBpdHMgc3RhdGUgd2l0aCB0aGF0IGNhY2hlLlxuICBnZXQgdmFsdWUoKSB7XG4gICAgQ1VSUkVOVF9UUkFDS0VSPy5hZGQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIC8vIFdoZW5ldmVyIGEgc3RvcmFnZSB2YWx1ZSBpcyB1cGRhdGVkLCB3ZSBidW1wIHRoZSBnbG9iYWwgcmV2aXNpb24gY2xvY2ssXG4gIC8vIGFzc2lnbiB0aGUgcmV2aXNpb24gZm9yIHRoaXMgc3RvcmFnZSB0byB0aGUgbmV3IHZhbHVlLCBfYW5kXyB3ZSBzY2hlZHVsZSBhXG4gIC8vIHJlcmVuZGVyLiBUaGlzIGlzIGltcG9ydGFudCwgYW5kIGl0J3Mgd2hhdCBtYWtlcyBhdXRvdHJhY2tpbmcgIF9wdWxsX1xuICAvLyBiYXNlZC4gV2UgZG9uJ3QgYWN0aXZlbHkgdGVsbCB0aGUgY2FjaGVzIHdoaWNoIGRlcGVuZCBvbiB0aGUgc3RvcmFnZSB0aGF0XG4gIC8vIGFueXRoaW5nIGhhcyBoYXBwZW5lZC4gSW5zdGVhZCwgd2UgcmVjb21wdXRlIHRoZSBjYWNoZXMgd2hlbiBuZWVkZWQuXG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSBuZXdWYWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIHRoaXMucmV2aXNpb24gPSArKyRSRVZJU0lPTjtcbiAgfVxufTtcbmZ1bmN0aW9uIHRyaXBsZUVxKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG52YXIgVHJhY2tpbmdDYWNoZSA9IGNsYXNzIHtcbiAgX2NhY2hlZFZhbHVlO1xuICBfY2FjaGVkUmV2aXNpb24gPSAtMTtcbiAgX2RlcHMgPSBbXTtcbiAgaGl0cyA9IDA7XG4gIGZuO1xuICBjb25zdHJ1Y3Rvcihmbikge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9jYWNoZWRWYWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9jYWNoZWRSZXZpc2lvbiA9IC0xO1xuICAgIHRoaXMuX2RlcHMgPSBbXTtcbiAgICB0aGlzLmhpdHMgPSAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5yZXZpc2lvbiA+IHRoaXMuX2NhY2hlZFJldmlzaW9uKSB7XG4gICAgICBjb25zdCB7IGZuIH0gPSB0aGlzO1xuICAgICAgY29uc3QgY3VycmVudFRyYWNrZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgY29uc3QgcHJldlRyYWNrZXIgPSBDVVJSRU5UX1RSQUNLRVI7XG4gICAgICBDVVJSRU5UX1RSQUNLRVIgPSBjdXJyZW50VHJhY2tlcjtcbiAgICAgIHRoaXMuX2NhY2hlZFZhbHVlID0gZm4oKTtcbiAgICAgIENVUlJFTlRfVFJBQ0tFUiA9IHByZXZUcmFja2VyO1xuICAgICAgdGhpcy5oaXRzKys7XG4gICAgICB0aGlzLl9kZXBzID0gQXJyYXkuZnJvbShjdXJyZW50VHJhY2tlcik7XG4gICAgICB0aGlzLl9jYWNoZWRSZXZpc2lvbiA9IHRoaXMucmV2aXNpb247XG4gICAgfVxuICAgIENVUlJFTlRfVFJBQ0tFUj8uYWRkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRWYWx1ZTtcbiAgfVxuICBnZXQgcmV2aXNpb24oKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLnRoaXMuX2RlcHMubWFwKChkKSA9PiBkLnJldmlzaW9uKSwgMCk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRWYWx1ZShjZWxsKSB7XG4gIGlmICghKGNlbGwgaW5zdGFuY2VvZiBDZWxsKSkge1xuICAgIGNvbnNvbGUud2FybihcIk5vdCBhIHZhbGlkIGNlbGwhIFwiLCBjZWxsKTtcbiAgfVxuICByZXR1cm4gY2VsbC52YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlKHN0b3JhZ2UsIHZhbHVlKSB7XG4gIGlmICghKHN0b3JhZ2UgaW5zdGFuY2VvZiBDZWxsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcInNldFZhbHVlIG11c3QgYmUgcGFzc2VkIGEgdHJhY2tlZCBzdG9yZSBjcmVhdGVkIHdpdGggYGNyZWF0ZVN0b3JhZ2VgLlwiXG4gICAgKTtcbiAgfVxuICBzdG9yYWdlLnZhbHVlID0gc3RvcmFnZS5fbGFzdFZhbHVlID0gdmFsdWU7XG59XG5mdW5jdGlvbiBjcmVhdGVDZWxsKGluaXRpYWxWYWx1ZSwgaXNFcXVhbCA9IHRyaXBsZUVxKSB7XG4gIHJldHVybiBuZXcgQ2VsbChpbml0aWFsVmFsdWUsIGlzRXF1YWwpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoZm4pIHtcbiAgYXNzZXJ0SXNGdW5jdGlvbihcbiAgICBmbixcbiAgICBcInRoZSBmaXJzdCBwYXJhbWV0ZXIgdG8gYGNyZWF0ZUNhY2hlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIlxuICApO1xuICByZXR1cm4gbmV3IFRyYWNraW5nQ2FjaGUoZm4pO1xufVxuXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS90cmFja2luZy50c1xudmFyIG5ldmVyRXEgPSAoYSwgYikgPT4gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVUYWcoKSB7XG4gIHJldHVybiBjcmVhdGVDZWxsKG51bGwsIG5ldmVyRXEpO1xufVxuZnVuY3Rpb24gZGlydHlUYWcodGFnLCB2YWx1ZSkge1xuICBzZXRWYWx1ZSh0YWcsIHZhbHVlKTtcbn1cbnZhciBjb25zdW1lQ29sbGVjdGlvbiA9IChub2RlKSA9PiB7XG4gIGxldCB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWc7XG4gIGlmICh0YWcgPT09IG51bGwpIHtcbiAgICB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWcgPSBjcmVhdGVUYWcoKTtcbiAgfVxuICBnZXRWYWx1ZSh0YWcpO1xufTtcbnZhciBkaXJ0eUNvbGxlY3Rpb24gPSAobm9kZSkgPT4ge1xuICBjb25zdCB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWc7XG4gIGlmICh0YWcgIT09IG51bGwpIHtcbiAgICBkaXJ0eVRhZyh0YWcsIG51bGwpO1xuICB9XG59O1xuXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS9wcm94eS50c1xudmFyIFJFRFVYX1BST1hZX0xBQkVMID0gU3ltYm9sKCk7XG52YXIgbmV4dElkID0gMDtcbnZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7XG52YXIgT2JqZWN0VHJlZU5vZGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnRhZy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHByb3h5ID0gbmV3IFByb3h5KHRoaXMsIG9iamVjdFByb3h5SGFuZGxlcik7XG4gIHRhZyA9IGNyZWF0ZVRhZygpO1xuICB0YWdzID0ge307XG4gIGNoaWxkcmVuID0ge307XG4gIGNvbGxlY3Rpb25UYWcgPSBudWxsO1xuICBpZCA9IG5leHRJZCsrO1xufTtcbnZhciBvYmplY3RQcm94eUhhbmRsZXIgPSB7XG4gIGdldChub2RlLCBrZXkpIHtcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVSZXN1bHQoKSB7XG4gICAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgICAgY29uc3QgY2hpbGRWYWx1ZSA9IFJlZmxlY3QuZ2V0KHZhbHVlLCBrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5IGluIHByb3RvKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIGNoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNoaWxkTm9kZSA9IG5vZGUuY2hpbGRyZW5ba2V5XTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltrZXldID0gY3JlYXRlTm9kZShjaGlsZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2RlLnRhZykge1xuICAgICAgICAgIGdldFZhbHVlKGNoaWxkTm9kZS50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGUucHJveHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdGFnID0gbm9kZS50YWdzW2tleV07XG4gICAgICAgIGlmICh0YWcgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRhZyA9IG5vZGUudGFnc1trZXldID0gY3JlYXRlVGFnKCk7XG4gICAgICAgICAgdGFnLnZhbHVlID0gY2hpbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSh0YWcpO1xuICAgICAgICByZXR1cm4gY2hpbGRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gY2FsY3VsYXRlUmVzdWx0KCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcbiAgb3duS2V5cyhub2RlKSB7XG4gICAgY29uc3VtZUNvbGxlY3Rpb24obm9kZSk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhub2RlLnZhbHVlKTtcbiAgfSxcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUsIHByb3ApIHtcbiAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS52YWx1ZSwgcHJvcCk7XG4gIH0sXG4gIGhhcyhub2RlLCBwcm9wKSB7XG4gICAgcmV0dXJuIFJlZmxlY3QuaGFzKG5vZGUudmFsdWUsIHByb3ApO1xuICB9XG59O1xudmFyIEFycmF5VHJlZU5vZGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnRhZy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHByb3h5ID0gbmV3IFByb3h5KFt0aGlzXSwgYXJyYXlQcm94eUhhbmRsZXIpO1xuICB0YWcgPSBjcmVhdGVUYWcoKTtcbiAgdGFncyA9IHt9O1xuICBjaGlsZHJlbiA9IHt9O1xuICBjb2xsZWN0aW9uVGFnID0gbnVsbDtcbiAgaWQgPSBuZXh0SWQrKztcbn07XG52YXIgYXJyYXlQcm94eUhhbmRsZXIgPSB7XG4gIGdldChbbm9kZV0sIGtleSkge1xuICAgIGlmIChrZXkgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGNvbnN1bWVDb2xsZWN0aW9uKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0UHJveHlIYW5kbGVyLmdldChub2RlLCBrZXkpO1xuICB9LFxuICBvd25LZXlzKFtub2RlXSkge1xuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIub3duS2V5cyhub2RlKTtcbiAgfSxcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFtub2RlXSwgcHJvcCkge1xuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUsIHByb3ApO1xuICB9LFxuICBoYXMoW25vZGVdLCBwcm9wKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5oYXMobm9kZSwgcHJvcCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVOb2RlKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlUcmVlTm9kZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBPYmplY3RUcmVlTm9kZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB1cGRhdGVOb2RlKG5vZGUsIG5ld1ZhbHVlKSB7XG4gIGNvbnN0IHsgdmFsdWUsIHRhZ3MsIGNoaWxkcmVuIH0gPSBub2RlO1xuICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggIT09IG5ld1ZhbHVlLmxlbmd0aCkge1xuICAgIGRpcnR5Q29sbGVjdGlvbihub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBsZXQgb2xkS2V5c1NpemUgPSAwO1xuICAgICAgbGV0IG5ld0tleXNTaXplID0gMDtcbiAgICAgIGxldCBhbnlLZXlzQWRkZWQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgX2tleSBpbiB2YWx1ZSkge1xuICAgICAgICBvbGRLZXlzU2l6ZSsrO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgbmV3S2V5c1NpemUrKztcbiAgICAgICAgaWYgKCEoa2V5IGluIHZhbHVlKSkge1xuICAgICAgICAgIGFueUtleXNBZGRlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzRGlmZmVyZW50ID0gYW55S2V5c0FkZGVkIHx8IG9sZEtleXNTaXplICE9PSBuZXdLZXlzU2l6ZTtcbiAgICAgIGlmIChpc0RpZmZlcmVudCkge1xuICAgICAgICBkaXJ0eUNvbGxlY3Rpb24obm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHRhZ3MpIHtcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gdmFsdWVba2V5XTtcbiAgICBjb25zdCBuZXdDaGlsZFZhbHVlID0gbmV3VmFsdWVba2V5XTtcbiAgICBpZiAoY2hpbGRWYWx1ZSAhPT0gbmV3Q2hpbGRWYWx1ZSkge1xuICAgICAgZGlydHlDb2xsZWN0aW9uKG5vZGUpO1xuICAgICAgZGlydHlUYWcodGFnc1trZXldLCBuZXdDaGlsZFZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSB0YWdzW2tleV07XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5ba2V5XTtcbiAgICBjb25zdCBuZXdDaGlsZFZhbHVlID0gbmV3VmFsdWVba2V5XTtcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gY2hpbGROb2RlLnZhbHVlO1xuICAgIGlmIChjaGlsZFZhbHVlID09PSBuZXdDaGlsZFZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdDaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZU5vZGUoY2hpbGROb2RlLCBuZXdDaGlsZFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlTm9kZShjaGlsZE5vZGUpO1xuICAgICAgZGVsZXRlIGNoaWxkcmVuW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZWxldGVOb2RlKG5vZGUpIHtcbiAgaWYgKG5vZGUudGFnKSB7XG4gICAgZGlydHlUYWcobm9kZS50YWcsIG51bGwpO1xuICB9XG4gIGRpcnR5Q29sbGVjdGlvbihub2RlKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9kZS50YWdzKSB7XG4gICAgZGlydHlUYWcobm9kZS50YWdzW2tleV0sIG51bGwpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG5vZGUuY2hpbGRyZW4pIHtcbiAgICBkZWxldGVOb2RlKG5vZGUuY2hpbGRyZW5ba2V5XSk7XG4gIH1cbn1cblxuLy8gc3JjL2xydU1lbW9pemUudHNcbmZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbkNhY2hlKGVxdWFscykge1xuICBsZXQgZW50cnk7XG4gIHJldHVybiB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgaWYgKGVudHJ5ICYmIGVxdWFscyhlbnRyeS5rZXksIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgICB9LFxuICAgIHB1dChrZXksIHZhbHVlKSB7XG4gICAgICBlbnRyeSA9IHsga2V5LCB2YWx1ZSB9O1xuICAgIH0sXG4gICAgZ2V0RW50cmllcygpIHtcbiAgICAgIHJldHVybiBlbnRyeSA/IFtlbnRyeV0gOiBbXTtcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgZW50cnkgPSB2b2lkIDA7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTHJ1Q2FjaGUobWF4U2l6ZSwgZXF1YWxzKSB7XG4gIGxldCBlbnRyaWVzID0gW107XG4gIGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBjb25zdCBjYWNoZUluZGV4ID0gZW50cmllcy5maW5kSW5kZXgoKGVudHJ5KSA9PiBlcXVhbHMoa2V5LCBlbnRyeS5rZXkpKTtcbiAgICBpZiAoY2FjaGVJbmRleCA+IC0xKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbY2FjaGVJbmRleF07XG4gICAgICBpZiAoY2FjaGVJbmRleCA+IDApIHtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoY2FjaGVJbmRleCwgMSk7XG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOT1RfRk9VTkQ7XG4gIH1cbiAgZnVuY3Rpb24gcHV0KGtleSwgdmFsdWUpIHtcbiAgICBpZiAoZ2V0KGtleSkgPT09IE5PVF9GT1VORCkge1xuICAgICAgZW50cmllcy51bnNoaWZ0KHsga2V5LCB2YWx1ZSB9KTtcbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgZW50cmllcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW50cmllcygpIHtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBlbnRyaWVzID0gW107XG4gIH1cbiAgcmV0dXJuIHsgZ2V0LCBwdXQsIGdldEVudHJpZXMsIGNsZWFyIH07XG59XG52YXIgcmVmZXJlbmNlRXF1YWxpdHlDaGVjayA9IChhLCBiKSA9PiBhID09PSBiO1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKHByZXYsIG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gcHJldjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWVxdWFsaXR5Q2hlY2socHJldltpXSwgbmV4dFtpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGxydU1lbW9pemUoZnVuYywgZXF1YWxpdHlDaGVja09yT3B0aW9ucykge1xuICBjb25zdCBwcm92aWRlZE9wdGlvbnMgPSB0eXBlb2YgZXF1YWxpdHlDaGVja09yT3B0aW9ucyA9PT0gXCJvYmplY3RcIiA/IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgOiB7IGVxdWFsaXR5Q2hlY2s6IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgfTtcbiAgY29uc3Qge1xuICAgIGVxdWFsaXR5Q2hlY2sgPSByZWZlcmVuY2VFcXVhbGl0eUNoZWNrLFxuICAgIG1heFNpemUgPSAxLFxuICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2tcbiAgfSA9IHByb3ZpZGVkT3B0aW9ucztcbiAgY29uc3QgY29tcGFyYXRvciA9IGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvcihlcXVhbGl0eUNoZWNrKTtcbiAgbGV0IHJlc3VsdHNDb3VudCA9IDA7XG4gIGNvbnN0IGNhY2hlID0gbWF4U2l6ZSA9PT0gMSA/IGNyZWF0ZVNpbmdsZXRvbkNhY2hlKGNvbXBhcmF0b3IpIDogY3JlYXRlTHJ1Q2FjaGUobWF4U2l6ZSwgY29tcGFyYXRvcik7XG4gIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xuICAgIGxldCB2YWx1ZSA9IGNhY2hlLmdldChhcmd1bWVudHMpO1xuICAgIGlmICh2YWx1ZSA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICB2YWx1ZSA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIHJlc3VsdHNDb3VudCsrO1xuICAgICAgaWYgKHJlc3VsdEVxdWFsaXR5Q2hlY2spIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGNhY2hlLmdldEVudHJpZXMoKTtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdFbnRyeSA9IGVudHJpZXMuZmluZChcbiAgICAgICAgICAoZW50cnkpID0+IHJlc3VsdEVxdWFsaXR5Q2hlY2soZW50cnkudmFsdWUsIHZhbHVlKVxuICAgICAgICApO1xuICAgICAgICBpZiAobWF0Y2hpbmdFbnRyeSkge1xuICAgICAgICAgIHZhbHVlID0gbWF0Y2hpbmdFbnRyeS52YWx1ZTtcbiAgICAgICAgICByZXN1bHRzQ291bnQgIT09IDAgJiYgcmVzdWx0c0NvdW50LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhY2hlLnB1dChhcmd1bWVudHMsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIG1lbW9pemVkLmNsZWFyQ2FjaGUgPSAoKSA9PiB7XG4gICAgY2FjaGUuY2xlYXIoKTtcbiAgICBtZW1vaXplZC5yZXNldFJlc3VsdHNDb3VudCgpO1xuICB9O1xuICBtZW1vaXplZC5yZXN1bHRzQ291bnQgPSAoKSA9PiByZXN1bHRzQ291bnQ7XG4gIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50ID0gKCkgPT4ge1xuICAgIHJlc3VsdHNDb3VudCA9IDA7XG4gIH07XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gc3JjL2F1dG90cmFja01lbW9pemUvYXV0b3RyYWNrTWVtb2l6ZS50c1xuZnVuY3Rpb24gYXV0b3RyYWNrTWVtb2l6ZShmdW5jKSB7XG4gIGNvbnN0IG5vZGUgPSBjcmVhdGVOb2RlKFxuICAgIFtdXG4gICk7XG4gIGxldCBsYXN0QXJncyA9IG51bGw7XG4gIGNvbnN0IHNoYWxsb3dFcXVhbCA9IGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvcihyZWZlcmVuY2VFcXVhbGl0eUNoZWNrKTtcbiAgY29uc3QgY2FjaGUgPSBjcmVhdGVDYWNoZSgoKSA9PiB7XG4gICAgY29uc3QgcmVzID0gZnVuYy5hcHBseShudWxsLCBub2RlLnByb3h5KTtcbiAgICByZXR1cm4gcmVzO1xuICB9KTtcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgaWYgKCFzaGFsbG93RXF1YWwobGFzdEFyZ3MsIGFyZ3VtZW50cykpIHtcbiAgICAgIHVwZGF0ZU5vZGUobm9kZSwgYXJndW1lbnRzKTtcbiAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGUudmFsdWU7XG4gIH1cbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcbiAgICByZXR1cm4gY2FjaGUuY2xlYXIoKTtcbiAgfTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBzcmMvd2Vha01hcE1lbW9pemUudHNcbnZhciBTdHJvbmdSZWYgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIGRlcmVmKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG59O1xudmFyIFJlZiA9IHR5cGVvZiBXZWFrUmVmICE9PSBcInVuZGVmaW5lZFwiID8gV2Vha1JlZiA6IFN0cm9uZ1JlZjtcbnZhciBVTlRFUk1JTkFURUQgPSAwO1xudmFyIFRFUk1JTkFURUQgPSAxO1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGVOb2RlKCkge1xuICByZXR1cm4ge1xuICAgIHM6IFVOVEVSTUlOQVRFRCxcbiAgICB2OiB2b2lkIDAsXG4gICAgbzogbnVsbCxcbiAgICBwOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiB3ZWFrTWFwTWVtb2l6ZShmdW5jLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGZuTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICBjb25zdCB7IHJlc3VsdEVxdWFsaXR5Q2hlY2sgfSA9IG9wdGlvbnM7XG4gIGxldCBsYXN0UmVzdWx0O1xuICBsZXQgcmVzdWx0c0NvdW50ID0gMDtcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgbGV0IGNhY2hlTm9kZSA9IGZuTm9kZTtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gYXJndW1lbnRzO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIgJiYgYXJnICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBvYmplY3RDYWNoZSA9IGNhY2hlTm9kZS5vO1xuICAgICAgICBpZiAob2JqZWN0Q2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICBjYWNoZU5vZGUubyA9IG9iamVjdENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JqZWN0Tm9kZSA9IG9iamVjdENhY2hlLmdldChhcmcpO1xuICAgICAgICBpZiAob2JqZWN0Tm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gY3JlYXRlQ2FjaGVOb2RlKCk7XG4gICAgICAgICAgb2JqZWN0Q2FjaGUuc2V0KGFyZywgY2FjaGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBvYmplY3ROb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJpbWl0aXZlQ2FjaGUgPSBjYWNoZU5vZGUucDtcbiAgICAgICAgaWYgKHByaW1pdGl2ZUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgY2FjaGVOb2RlLnAgPSBwcmltaXRpdmVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpbWl0aXZlTm9kZSA9IHByaW1pdGl2ZUNhY2hlLmdldChhcmcpO1xuICAgICAgICBpZiAocHJpbWl0aXZlTm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gY3JlYXRlQ2FjaGVOb2RlKCk7XG4gICAgICAgICAgcHJpbWl0aXZlQ2FjaGUuc2V0KGFyZywgY2FjaGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBwcmltaXRpdmVOb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRlcm1pbmF0ZWROb2RlID0gY2FjaGVOb2RlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGNhY2hlTm9kZS5zID09PSBURVJNSU5BVEVEKSB7XG4gICAgICByZXN1bHQgPSBjYWNoZU5vZGUudjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgcmVzdWx0c0NvdW50Kys7XG4gICAgfVxuICAgIHRlcm1pbmF0ZWROb2RlLnMgPSBURVJNSU5BVEVEO1xuICAgIGlmIChyZXN1bHRFcXVhbGl0eUNoZWNrKSB7XG4gICAgICBjb25zdCBsYXN0UmVzdWx0VmFsdWUgPSBsYXN0UmVzdWx0Py5kZXJlZj8uKCkgPz8gbGFzdFJlc3VsdDtcbiAgICAgIGlmIChsYXN0UmVzdWx0VmFsdWUgIT0gbnVsbCAmJiByZXN1bHRFcXVhbGl0eUNoZWNrKGxhc3RSZXN1bHRWYWx1ZSwgcmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSBsYXN0UmVzdWx0VmFsdWU7XG4gICAgICAgIHJlc3VsdHNDb3VudCAhPT0gMCAmJiByZXN1bHRzQ291bnQtLTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5lZWRzV2Vha1JlZiA9IHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgcmVzdWx0ICE9PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIGxhc3RSZXN1bHQgPSBuZWVkc1dlYWtSZWYgPyBuZXcgUmVmKHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgfVxuICAgIHRlcm1pbmF0ZWROb2RlLnYgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBtZW1vaXplZC5jbGVhckNhY2hlID0gKCkgPT4ge1xuICAgIGZuTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50KCk7XG4gIH07XG4gIG1lbW9pemVkLnJlc3VsdHNDb3VudCA9ICgpID0+IHJlc3VsdHNDb3VudDtcbiAgbWVtb2l6ZWQucmVzZXRSZXN1bHRzQ291bnQgPSAoKSA9PiB7XG4gICAgcmVzdWx0c0NvdW50ID0gMDtcbiAgfTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBzcmMvY3JlYXRlU2VsZWN0b3JDcmVhdG9yLnRzXG5mdW5jdGlvbiBjcmVhdGVTZWxlY3RvckNyZWF0b3IobWVtb2l6ZU9yT3B0aW9ucywgLi4ubWVtb2l6ZU9wdGlvbnNGcm9tQXJncykge1xuICBjb25zdCBjcmVhdGVTZWxlY3RvckNyZWF0b3JPcHRpb25zID0gdHlwZW9mIG1lbW9pemVPck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHtcbiAgICBtZW1vaXplOiBtZW1vaXplT3JPcHRpb25zLFxuICAgIG1lbW9pemVPcHRpb25zOiBtZW1vaXplT3B0aW9uc0Zyb21BcmdzXG4gIH0gOiBtZW1vaXplT3JPcHRpb25zO1xuICBjb25zdCBjcmVhdGVTZWxlY3RvcjIgPSAoLi4uY3JlYXRlU2VsZWN0b3JBcmdzKSA9PiB7XG4gICAgbGV0IHJlY29tcHV0YXRpb25zID0gMDtcbiAgICBsZXQgZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zID0gMDtcbiAgICBsZXQgbGFzdFJlc3VsdDtcbiAgICBsZXQgZGlyZWN0bHlQYXNzZWRPcHRpb25zID0ge307XG4gICAgbGV0IHJlc3VsdEZ1bmMgPSBjcmVhdGVTZWxlY3RvckFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRGdW5jID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBkaXJlY3RseVBhc3NlZE9wdGlvbnMgPSByZXN1bHRGdW5jO1xuICAgICAgcmVzdWx0RnVuYyA9IGNyZWF0ZVNlbGVjdG9yQXJncy5wb3AoKTtcbiAgICB9XG4gICAgYXNzZXJ0SXNGdW5jdGlvbihcbiAgICAgIHJlc3VsdEZ1bmMsXG4gICAgICBgY3JlYXRlU2VsZWN0b3IgZXhwZWN0cyBhbiBvdXRwdXQgZnVuY3Rpb24gYWZ0ZXIgdGhlIGlucHV0cywgYnV0IHJlY2VpdmVkOiBbJHt0eXBlb2YgcmVzdWx0RnVuY31dYFxuICAgICk7XG4gICAgY29uc3QgY29tYmluZWRPcHRpb25zID0ge1xuICAgICAgLi4uY3JlYXRlU2VsZWN0b3JDcmVhdG9yT3B0aW9ucyxcbiAgICAgIC4uLmRpcmVjdGx5UGFzc2VkT3B0aW9uc1xuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgbWVtb2l6ZSxcbiAgICAgIG1lbW9pemVPcHRpb25zID0gW10sXG4gICAgICBhcmdzTWVtb2l6ZSA9IHdlYWtNYXBNZW1vaXplLFxuICAgICAgYXJnc01lbW9pemVPcHRpb25zID0gW10sXG4gICAgICBkZXZNb2RlQ2hlY2tzID0ge31cbiAgICB9ID0gY29tYmluZWRPcHRpb25zO1xuICAgIGNvbnN0IGZpbmFsTWVtb2l6ZU9wdGlvbnMgPSBlbnN1cmVJc0FycmF5KG1lbW9pemVPcHRpb25zKTtcbiAgICBjb25zdCBmaW5hbEFyZ3NNZW1vaXplT3B0aW9ucyA9IGVuc3VyZUlzQXJyYXkoYXJnc01lbW9pemVPcHRpb25zKTtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBnZXREZXBlbmRlbmNpZXMoY3JlYXRlU2VsZWN0b3JBcmdzKTtcbiAgICBjb25zdCBtZW1vaXplZFJlc3VsdEZ1bmMgPSBtZW1vaXplKGZ1bmN0aW9uIHJlY29tcHV0YXRpb25XcmFwcGVyKCkge1xuICAgICAgcmVjb21wdXRhdGlvbnMrKztcbiAgICAgIHJldHVybiByZXN1bHRGdW5jLmFwcGx5KFxuICAgICAgICBudWxsLFxuICAgICAgICBhcmd1bWVudHNcbiAgICAgICk7XG4gICAgfSwgLi4uZmluYWxNZW1vaXplT3B0aW9ucyk7XG4gICAgbGV0IGZpcnN0UnVuID0gdHJ1ZTtcbiAgICBjb25zdCBzZWxlY3RvciA9IGFyZ3NNZW1vaXplKGZ1bmN0aW9uIGRlcGVuZGVuY2llc0NoZWNrZXIoKSB7XG4gICAgICBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMrKztcbiAgICAgIGNvbnN0IGlucHV0U2VsZWN0b3JSZXN1bHRzID0gY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzKFxuICAgICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICAgIGFyZ3VtZW50c1xuICAgICAgKTtcbiAgICAgIGxhc3RSZXN1bHQgPSBtZW1vaXplZFJlc3VsdEZ1bmMuYXBwbHkobnVsbCwgaW5wdXRTZWxlY3RvclJlc3VsdHMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCB7IGlkZW50aXR5RnVuY3Rpb25DaGVjaywgaW5wdXRTdGFiaWxpdHlDaGVjayB9ID0gZ2V0RGV2TW9kZUNoZWNrc0V4ZWN1dGlvbkluZm8oZmlyc3RSdW4sIGRldk1vZGVDaGVja3MpO1xuICAgICAgICBpZiAoaWRlbnRpdHlGdW5jdGlvbkNoZWNrLnNob3VsZFJ1bikge1xuICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjay5ydW4oXG4gICAgICAgICAgICByZXN1bHRGdW5jLFxuICAgICAgICAgICAgaW5wdXRTZWxlY3RvclJlc3VsdHMsXG4gICAgICAgICAgICBsYXN0UmVzdWx0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRTdGFiaWxpdHlDaGVjay5zaG91bGRSdW4pIHtcbiAgICAgICAgICBjb25zdCBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkgPSBjb2xsZWN0SW5wdXRTZWxlY3RvclJlc3VsdHMoXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICBhcmd1bWVudHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGlucHV0U3RhYmlsaXR5Q2hlY2sucnVuKFxuICAgICAgICAgICAgeyBpbnB1dFNlbGVjdG9yUmVzdWx0cywgaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5IH0sXG4gICAgICAgICAgICB7IG1lbW9pemUsIG1lbW9pemVPcHRpb25zOiBmaW5hbE1lbW9pemVPcHRpb25zIH0sXG4gICAgICAgICAgICBhcmd1bWVudHNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFJ1bilcbiAgICAgICAgICBmaXJzdFJ1biA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfSwgLi4uZmluYWxBcmdzTWVtb2l6ZU9wdGlvbnMpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHNlbGVjdG9yLCB7XG4gICAgICByZXN1bHRGdW5jLFxuICAgICAgbWVtb2l6ZWRSZXN1bHRGdW5jLFxuICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zOiAoKSA9PiBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMsXG4gICAgICByZXNldERlcGVuZGVuY3lSZWNvbXB1dGF0aW9uczogKCkgPT4ge1xuICAgICAgICBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMgPSAwO1xuICAgICAgfSxcbiAgICAgIGxhc3RSZXN1bHQ6ICgpID0+IGxhc3RSZXN1bHQsXG4gICAgICByZWNvbXB1dGF0aW9uczogKCkgPT4gcmVjb21wdXRhdGlvbnMsXG4gICAgICByZXNldFJlY29tcHV0YXRpb25zOiAoKSA9PiB7XG4gICAgICAgIHJlY29tcHV0YXRpb25zID0gMDtcbiAgICAgIH0sXG4gICAgICBtZW1vaXplLFxuICAgICAgYXJnc01lbW9pemVcbiAgICB9KTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihjcmVhdGVTZWxlY3RvcjIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yMjtcbn1cbnZhciBjcmVhdGVTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZWxlY3RvckNyZWF0b3Iod2Vha01hcE1lbW9pemUpO1xuXG4vLyBzcmMvY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yLnRzXG52YXIgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yID0gT2JqZWN0LmFzc2lnbihcbiAgKGlucHV0U2VsZWN0b3JzT2JqZWN0LCBzZWxlY3RvckNyZWF0b3IgPSBjcmVhdGVTZWxlY3RvcikgPT4ge1xuICAgIGFzc2VydElzT2JqZWN0KFxuICAgICAgaW5wdXRTZWxlY3RvcnNPYmplY3QsXG4gICAgICBgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIGV4cGVjdHMgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgYSBzZWxlY3RvciwgaW5zdGVhZCByZWNlaXZlZCBhICR7dHlwZW9mIGlucHV0U2VsZWN0b3JzT2JqZWN0fWBcbiAgICApO1xuICAgIGNvbnN0IGlucHV0U2VsZWN0b3JLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTZWxlY3RvcnNPYmplY3QpO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGlucHV0U2VsZWN0b3JLZXlzLm1hcChcbiAgICAgIChrZXkpID0+IGlucHV0U2VsZWN0b3JzT2JqZWN0W2tleV1cbiAgICApO1xuICAgIGNvbnN0IHN0cnVjdHVyZWRTZWxlY3RvciA9IHNlbGVjdG9yQ3JlYXRvcihcbiAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgICguLi5pbnB1dFNlbGVjdG9yUmVzdWx0cykgPT4ge1xuICAgICAgICByZXR1cm4gaW5wdXRTZWxlY3RvclJlc3VsdHMucmVkdWNlKChjb21wb3NpdGlvbiwgdmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29tcG9zaXRpb25baW5wdXRTZWxlY3RvcktleXNbaW5kZXhdXSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBjb21wb3NpdGlvbjtcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRTZWxlY3RvcjtcbiAgfSxcbiAgeyB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciB9XG4pO1xuZXhwb3J0IHtcbiAgY3JlYXRlU2VsZWN0b3IsXG4gIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yLFxuICBscnVNZW1vaXplLFxuICByZWZlcmVuY2VFcXVhbGl0eUNoZWNrLFxuICBzZXRHbG9iYWxEZXZNb2RlQ2hlY2tzLFxuICBhdXRvdHJhY2tNZW1vaXplIGFzIHVuc3RhYmxlX2F1dG90cmFja01lbW9pemUsXG4gIHdlYWtNYXBNZW1vaXplXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzZWxlY3QubWpzLm1hcCJdLCJuYW1lcyI6WyJydW5JZGVudGl0eUZ1bmN0aW9uQ2hlY2siLCJyZXN1bHRGdW5jIiwiaW5wdXRTZWxlY3RvcnNSZXN1bHRzIiwib3V0cHV0U2VsZWN0b3JSZXN1bHQiLCJsZW5ndGgiLCJpc0lucHV0U2FtZUFzT3V0cHV0IiwiZW1wdHlPYmplY3QiLCJzdGFjayIsIkVycm9yIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwicnVuSW5wdXRTdGFiaWxpdHlDaGVjayIsImlucHV0U2VsZWN0b3JSZXN1bHRzT2JqZWN0Iiwib3B0aW9ucyIsImlucHV0U2VsZWN0b3JBcmdzIiwibWVtb2l6ZSIsIm1lbW9pemVPcHRpb25zIiwiaW5wdXRTZWxlY3RvclJlc3VsdHMiLCJpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkiLCJjcmVhdGVBbkVtcHR5T2JqZWN0IiwiYXJlSW5wdXRTZWxlY3RvclJlc3VsdHNFcXVhbCIsImFwcGx5IiwiYXJndW1lbnRzIiwiZmlyc3RJbnB1dHMiLCJzZWNvbmRJbnB1dHMiLCJnbG9iYWxEZXZNb2RlQ2hlY2tzIiwiaW5wdXRTdGFiaWxpdHlDaGVjayIsImlkZW50aXR5RnVuY3Rpb25DaGVjayIsInNldEdsb2JhbERldk1vZGVDaGVja3MiLCJkZXZNb2RlQ2hlY2tzIiwiT2JqZWN0IiwiYXNzaWduIiwiTk9UX0ZPVU5EIiwiYXNzZXJ0SXNGdW5jdGlvbiIsImZ1bmMiLCJlcnJvck1lc3NhZ2UiLCJUeXBlRXJyb3IiLCJhc3NlcnRJc09iamVjdCIsIm9iamVjdCIsImFzc2VydElzQXJyYXlPZkZ1bmN0aW9ucyIsImFycmF5IiwiZXZlcnkiLCJpdGVtIiwiaXRlbVR5cGVzIiwibWFwIiwibmFtZSIsImpvaW4iLCJlbnN1cmVJc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0RGVwZW5kZW5jaWVzIiwiY3JlYXRlU2VsZWN0b3JBcmdzIiwiZGVwZW5kZW5jaWVzIiwiY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzIiwiaSIsInB1c2giLCJnZXREZXZNb2RlQ2hlY2tzRXhlY3V0aW9uSW5mbyIsImZpcnN0UnVuIiwic2hvdWxkUnVuIiwicnVuIiwiJFJFVklTSU9OIiwiQ1VSUkVOVF9UUkFDS0VSIiwiQ2VsbCIsInZhbHVlIiwiYWRkIiwiX3ZhbHVlIiwibmV3VmFsdWUiLCJyZXZpc2lvbiIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbFZhbHVlIiwiaXNFcXVhbCIsInRyaXBsZUVxIiwiX2lzRXF1YWwiLCJfbGFzdFZhbHVlIiwiYSIsImIiLCJUcmFja2luZ0NhY2hlIiwiY2xlYXIiLCJfY2FjaGVkVmFsdWUiLCJfY2FjaGVkUmV2aXNpb24iLCJfZGVwcyIsImhpdHMiLCJmbiIsImN1cnJlbnRUcmFja2VyIiwiU2V0IiwicHJldlRyYWNrZXIiLCJmcm9tIiwiTWF0aCIsIm1heCIsImQiLCJnZXRWYWx1ZSIsImNlbGwiLCJzZXRWYWx1ZSIsInN0b3JhZ2UiLCJjcmVhdGVDZWxsIiwiY3JlYXRlQ2FjaGUiLCJuZXZlckVxIiwiY3JlYXRlVGFnIiwiZGlydHlUYWciLCJ0YWciLCJjb25zdW1lQ29sbGVjdGlvbiIsIm5vZGUiLCJjb2xsZWN0aW9uVGFnIiwiZGlydHlDb2xsZWN0aW9uIiwiUkVEVVhfUFJPWFlfTEFCRUwiLCJTeW1ib2wiLCJuZXh0SWQiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiT2JqZWN0VHJlZU5vZGUiLCJwcm94eSIsIlByb3h5Iiwib2JqZWN0UHJveHlIYW5kbGVyIiwidGFncyIsImNoaWxkcmVuIiwiaWQiLCJnZXQiLCJrZXkiLCJjYWxjdWxhdGVSZXN1bHQiLCJjaGlsZFZhbHVlIiwiUmVmbGVjdCIsImNoaWxkTm9kZSIsImNyZWF0ZU5vZGUiLCJyZXMiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHJvcCIsImhhcyIsIkFycmF5VHJlZU5vZGUiLCJhcnJheVByb3h5SGFuZGxlciIsInVwZGF0ZU5vZGUiLCJvbGRLZXlzU2l6ZSIsIm5ld0tleXNTaXplIiwiYW55S2V5c0FkZGVkIiwiX2tleSIsImlzRGlmZmVyZW50IiwibmV3Q2hpbGRWYWx1ZSIsImRlbGV0ZU5vZGUiLCJjcmVhdGVTaW5nbGV0b25DYWNoZSIsImVxdWFscyIsImVudHJ5IiwicHV0IiwiZ2V0RW50cmllcyIsImNyZWF0ZUxydUNhY2hlIiwibWF4U2l6ZSIsImVudHJpZXMiLCJjYWNoZUluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwidW5zaGlmdCIsInBvcCIsInJlZmVyZW5jZUVxdWFsaXR5Q2hlY2siLCJjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IiLCJlcXVhbGl0eUNoZWNrIiwiYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwiLCJwcmV2IiwibmV4dCIsImxydU1lbW9pemUiLCJlcXVhbGl0eUNoZWNrT3JPcHRpb25zIiwicHJvdmlkZWRPcHRpb25zIiwicmVzdWx0RXF1YWxpdHlDaGVjayIsImNvbXBhcmF0b3IiLCJyZXN1bHRzQ291bnQiLCJjYWNoZSIsIm1lbW9pemVkIiwibWF0Y2hpbmdFbnRyeSIsImZpbmQiLCJjbGVhckNhY2hlIiwicmVzZXRSZXN1bHRzQ291bnQiLCJhdXRvdHJhY2tNZW1vaXplIiwibGFzdEFyZ3MiLCJzaGFsbG93RXF1YWwiLCJTdHJvbmdSZWYiLCJkZXJlZiIsIlJlZiIsIldlYWtSZWYiLCJVTlRFUk1JTkFURUQiLCJURVJNSU5BVEVEIiwiY3JlYXRlQ2FjaGVOb2RlIiwicyIsInYiLCJvIiwicCIsIndlYWtNYXBNZW1vaXplIiwiZm5Ob2RlIiwibGFzdFJlc3VsdCIsImNhY2hlTm9kZSIsImwiLCJhcmciLCJvYmplY3RDYWNoZSIsIldlYWtNYXAiLCJvYmplY3ROb2RlIiwic2V0IiwicHJpbWl0aXZlQ2FjaGUiLCJNYXAiLCJwcmltaXRpdmVOb2RlIiwidGVybWluYXRlZE5vZGUiLCJyZXN1bHQiLCJsYXN0UmVzdWx0VmFsdWUiLCJuZWVkc1dlYWtSZWYiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IiLCJtZW1vaXplT3JPcHRpb25zIiwibWVtb2l6ZU9wdGlvbnNGcm9tQXJncyIsImNyZWF0ZVNlbGVjdG9yQ3JlYXRvck9wdGlvbnMiLCJjcmVhdGVTZWxlY3RvcjIiLCJyZWNvbXB1dGF0aW9ucyIsImRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyIsImRpcmVjdGx5UGFzc2VkT3B0aW9ucyIsImNvbWJpbmVkT3B0aW9ucyIsImFyZ3NNZW1vaXplIiwiYXJnc01lbW9pemVPcHRpb25zIiwiZmluYWxNZW1vaXplT3B0aW9ucyIsImZpbmFsQXJnc01lbW9pemVPcHRpb25zIiwibWVtb2l6ZWRSZXN1bHRGdW5jIiwicmVjb21wdXRhdGlvbldyYXBwZXIiLCJzZWxlY3RvciIsImRlcGVuZGVuY2llc0NoZWNrZXIiLCJwcm9jZXNzIiwicmVzZXREZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMiLCJyZXNldFJlY29tcHV0YXRpb25zIiwid2l0aFR5cGVzIiwiY3JlYXRlU2VsZWN0b3IiLCJjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IiLCJpbnB1dFNlbGVjdG9yc09iamVjdCIsInNlbGVjdG9yQ3JlYXRvciIsImlucHV0U2VsZWN0b3JLZXlzIiwia2V5cyIsInN0cnVjdHVyZWRTZWxlY3RvciIsInJlZHVjZSIsImNvbXBvc2l0aW9uIiwiaW5kZXgiLCJ1bnN0YWJsZV9hdXRvdHJhY2tNZW1vaXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/reselect/dist/reselect.mjs\n"));

/***/ })

});